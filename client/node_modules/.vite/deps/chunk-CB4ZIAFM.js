import {
  coreSystem,
  realmPlugin,
  require_Lexical,
  require_LexicalComposerContext,
  require_LexicalUtils,
  system
} from "./chunk-I3I4FGWZ.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/@lexical/list/LexicalList.dev.js
var require_LexicalList_dev = __commonJS({
  "node_modules/@lexical/list/LexicalList.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var utils = require_LexicalUtils();
    function $getListDepth2(listNode) {
      let depth = 1;
      let parent = listNode.getParent();
      while (parent != null) {
        if ($isListItemNode4(parent)) {
          const parentList = parent.getParent();
          if ($isListNode4(parentList)) {
            depth++;
            parent = parentList.getParent();
            continue;
          }
          {
            throw Error(`A ListItemNode must have a ListNode for a parent.`);
          }
        }
        return depth;
      }
      return depth;
    }
    function $getTopListNode(listItem) {
      let list = listItem.getParent();
      if (!$isListNode4(list)) {
        {
          throw Error(`A ListItemNode must have a ListNode for a parent.`);
        }
      }
      let parent = list;
      while (parent !== null) {
        parent = parent.getParent();
        if ($isListNode4(parent)) {
          list = parent;
        }
      }
      return list;
    }
    function $getAllListItems(node) {
      let listItemNodes = [];
      const listChildren = node.getChildren().filter($isListItemNode4);
      for (let i = 0; i < listChildren.length; i++) {
        const listItemNode = listChildren[i];
        const firstChild = listItemNode.getFirstChild();
        if ($isListNode4(firstChild)) {
          listItemNodes = listItemNodes.concat($getAllListItems(firstChild));
        } else {
          listItemNodes.push(listItemNode);
        }
      }
      return listItemNodes;
    }
    function isNestedListNode(node) {
      return $isListItemNode4(node) && $isListNode4(node.getFirstChild());
    }
    function $removeHighestEmptyListParent(sublist) {
      let emptyListPtr = sublist;
      while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {
        const parent = emptyListPtr.getParent();
        if (parent == null || !($isListItemNode4(emptyListPtr) || $isListNode4(emptyListPtr))) {
          break;
        }
        emptyListPtr = parent;
      }
      emptyListPtr.remove();
    }
    function wrapInListItem(node) {
      const listItemWrapper = $createListItemNode3();
      return listItemWrapper.append(node);
    }
    function $isSelectingEmptyListItem(anchorNode, nodes) {
      return $isListItemNode4(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);
    }
    function $getListItemValue(listItem) {
      const list = listItem.getParent();
      let value = 1;
      if (list != null) {
        if (!$isListNode4(list)) {
          {
            throw Error(`$getListItemValue: list node is not parent of list item node`);
          }
        } else {
          value = list.getStart();
        }
      }
      const siblings = listItem.getPreviousSiblings();
      for (let i = 0; i < siblings.length; i++) {
        const sibling = siblings[i];
        if ($isListItemNode4(sibling) && !$isListNode4(sibling.getFirstChild())) {
          value++;
        }
      }
      return value;
    }
    function insertList(editor, listType) {
      editor.update(() => {
        const selection = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {
          const nodes = selection.getNodes();
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          const anchorNodeParent = anchorNode.getParent();
          if ($isSelectingEmptyListItem(anchorNode, nodes)) {
            const list = $createListNode2(listType);
            if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {
              anchorNode.replace(list);
              const listItem = $createListItemNode3();
              if (lexical.$isElementNode(anchorNode)) {
                listItem.setFormat(anchorNode.getFormatType());
                listItem.setIndent(anchorNode.getIndent());
              }
              list.append(listItem);
            } else if ($isListItemNode4(anchorNode)) {
              const parent = anchorNode.getParentOrThrow();
              append(list, parent.getChildren());
              parent.replace(list);
            }
            return;
          } else {
            const handled = /* @__PURE__ */ new Set();
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {
                createListOrMerge(node, listType);
                continue;
              }
              if (lexical.$isLeafNode(node)) {
                let parent = node.getParent();
                while (parent != null) {
                  const parentKey = parent.getKey();
                  if ($isListNode4(parent)) {
                    if (!handled.has(parentKey)) {
                      const newListNode = $createListNode2(listType);
                      append(newListNode, parent.getChildren());
                      parent.replace(newListNode);
                      updateChildrenListItemValue(newListNode);
                      handled.add(parentKey);
                    }
                    break;
                  } else {
                    const nextParent = parent.getParent();
                    if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {
                      handled.add(parentKey);
                      createListOrMerge(parent, listType);
                      break;
                    }
                    parent = nextParent;
                  }
                }
              }
            }
          }
        }
      });
    }
    function append(node, nodesToAppend) {
      node.splice(node.getChildrenSize(), 0, nodesToAppend);
    }
    function createListOrMerge(node, listType) {
      if ($isListNode4(node)) {
        return node;
      }
      const previousSibling = node.getPreviousSibling();
      const nextSibling = node.getNextSibling();
      const listItem = $createListItemNode3();
      listItem.setFormat(node.getFormatType());
      listItem.setIndent(node.getIndent());
      append(listItem, node.getChildren());
      if ($isListNode4(previousSibling) && listType === previousSibling.getListType()) {
        previousSibling.append(listItem);
        node.remove();
        if ($isListNode4(nextSibling) && listType === nextSibling.getListType()) {
          append(previousSibling, nextSibling.getChildren());
          nextSibling.remove();
        }
        return previousSibling;
      } else if ($isListNode4(nextSibling) && listType === nextSibling.getListType()) {
        nextSibling.getFirstChildOrThrow().insertBefore(listItem);
        node.remove();
        return nextSibling;
      } else {
        const list = $createListNode2(listType);
        list.append(listItem);
        node.replace(list);
        updateChildrenListItemValue(list);
        return list;
      }
    }
    function mergeLists(list1, list2) {
      const listItem1 = list1.getLastChild();
      const listItem2 = list2.getFirstChild();
      if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {
        mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());
        listItem2.remove();
      }
      const toMerge = list2.getChildren();
      if (toMerge.length > 0) {
        list1.append(...toMerge);
        updateChildrenListItemValue(list1);
      }
      list2.remove();
    }
    function removeList(editor) {
      editor.update(() => {
        const selection = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection)) {
          const listNodes = /* @__PURE__ */ new Set();
          const nodes = selection.getNodes();
          const anchorNode = selection.anchor.getNode();
          if ($isSelectingEmptyListItem(anchorNode, nodes)) {
            listNodes.add($getTopListNode(anchorNode));
          } else {
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              if (lexical.$isLeafNode(node)) {
                const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode2);
                if (listItemNode != null) {
                  listNodes.add($getTopListNode(listItemNode));
                }
              }
            }
          }
          for (const listNode of listNodes) {
            let insertionPoint = listNode;
            const listItems = $getAllListItems(listNode);
            for (const listItemNode of listItems) {
              const paragraph = lexical.$createParagraphNode();
              append(paragraph, listItemNode.getChildren());
              insertionPoint.insertAfter(paragraph);
              insertionPoint = paragraph;
              if (listItemNode.__key === selection.anchor.key) {
                selection.anchor.set(paragraph.getKey(), 0, "element");
              }
              if (listItemNode.__key === selection.focus.key) {
                selection.focus.set(paragraph.getKey(), 0, "element");
              }
              listItemNode.remove();
            }
            listNode.remove();
          }
        }
      });
    }
    function updateChildrenListItemValue(list, children) {
      const childrenOrExisting = children || list.getChildren();
      if (childrenOrExisting !== void 0) {
        for (let i = 0; i < childrenOrExisting.length; i++) {
          const child = childrenOrExisting[i];
          if ($isListItemNode4(child)) {
            const prevValue = child.getValue();
            const nextValue = $getListItemValue(child);
            if (prevValue !== nextValue) {
              child.setValue(nextValue);
            }
          }
        }
      }
    }
    function $handleIndent(listItemNode) {
      const removed = /* @__PURE__ */ new Set();
      if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {
        return;
      }
      const parent = listItemNode.getParent();
      const nextSibling = listItemNode.getNextSibling();
      const previousSibling = listItemNode.getPreviousSibling();
      if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {
        const innerList = previousSibling.getFirstChild();
        if ($isListNode4(innerList)) {
          innerList.append(listItemNode);
          const nextInnerList = nextSibling.getFirstChild();
          if ($isListNode4(nextInnerList)) {
            const children = nextInnerList.getChildren();
            append(innerList, children);
            nextSibling.remove();
            removed.add(nextSibling.getKey());
          }
          updateChildrenListItemValue(innerList);
        }
      } else if (isNestedListNode(nextSibling)) {
        const innerList = nextSibling.getFirstChild();
        if ($isListNode4(innerList)) {
          const firstChild = innerList.getFirstChild();
          if (firstChild !== null) {
            firstChild.insertBefore(listItemNode);
          }
          updateChildrenListItemValue(innerList);
        }
      } else if (isNestedListNode(previousSibling)) {
        const innerList = previousSibling.getFirstChild();
        if ($isListNode4(innerList)) {
          innerList.append(listItemNode);
          updateChildrenListItemValue(innerList);
        }
      } else {
        if ($isListNode4(parent)) {
          const newListItem = $createListItemNode3();
          const newList = $createListNode2(parent.getListType());
          newListItem.append(newList);
          newList.append(listItemNode);
          if (previousSibling) {
            previousSibling.insertAfter(newListItem);
          } else if (nextSibling) {
            nextSibling.insertBefore(newListItem);
          } else {
            parent.append(newListItem);
          }
          updateChildrenListItemValue(newList);
        }
      }
      if ($isListNode4(parent)) {
        updateChildrenListItemValue(parent);
      }
    }
    function $handleOutdent(listItemNode) {
      if (isNestedListNode(listItemNode)) {
        return;
      }
      const parentList = listItemNode.getParent();
      const grandparentListItem = parentList ? parentList.getParent() : void 0;
      const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : void 0;
      if ($isListNode4(greatGrandparentList) && $isListItemNode4(grandparentListItem) && $isListNode4(parentList)) {
        const firstChild = parentList ? parentList.getFirstChild() : void 0;
        const lastChild = parentList ? parentList.getLastChild() : void 0;
        if (listItemNode.is(firstChild)) {
          grandparentListItem.insertBefore(listItemNode);
          if (parentList.isEmpty()) {
            grandparentListItem.remove();
          }
        } else if (listItemNode.is(lastChild)) {
          grandparentListItem.insertAfter(listItemNode);
          if (parentList.isEmpty()) {
            grandparentListItem.remove();
          }
        } else {
          const listType = parentList.getListType();
          const previousSiblingsListItem = $createListItemNode3();
          const previousSiblingsList = $createListNode2(listType);
          previousSiblingsListItem.append(previousSiblingsList);
          listItemNode.getPreviousSiblings().forEach((sibling) => previousSiblingsList.append(sibling));
          const nextSiblingsListItem = $createListItemNode3();
          const nextSiblingsList = $createListNode2(listType);
          nextSiblingsListItem.append(nextSiblingsList);
          append(nextSiblingsList, listItemNode.getNextSiblings());
          grandparentListItem.insertBefore(previousSiblingsListItem);
          grandparentListItem.insertAfter(nextSiblingsListItem);
          grandparentListItem.replace(listItemNode);
        }
        updateChildrenListItemValue(parentList);
        updateChildrenListItemValue(greatGrandparentList);
      }
    }
    function $handleListInsertParagraph() {
      const selection = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {
        return false;
      }
      const anchor = selection.anchor.getNode();
      if (!$isListItemNode4(anchor) || anchor.getChildrenSize() !== 0) {
        return false;
      }
      const topListNode = $getTopListNode(anchor);
      const parent = anchor.getParent();
      if (!$isListNode4(parent)) {
        throw Error(`A ListItemNode must have a ListNode for a parent.`);
      }
      const grandparent = parent.getParent();
      let replacementNode;
      if (lexical.$isRootOrShadowRoot(grandparent)) {
        replacementNode = lexical.$createParagraphNode();
        topListNode.insertAfter(replacementNode);
      } else if ($isListItemNode4(grandparent)) {
        replacementNode = $createListItemNode3();
        grandparent.insertAfter(replacementNode);
      } else {
        return false;
      }
      replacementNode.select();
      const nextSiblings = anchor.getNextSiblings();
      if (nextSiblings.length > 0) {
        const newList = $createListNode2(parent.getListType());
        if (lexical.$isParagraphNode(replacementNode)) {
          replacementNode.insertAfter(newList);
        } else {
          const newListItem = $createListItemNode3();
          newListItem.append(newList);
          replacementNode.insertAfter(newListItem);
        }
        nextSiblings.forEach((sibling) => {
          sibling.remove();
          newList.append(sibling);
        });
      }
      $removeHighestEmptyListParent(anchor);
      return true;
    }
    var ListItemNode2 = class _ListItemNode extends lexical.ElementNode {
      /** @internal */
      /** @internal */
      static getType() {
        return "listitem";
      }
      static clone(node) {
        return new _ListItemNode(node.__value, node.__checked, node.__key);
      }
      constructor(value, checked, key) {
        super(key);
        this.__value = value === void 0 ? 1 : value;
        this.__checked = checked;
      }
      createDOM(config) {
        const element = document.createElement("li");
        const parent = this.getParent();
        if ($isListNode4(parent) && parent.getListType() === "check") {
          updateListItemChecked(element, this, null);
        }
        element.value = this.__value;
        $setListItemThemeClassNames(element, config.theme, this);
        return element;
      }
      updateDOM(prevNode, dom, config) {
        const parent = this.getParent();
        if ($isListNode4(parent) && parent.getListType() === "check") {
          updateListItemChecked(dom, this, prevNode);
        }
        dom.value = this.__value;
        $setListItemThemeClassNames(dom, config.theme, this);
        return false;
      }
      static transform() {
        return (node) => {
          const parent = node.getParent();
          if ($isListNode4(parent)) {
            updateChildrenListItemValue(parent);
            if (parent.getListType() !== "check" && node.getChecked() != null) {
              node.setChecked(void 0);
            }
          }
        };
      }
      static importDOM() {
        return {
          li: (node) => ({
            conversion: convertListItemElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createListItemNode3();
        node.setChecked(serializedNode.checked);
        node.setValue(serializedNode.value);
        node.setFormat(serializedNode.format);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          checked: this.getChecked(),
          type: "listitem",
          value: this.getValue(),
          version: 1
        };
      }
      append(...nodes) {
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (lexical.$isElementNode(node) && this.canMergeWith(node)) {
            const children = node.getChildren();
            this.append(...children);
            node.remove();
          } else {
            super.append(node);
          }
        }
        return this;
      }
      replace(replaceWithNode, includeChildren) {
        if ($isListItemNode4(replaceWithNode)) {
          return super.replace(replaceWithNode);
        }
        this.setIndent(0);
        const list = this.getParentOrThrow();
        if (!$isListNode4(list))
          return replaceWithNode;
        if (list.__first === this.getKey()) {
          list.insertBefore(replaceWithNode);
        } else if (list.__last === this.getKey()) {
          list.insertAfter(replaceWithNode);
        } else {
          const newList = $createListNode2(list.getListType());
          let nextSibling = this.getNextSibling();
          while (nextSibling) {
            const nodeToAppend = nextSibling;
            nextSibling = nextSibling.getNextSibling();
            newList.append(nodeToAppend);
          }
          list.insertAfter(replaceWithNode);
          replaceWithNode.insertAfter(newList);
        }
        if (includeChildren) {
          this.getChildren().forEach((child) => {
            replaceWithNode.append(child);
          });
        }
        this.remove();
        if (list.getChildrenSize() === 0) {
          list.remove();
        }
        return replaceWithNode;
      }
      insertAfter(node, restoreSelection = true) {
        const listNode = this.getParentOrThrow();
        if (!$isListNode4(listNode)) {
          {
            throw Error(`insertAfter: list node is not parent of list item node`);
          }
        }
        const siblings = this.getNextSiblings();
        if ($isListItemNode4(node)) {
          const after = super.insertAfter(node, restoreSelection);
          const afterListNode = node.getParentOrThrow();
          if ($isListNode4(afterListNode)) {
            updateChildrenListItemValue(afterListNode);
          }
          return after;
        }
        if ($isListNode4(node)) {
          let child = node;
          const children = node.getChildren();
          for (let i = children.length - 1; i >= 0; i--) {
            child = children[i];
            this.insertAfter(child, restoreSelection);
          }
          return child;
        }
        listNode.insertAfter(node, restoreSelection);
        if (siblings.length !== 0) {
          const newListNode = $createListNode2(listNode.getListType());
          siblings.forEach((sibling) => newListNode.append(sibling));
          node.insertAfter(newListNode, restoreSelection);
        }
        return node;
      }
      remove(preserveEmptyParent) {
        const prevSibling = this.getPreviousSibling();
        const nextSibling = this.getNextSibling();
        super.remove(preserveEmptyParent);
        if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {
          mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());
          nextSibling.remove();
        } else if (nextSibling) {
          const parent = nextSibling.getParent();
          if ($isListNode4(parent)) {
            updateChildrenListItemValue(parent);
          }
        }
      }
      insertNewAfter(_, restoreSelection = true) {
        const newElement = $createListItemNode3(this.__checked == null ? void 0 : false);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart(selection) {
        const paragraph = lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => paragraph.append(child));
        const listNode = this.getParentOrThrow();
        const listNodeParent = listNode.getParentOrThrow();
        const isIndented = $isListItemNode4(listNodeParent);
        if (listNode.getChildrenSize() === 1) {
          if (isIndented) {
            listNode.remove();
            listNodeParent.select();
          } else {
            listNode.insertBefore(paragraph);
            listNode.remove();
            const anchor = selection.anchor;
            const focus = selection.focus;
            const key = paragraph.getKey();
            if (anchor.type === "element" && anchor.getNode().is(this)) {
              anchor.set(key, anchor.offset, "element");
            }
            if (focus.type === "element" && focus.getNode().is(this)) {
              focus.set(key, focus.offset, "element");
            }
          }
        } else {
          listNode.insertBefore(paragraph);
          this.remove();
        }
        return true;
      }
      getValue() {
        const self = this.getLatest();
        return self.__value;
      }
      setValue(value) {
        const self = this.getWritable();
        self.__value = value;
      }
      getChecked() {
        const self = this.getLatest();
        return self.__checked;
      }
      setChecked(checked) {
        const self = this.getWritable();
        self.__checked = checked;
      }
      toggleChecked() {
        this.setChecked(!this.__checked);
      }
      getIndent() {
        const parent = this.getParent();
        if (parent === null) {
          return this.getLatest().__indent;
        }
        let listNodeParent = parent.getParentOrThrow();
        let indentLevel = 0;
        while ($isListItemNode4(listNodeParent)) {
          listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();
          indentLevel++;
        }
        return indentLevel;
      }
      setIndent(indent) {
        if (!(typeof indent === "number" && indent > -1)) {
          throw Error(`Invalid indent value.`);
        }
        let currentIndent = this.getIndent();
        while (currentIndent !== indent) {
          if (currentIndent < indent) {
            $handleIndent(this);
            currentIndent++;
          } else {
            $handleOutdent(this);
            currentIndent--;
          }
        }
        return this;
      }
      insertBefore(nodeToInsert) {
        if ($isListItemNode4(nodeToInsert)) {
          const parent = this.getParentOrThrow();
          if ($isListNode4(parent)) {
            const siblings = this.getNextSiblings();
            updateChildrenListItemValue(parent, siblings);
          }
        }
        return super.insertBefore(nodeToInsert);
      }
      canInsertAfter(node) {
        return $isListItemNode4(node);
      }
      canReplaceWith(replacement) {
        return $isListItemNode4(replacement);
      }
      canMergeWith(node) {
        return lexical.$isParagraphNode(node) || $isListItemNode4(node);
      }
      extractWithChild(child, selection) {
        if (!lexical.$isRangeSelection(selection)) {
          return false;
        }
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;
      }
      isParentRequired() {
        return true;
      }
      createParentElementNode() {
        return $createListNode2("bullet");
      }
    };
    function $setListItemThemeClassNames(dom, editorThemeClasses, node) {
      const classesToAdd = [];
      const classesToRemove = [];
      const listTheme = editorThemeClasses.list;
      const listItemClassName = listTheme ? listTheme.listitem : void 0;
      let nestedListItemClassName;
      if (listTheme && listTheme.nested) {
        nestedListItemClassName = listTheme.nested.listitem;
      }
      if (listItemClassName !== void 0) {
        const listItemClasses = listItemClassName.split(" ");
        classesToAdd.push(...listItemClasses);
      }
      if (listTheme) {
        const parentNode = node.getParent();
        const isCheckList = $isListNode4(parentNode) && parentNode.getListType() === "check";
        const checked = node.getChecked();
        if (!isCheckList || checked) {
          classesToRemove.push(listTheme.listitemUnchecked);
        }
        if (!isCheckList || !checked) {
          classesToRemove.push(listTheme.listitemChecked);
        }
        if (isCheckList) {
          classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);
        }
      }
      if (nestedListItemClassName !== void 0) {
        const nestedListItemClasses = nestedListItemClassName.split(" ");
        if (node.getChildren().some((child) => $isListNode4(child))) {
          classesToAdd.push(...nestedListItemClasses);
        } else {
          classesToRemove.push(...nestedListItemClasses);
        }
      }
      if (classesToRemove.length > 0) {
        utils.removeClassNamesFromElement(dom, ...classesToRemove);
      }
      if (classesToAdd.length > 0) {
        utils.addClassNamesToElement(dom, ...classesToAdd);
      }
    }
    function updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {
      if ($isListNode4(listItemNode.getFirstChild())) {
        dom.removeAttribute("role");
        dom.removeAttribute("tabIndex");
        dom.removeAttribute("aria-checked");
      } else {
        dom.setAttribute("role", "checkbox");
        dom.setAttribute("tabIndex", "-1");
        if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {
          dom.setAttribute("aria-checked", listItemNode.getChecked() ? "true" : "false");
        }
      }
    }
    function convertListItemElement(domNode) {
      const checked = utils.isHTMLElement(domNode) && domNode.getAttribute("aria-checked") === "true";
      return {
        node: $createListItemNode3(checked)
      };
    }
    function $createListItemNode3(checked) {
      return lexical.$applyNodeReplacement(new ListItemNode2(void 0, checked));
    }
    function $isListItemNode4(node) {
      return node instanceof ListItemNode2;
    }
    var ListNode2 = class _ListNode extends lexical.ElementNode {
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "list";
      }
      static clone(node) {
        const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];
        return new _ListNode(listType, node.__start, node.__key);
      }
      constructor(listType, start, key) {
        super(key);
        const _listType = TAG_TO_LIST_TYPE[listType] || listType;
        this.__listType = _listType;
        this.__tag = _listType === "number" ? "ol" : "ul";
        this.__start = start;
      }
      getTag() {
        return this.__tag;
      }
      setListType(type) {
        const writable = this.getWritable();
        writable.__listType = type;
        writable.__tag = type === "number" ? "ol" : "ul";
      }
      getListType() {
        return this.__listType;
      }
      getStart() {
        return this.__start;
      }
      // View
      createDOM(config, _editor) {
        const tag = this.__tag;
        const dom = document.createElement(tag);
        if (this.__start !== 1) {
          dom.setAttribute("start", String(this.__start));
        }
        dom.__lexicalListType = this.__listType;
        setListThemeClassNames(dom, config.theme, this);
        return dom;
      }
      updateDOM(prevNode, dom, config) {
        if (prevNode.__tag !== this.__tag) {
          return true;
        }
        setListThemeClassNames(dom, config.theme, this);
        return false;
      }
      static importDOM() {
        return {
          ol: (node) => ({
            conversion: convertListNode,
            priority: 0
          }),
          ul: (node) => ({
            conversion: convertListNode,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createListNode2(serializedNode.listType, serializedNode.start);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && utils.isHTMLElement(element)) {
          if (this.__start !== 1) {
            element.setAttribute("start", String(this.__start));
          }
          if (this.__listType === "check") {
            element.setAttribute("__lexicalListType", "check");
          }
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          listType: this.getListType(),
          start: this.getStart(),
          tag: this.getTag(),
          type: "list",
          version: 1
        };
      }
      canBeEmpty() {
        return false;
      }
      canIndent() {
        return false;
      }
      append(...nodesToAppend) {
        for (let i = 0; i < nodesToAppend.length; i++) {
          const currentNode = nodesToAppend[i];
          if ($isListItemNode4(currentNode)) {
            super.append(currentNode);
          } else {
            const listItemNode = $createListItemNode3();
            if ($isListNode4(currentNode)) {
              listItemNode.append(currentNode);
            } else if (lexical.$isElementNode(currentNode)) {
              const textNode = lexical.$createTextNode(currentNode.getTextContent());
              listItemNode.append(textNode);
            } else {
              listItemNode.append(currentNode);
            }
            super.append(listItemNode);
          }
        }
        updateChildrenListItemValue(this);
        return this;
      }
      extractWithChild(child) {
        return $isListItemNode4(child);
      }
    };
    function setListThemeClassNames(dom, editorThemeClasses, node) {
      const classesToAdd = [];
      const classesToRemove = [];
      const listTheme = editorThemeClasses.list;
      if (listTheme !== void 0) {
        const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];
        const listDepth = $getListDepth2(node) - 1;
        const normalizedListDepth = listDepth % listLevelsClassNames.length;
        const listLevelClassName = listLevelsClassNames[normalizedListDepth];
        const listClassName = listTheme[node.__tag];
        let nestedListClassName;
        const nestedListTheme = listTheme.nested;
        if (nestedListTheme !== void 0 && nestedListTheme.list) {
          nestedListClassName = nestedListTheme.list;
        }
        if (listClassName !== void 0) {
          classesToAdd.push(listClassName);
        }
        if (listLevelClassName !== void 0) {
          const listItemClasses = listLevelClassName.split(" ");
          classesToAdd.push(...listItemClasses);
          for (let i = 0; i < listLevelsClassNames.length; i++) {
            if (i !== normalizedListDepth) {
              classesToRemove.push(node.__tag + i);
            }
          }
        }
        if (nestedListClassName !== void 0) {
          const nestedListItemClasses = nestedListClassName.split(" ");
          if (listDepth > 1) {
            classesToAdd.push(...nestedListItemClasses);
          } else {
            classesToRemove.push(...nestedListItemClasses);
          }
        }
      }
      if (classesToRemove.length > 0) {
        utils.removeClassNamesFromElement(dom, ...classesToRemove);
      }
      if (classesToAdd.length > 0) {
        utils.addClassNamesToElement(dom, ...classesToAdd);
      }
    }
    function normalizeChildren(nodes) {
      const normalizedListItems = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if ($isListItemNode4(node)) {
          normalizedListItems.push(node);
          const children = node.getChildren();
          if (children.length > 1) {
            children.forEach((child) => {
              if ($isListNode4(child)) {
                normalizedListItems.push(wrapInListItem(child));
              }
            });
          }
        } else {
          normalizedListItems.push(wrapInListItem(node));
        }
      }
      return normalizedListItems;
    }
    function convertListNode(domNode) {
      const nodeName = domNode.nodeName.toLowerCase();
      let node = null;
      if (nodeName === "ol") {
        const start = domNode.start;
        node = $createListNode2("number", start);
      } else if (nodeName === "ul") {
        if (utils.isHTMLElement(domNode) && domNode.getAttribute("__lexicallisttype") === "check") {
          node = $createListNode2("check");
        } else {
          node = $createListNode2("bullet");
        }
      }
      return {
        after: normalizeChildren,
        node
      };
    }
    var TAG_TO_LIST_TYPE = {
      ol: "number",
      ul: "bullet"
    };
    function $createListNode2(listType, start = 1) {
      return lexical.$applyNodeReplacement(new ListNode2(listType, start));
    }
    function $isListNode4(node) {
      return node instanceof ListNode2;
    }
    var INSERT_UNORDERED_LIST_COMMAND2 = lexical.createCommand("INSERT_UNORDERED_LIST_COMMAND");
    var INSERT_ORDERED_LIST_COMMAND2 = lexical.createCommand("INSERT_ORDERED_LIST_COMMAND");
    var INSERT_CHECK_LIST_COMMAND = lexical.createCommand("INSERT_CHECK_LIST_COMMAND");
    var REMOVE_LIST_COMMAND2 = lexical.createCommand("REMOVE_LIST_COMMAND");
    exports.$createListItemNode = $createListItemNode3;
    exports.$createListNode = $createListNode2;
    exports.$getListDepth = $getListDepth2;
    exports.$handleListInsertParagraph = $handleListInsertParagraph;
    exports.$isListItemNode = $isListItemNode4;
    exports.$isListNode = $isListNode4;
    exports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;
    exports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND2;
    exports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND2;
    exports.ListItemNode = ListItemNode2;
    exports.ListNode = ListNode2;
    exports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND2;
    exports.insertList = insertList;
    exports.removeList = removeList;
  }
});

// node_modules/@lexical/list/LexicalList.js
var require_LexicalList = __commonJS({
  "node_modules/@lexical/list/LexicalList.js"(exports, module) {
    "use strict";
    var LexicalList = true ? require_LexicalList_dev() : null;
    module.exports = LexicalList;
  }
});

// node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js
var require_LexicalTabIndentationPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalTabIndentationPlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var react = require_react();
    function indentOverTab(selection) {
      const nodes = selection.getNodes();
      const canIndentBlockNodes = utils.$filter(nodes, (node) => {
        if (lexical.$isBlockElementNode(node) && node.canIndent()) {
          return node;
        }
        return null;
      });
      if (canIndentBlockNodes.length > 0) {
        return true;
      }
      const anchor = selection.anchor;
      const focus = selection.focus;
      const first = focus.isBefore(anchor) ? focus : anchor;
      const firstNode = first.getNode();
      const firstBlock = utils.$getNearestBlockElementAncestorOrThrow(firstNode);
      if (firstBlock.canIndent()) {
        const firstBlockKey = firstBlock.getKey();
        let selectionAtStart = lexical.$createRangeSelection();
        selectionAtStart.anchor.set(firstBlockKey, 0, "element");
        selectionAtStart.focus.set(firstBlockKey, 0, "element");
        selectionAtStart = lexical.$normalizeSelection__EXPERIMENTAL(selectionAtStart);
        if (selectionAtStart.anchor.is(first)) {
          return true;
        }
      }
      return false;
    }
    function registerTabIndentation(editor) {
      return editor.registerCommand(lexical.KEY_TAB_COMMAND, (event) => {
        const selection = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection)) {
          return false;
        }
        event.preventDefault();
        const command = indentOverTab(selection) ? event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND : lexical.INSERT_TAB_COMMAND;
        return editor.dispatchCommand(command, void 0);
      }, lexical.COMMAND_PRIORITY_EDITOR);
    }
    function TabIndentationPlugin2() {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        return registerTabIndentation(editor);
      });
      return null;
    }
    exports.TabIndentationPlugin = TabIndentationPlugin2;
    exports.registerTabIndentation = registerTabIndentation;
  }
});

// node_modules/@lexical/react/LexicalTabIndentationPlugin.js
var require_LexicalTabIndentationPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalTabIndentationPlugin.js"(exports, module) {
    "use strict";
    var LexicalTabIndentationPlugin = true ? require_LexicalTabIndentationPlugin_dev() : null;
    module.exports = LexicalTabIndentationPlugin;
  }
});

// node_modules/@lexical/react/LexicalListPlugin.dev.js
var require_LexicalListPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalListPlugin.dev.js"(exports) {
    "use strict";
    var list = require_LexicalList();
    var LexicalComposerContext = require_LexicalComposerContext();
    var react = require_react();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function useList(editor) {
      react.useEffect(() => {
        return utils.mergeRegister(editor.registerCommand(list.INSERT_ORDERED_LIST_COMMAND, () => {
          list.insertList(editor, "number");
          return true;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_UNORDERED_LIST_COMMAND, () => {
          list.insertList(editor, "bullet");
          return true;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.REMOVE_LIST_COMMAND, () => {
          list.removeList(editor);
          return true;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
          const hasHandledInsertParagraph = list.$handleListInsertParagraph();
          if (hasHandledInsertParagraph) {
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW));
      }, [editor]);
    }
    function ListPlugin2() {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        if (!editor.hasNodes([list.ListNode, list.ListItemNode])) {
          throw new Error("ListPlugin: ListNode and/or ListItemNode not registered on editor");
        }
      }, [editor]);
      useList(editor);
      return null;
    }
    exports.ListPlugin = ListPlugin2;
  }
});

// node_modules/@lexical/react/LexicalListPlugin.js
var require_LexicalListPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalListPlugin.js"(exports, module) {
    "use strict";
    var LexicalListPlugin = true ? require_LexicalListPlugin_dev() : null;
    module.exports = LexicalListPlugin;
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/lists/MdastListVisitor.js
var import_list = __toESM(require_LexicalList(), 1);
var MdastListVisitor = {
  testNode: "list",
  visitNode: function({ mdastNode, lexicalParent, actions }) {
    const lexicalNode = (0, import_list.$createListNode)(mdastNode.ordered ? "number" : "bullet");
    if ((0, import_list.$isListItemNode)(lexicalParent)) {
      const dedicatedParent = (0, import_list.$createListItemNode)();
      dedicatedParent.append(lexicalNode);
      lexicalParent.insertAfter(dedicatedParent);
    } else {
      lexicalParent.append(lexicalNode);
    }
    actions.visitChildren(mdastNode, lexicalNode);
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/MdastListItemVisitor.js
var import_list2 = __toESM(require_LexicalList(), 1);
var MdastListItemVisitor = {
  testNode: "listItem",
  visitNode({ actions }) {
    actions.addAndStepInto((0, import_list2.$createListItemNode)());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/LexicalListVisitor.js
var import_list3 = __toESM(require_LexicalList(), 1);
var LexicalListVisitor = {
  testLexicalNode: import_list3.$isListNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("list", {
      ordered: lexicalNode.getListType() === "number",
      spread: false
    });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/LexicalListItemVisitor.js
var import_list4 = __toESM(require_LexicalList(), 1);
var LexicalListItemVisitor = {
  testLexicalNode: import_list4.$isListItemNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const children = lexicalNode.getChildren();
    const firstChild = children[0];
    if (children.length === 1 && (0, import_list4.$isListNode)(firstChild)) {
      const prevListItemNode = mdastParent.children.at(-1);
      actions.visitChildren(lexicalNode, prevListItemNode);
    } else {
      const listItem = actions.appendToParent(mdastParent, {
        type: "listItem",
        spread: false,
        children: [{ type: "paragraph", children: [] }]
      });
      actions.visitChildren(lexicalNode, listItem.children[0]);
    }
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/lists/index.js
var import_list5 = __toESM(require_LexicalList());
var import_lexical = __toESM(require_Lexical());
var import_LexicalTabIndentationPlugin = __toESM(require_LexicalTabIndentationPlugin());
var import_LexicalListPlugin = __toESM(require_LexicalListPlugin());
var import_utils = __toESM(require_LexicalUtils());
var ListTypeCommandMap = /* @__PURE__ */ new Map([
  ["number", import_list5.INSERT_ORDERED_LIST_COMMAND],
  ["bullet", import_list5.INSERT_UNORDERED_LIST_COMMAND],
  ["", import_list5.REMOVE_LIST_COMMAND]
]);
var listsSystem = system(
  (r, [{ activeEditor, currentSelection }]) => {
    const currentListType = r.node("");
    const applyListType = r.node();
    r.sub(r.pipe(applyListType, r.o.withLatestFrom(activeEditor)), ([listType, theEditor]) => {
      theEditor == null ? void 0 : theEditor.dispatchCommand(ListTypeCommandMap.get(listType), void 0);
    });
    r.sub(r.pipe(currentSelection, r.o.withLatestFrom(activeEditor)), ([selection, theEditor]) => {
      if (!selection || !theEditor) {
        return;
      }
      const anchorNode = selection.anchor.getNode();
      let element = anchorNode.getKey() === "root" ? anchorNode : (0, import_utils.$findMatchingParent)(anchorNode, (e) => {
        const parent = e.getParent();
        return parent !== null && (0, import_lexical.$isRootOrShadowRoot)(parent);
      });
      if (element === null) {
        element = anchorNode.getTopLevelElementOrThrow();
      }
      const elementKey = element.getKey();
      const elementDOM = theEditor.getElementByKey(elementKey);
      if (elementDOM !== null) {
        if ((0, import_list5.$isListNode)(element)) {
          const parentList = (0, import_utils.$getNearestNodeOfType)(anchorNode, import_list5.ListNode);
          const type = parentList ? parentList.getListType() : element.getListType();
          r.pub(currentListType, type);
        } else {
          r.pub(currentListType, null);
        }
      }
    });
    return { currentListType, applyListType };
  },
  [coreSystem]
);
var [
  /** @internal */
  listsPlugin,
  /** @internal */
  listsPluginHooks
] = realmPlugin({
  id: "lists",
  systemSpec: listsSystem,
  init: (realm) => {
    var _a;
    realm.pubKey("addImportVisitor", MdastListVisitor);
    realm.pubKey("addImportVisitor", MdastListItemVisitor);
    realm.pubKey("addLexicalNode", import_list5.ListItemNode);
    realm.pubKey("addLexicalNode", import_list5.ListNode);
    realm.pubKey("addExportVisitor", LexicalListVisitor);
    realm.pubKey("addExportVisitor", LexicalListItemVisitor);
    (_a = realm.getKeyValue("rootEditor")) == null ? void 0 : _a.registerCommand(import_lexical.INDENT_CONTENT_COMMAND, () => !isIndentPermitted(7), import_lexical.COMMAND_PRIORITY_CRITICAL);
    realm.pubKey("addComposerChild", import_LexicalTabIndentationPlugin.TabIndentationPlugin);
    realm.pubKey("addComposerChild", import_LexicalListPlugin.ListPlugin);
  }
});
function getElementNodesInSelection(selection) {
  const nodesInSelection = selection.getNodes();
  if (nodesInSelection.length === 0) {
    return /* @__PURE__ */ new Set([selection.anchor.getNode().getParentOrThrow(), selection.focus.getNode().getParentOrThrow()]);
  }
  return new Set(nodesInSelection.map((n) => (0, import_lexical.$isElementNode)(n) ? n : n.getParentOrThrow()));
}
function isIndentPermitted(maxDepth) {
  const selection = (0, import_lexical.$getSelection)();
  if (!(0, import_lexical.$isRangeSelection)(selection)) {
    return false;
  }
  const elementNodesInSelection = getElementNodesInSelection(selection);
  let totalDepth = 0;
  for (const elementNode of elementNodesInSelection) {
    if ((0, import_list5.$isListNode)(elementNode)) {
      totalDepth = Math.max((0, import_list5.$getListDepth)(elementNode) + 1, totalDepth);
    } else if ((0, import_list5.$isListItemNode)(elementNode)) {
      const parent = elementNode.getParent();
      if ((parent == null ? void 0 : parent.getChildren().length) === 1) {
        const grandParentListItem = parent == null ? void 0 : parent.getParent();
        if ((0, import_list5.$isListItemNode)(grandParentListItem) && grandParentListItem.getChildren().length === 1) {
          return false;
        }
      }
      if (!(0, import_list5.$isListNode)(parent)) {
        throw new Error("ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.");
      }
      totalDepth = Math.max((0, import_list5.$getListDepth)(parent) + 1, totalDepth);
    }
  }
  return totalDepth <= maxDepth;
}

export {
  listsSystem,
  listsPlugin,
  listsPluginHooks
};
//# sourceMappingURL=chunk-CB4ZIAFM.js.map
