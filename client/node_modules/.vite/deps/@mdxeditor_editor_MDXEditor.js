import {
  require_classnames,
  styles
} from "./chunk-UYAYURSS.js";
import {
  RealmPluginInitializer,
  corePlugin,
  corePluginHooks,
  noop,
  require_Lexical,
  require_LexicalComposerContext,
  require_LexicalRichText,
  require_LexicalUtils,
  useHasPlugin
} from "./chunk-I3I4FGWZ.js";
import "./chunk-4YQ2LHX3.js";
import {
  require_react_dom
} from "./chunk-X3B7SAOS.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/@lexical/react/LexicalComposer.dev.js
var require_LexicalComposer_dev = __commonJS({
  "node_modules/@lexical/react/LexicalComposer.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var lexical = require_Lexical();
    var React = require_react();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    var HISTORY_MERGE_OPTIONS = {
      tag: "history-merge"
    };
    function LexicalComposer2({
      initialConfig,
      children
    }) {
      const composerContext = React.useMemo(
        () => {
          const {
            theme,
            namespace,
            editor__DEPRECATED: initialEditor,
            nodes,
            onError,
            editorState: initialEditorState
          } = initialConfig;
          const context = LexicalComposerContext.createLexicalComposerContext(null, theme);
          let editor = initialEditor || null;
          if (editor === null) {
            const newEditor = lexical.createEditor({
              editable: initialConfig.editable,
              namespace,
              nodes,
              onError: (error) => onError(error, newEditor),
              theme
            });
            initializeEditor(newEditor, initialEditorState);
            editor = newEditor;
          }
          return [editor, context];
        },
        // We only do this for init
        // eslint-disable-next-line react-hooks/exhaustive-deps
        []
      );
      useLayoutEffect(() => {
        const isEditable = initialConfig.editable;
        const [editor] = composerContext;
        editor.setEditable(isEditable !== void 0 ? isEditable : true);
      }, []);
      return React.createElement(LexicalComposerContext.LexicalComposerContext.Provider, {
        value: composerContext
      }, children);
    }
    function initializeEditor(editor, initialEditorState) {
      if (initialEditorState === null) {
        return;
      } else if (initialEditorState === void 0) {
        editor.update(() => {
          const root = lexical.$getRoot();
          if (root.isEmpty()) {
            const paragraph = lexical.$createParagraphNode();
            root.append(paragraph);
            const activeElement = CAN_USE_DOM ? document.activeElement : null;
            if (lexical.$getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {
              paragraph.select();
            }
          }
        }, HISTORY_MERGE_OPTIONS);
      } else if (initialEditorState !== null) {
        switch (typeof initialEditorState) {
          case "string": {
            const parsedEditorState = editor.parseEditorState(initialEditorState);
            editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);
            break;
          }
          case "object": {
            editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);
            break;
          }
          case "function": {
            editor.update(() => {
              const root = lexical.$getRoot();
              if (root.isEmpty()) {
                initialEditorState(editor);
              }
            }, HISTORY_MERGE_OPTIONS);
            break;
          }
        }
      }
    }
    exports.LexicalComposer = LexicalComposer2;
  }
});

// node_modules/@lexical/react/LexicalComposer.js
var require_LexicalComposer = __commonJS({
  "node_modules/@lexical/react/LexicalComposer.js"(exports, module) {
    "use strict";
    var LexicalComposer2 = true ? require_LexicalComposer_dev() : null;
    module.exports = LexicalComposer2;
  }
});

// node_modules/@lexical/react/useLexicalEditable.dev.js
var require_useLexicalEditable_dev = __commonJS({
  "node_modules/@lexical/react/useLexicalEditable.dev.js"(exports, module) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var react = require_react();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? react.useLayoutEffect : react.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function useLexicalSubscription(subscription2) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const initializedSubscription = react.useMemo(() => subscription2(editor), [editor, subscription2]);
      const valueRef = react.useRef(initializedSubscription.initialValueFn());
      const [value, setValue] = react.useState(valueRef.current);
      useLayoutEffect(() => {
        const {
          initialValueFn,
          subscribe
        } = initializedSubscription;
        const currentValue = initialValueFn();
        if (valueRef.current !== currentValue) {
          valueRef.current = currentValue;
          setValue(currentValue);
        }
        return subscribe((newValue) => {
          valueRef.current = newValue;
          setValue(newValue);
        });
      }, [initializedSubscription, subscription2]);
      return value;
    }
    function subscription(editor) {
      return {
        initialValueFn: () => editor.isEditable(),
        subscribe: (callback) => {
          return editor.registerEditableListener(callback);
        }
      };
    }
    function useLexicalEditable() {
      return useLexicalSubscription(subscription);
    }
    module.exports = useLexicalEditable;
  }
});

// node_modules/@lexical/react/useLexicalEditable.js
var require_useLexicalEditable = __commonJS({
  "node_modules/@lexical/react/useLexicalEditable.js"(exports, module) {
    "use strict";
    var useLexicalEditable = true ? require_useLexicalEditable_dev() : null;
    module.exports = useLexicalEditable;
  }
});

// node_modules/@lexical/text/LexicalText.dev.js
var require_LexicalText_dev = __commonJS({
  "node_modules/@lexical/text/LexicalText.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    function $findTextIntersectionFromCharacters(root, targetCharacters) {
      let node = root.getFirstChild();
      let currentCharacters = 0;
      mainLoop:
        while (node !== null) {
          if (lexical.$isElementNode(node)) {
            const child = node.getFirstChild();
            if (child !== null) {
              node = child;
              continue;
            }
          } else if (lexical.$isTextNode(node)) {
            const characters = node.getTextContentSize();
            if (currentCharacters + characters > targetCharacters) {
              return {
                node,
                offset: targetCharacters - currentCharacters
              };
            }
            currentCharacters += characters;
          }
          const sibling = node.getNextSibling();
          if (sibling !== null) {
            node = sibling;
            continue;
          }
          let parent = node.getParent();
          while (parent !== null) {
            const parentSibling = parent.getNextSibling();
            if (parentSibling !== null) {
              node = parentSibling;
              continue mainLoop;
            }
            parent = parent.getParent();
          }
          break;
        }
      return null;
    }
    function $isRootTextContentEmpty(isEditorComposing, trim = true) {
      if (isEditorComposing) {
        return false;
      }
      let text = $rootTextContent();
      if (trim) {
        text = text.trim();
      }
      return text === "";
    }
    function $isRootTextContentEmptyCurry(isEditorComposing, trim) {
      return () => $isRootTextContentEmpty(isEditorComposing, trim);
    }
    function $rootTextContent() {
      const root = lexical.$getRoot();
      return root.getTextContent();
    }
    function $canShowPlaceholder(isComposing) {
      if (!$isRootTextContentEmpty(isComposing, false)) {
        return false;
      }
      const root = lexical.$getRoot();
      const children = root.getChildren();
      const childrenLength = children.length;
      if (childrenLength > 1) {
        return false;
      }
      for (let i = 0; i < childrenLength; i++) {
        const topBlock = children[i];
        if (lexical.$isDecoratorNode(topBlock)) {
          return false;
        }
        if (lexical.$isElementNode(topBlock)) {
          if (!lexical.$isParagraphNode(topBlock)) {
            return false;
          }
          if (topBlock.__indent !== 0) {
            return false;
          }
          const topBlockChildren = topBlock.getChildren();
          const topBlockChildrenLength = topBlockChildren.length;
          for (let s = 0; s < topBlockChildrenLength; s++) {
            const child = topBlockChildren[i];
            if (!lexical.$isTextNode(child)) {
              return false;
            }
          }
        }
      }
      return true;
    }
    function $canShowPlaceholderCurry(isEditorComposing) {
      return () => $canShowPlaceholder(isEditorComposing);
    }
    function registerLexicalTextEntity(editor, getMatch, targetNode, createNode) {
      const isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const replaceWithSimpleText = (node) => {
        const textNode = lexical.$createTextNode(node.getTextContent());
        textNode.setFormat(node.getFormat());
        node.replace(textNode);
      };
      const getMode = (node) => {
        return node.getLatest().__mode;
      };
      const textNodeTransform = (node) => {
        if (!node.isSimpleText()) {
          return;
        }
        const prevSibling = node.getPreviousSibling();
        let text = node.getTextContent();
        let currentNode = node;
        let match;
        if (lexical.$isTextNode(prevSibling)) {
          const previousText = prevSibling.getTextContent();
          const combinedText = previousText + text;
          const prevMatch = getMatch(combinedText);
          if (isTargetNode(prevSibling)) {
            if (prevMatch === null || getMode(prevSibling) !== 0) {
              replaceWithSimpleText(prevSibling);
              return;
            } else {
              const diff = prevMatch.end - previousText.length;
              if (diff > 0) {
                const concatText = text.slice(0, diff);
                const newTextContent = previousText + concatText;
                prevSibling.select();
                prevSibling.setTextContent(newTextContent);
                if (diff === text.length) {
                  node.remove();
                } else {
                  const remainingText = text.slice(diff);
                  node.setTextContent(remainingText);
                }
                return;
              }
            }
          } else if (prevMatch === null || prevMatch.start < previousText.length) {
            return;
          }
        }
        while (true) {
          match = getMatch(text);
          let nextText = match === null ? "" : text.slice(match.end);
          text = nextText;
          if (nextText === "") {
            const nextSibling = currentNode.getNextSibling();
            if (lexical.$isTextNode(nextSibling)) {
              nextText = currentNode.getTextContent() + nextSibling.getTextContent();
              const nextMatch = getMatch(nextText);
              if (nextMatch === null) {
                if (isTargetNode(nextSibling)) {
                  replaceWithSimpleText(nextSibling);
                } else {
                  nextSibling.markDirty();
                }
                return;
              } else if (nextMatch.start !== 0) {
                return;
              }
            }
          } else {
            const nextMatch = getMatch(nextText);
            if (nextMatch !== null && nextMatch.start === 0) {
              return;
            }
          }
          if (match === null) {
            return;
          }
          if (match.start === 0 && lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {
            continue;
          }
          let nodeToReplace;
          if (match.start === 0) {
            [nodeToReplace, currentNode] = currentNode.splitText(match.end);
          } else {
            [, nodeToReplace, currentNode] = currentNode.splitText(match.start, match.end);
          }
          const replacementNode = createNode(nodeToReplace);
          replacementNode.setFormat(nodeToReplace.getFormat());
          nodeToReplace.replace(replacementNode);
          if (currentNode == null) {
            return;
          }
        }
      };
      const reverseNodeTransform = (node) => {
        const text = node.getTextContent();
        const match = getMatch(text);
        if (match === null || match.start !== 0) {
          replaceWithSimpleText(node);
          return;
        }
        if (text.length > match.end) {
          node.splitText(match.end);
          return;
        }
        const prevSibling = node.getPreviousSibling();
        if (lexical.$isTextNode(prevSibling) && prevSibling.isTextEntity()) {
          replaceWithSimpleText(prevSibling);
          replaceWithSimpleText(node);
        }
        const nextSibling = node.getNextSibling();
        if (lexical.$isTextNode(nextSibling) && nextSibling.isTextEntity()) {
          replaceWithSimpleText(nextSibling);
          if (isTargetNode(node)) {
            replaceWithSimpleText(node);
          }
        }
      };
      const removePlainTextTransform = editor.registerNodeTransform(lexical.TextNode, textNodeTransform);
      const removeReverseNodeTransform = editor.registerNodeTransform(targetNode, reverseNodeTransform);
      return [removePlainTextTransform, removeReverseNodeTransform];
    }
    exports.$canShowPlaceholder = $canShowPlaceholder;
    exports.$canShowPlaceholderCurry = $canShowPlaceholderCurry;
    exports.$findTextIntersectionFromCharacters = $findTextIntersectionFromCharacters;
    exports.$isRootTextContentEmpty = $isRootTextContentEmpty;
    exports.$isRootTextContentEmptyCurry = $isRootTextContentEmptyCurry;
    exports.$rootTextContent = $rootTextContent;
    exports.registerLexicalTextEntity = registerLexicalTextEntity;
  }
});

// node_modules/@lexical/text/LexicalText.js
var require_LexicalText = __commonJS({
  "node_modules/@lexical/text/LexicalText.js"(exports, module) {
    "use strict";
    var LexicalText = true ? require_LexicalText_dev() : null;
    module.exports = LexicalText;
  }
});

// node_modules/@lexical/dragon/LexicalDragon.dev.js
var require_LexicalDragon_dev = __commonJS({
  "node_modules/@lexical/dragon/LexicalDragon.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    function registerDragonSupport(editor) {
      const origin = window.location.origin;
      const handler = (event) => {
        if (event.origin !== origin) {
          return;
        }
        const rootElement = editor.getRootElement();
        if (document.activeElement !== rootElement) {
          return;
        }
        const data = event.data;
        if (typeof data === "string") {
          let parsedData;
          try {
            parsedData = JSON.parse(data);
          } catch (e) {
            return;
          }
          if (parsedData && parsedData.protocol === "nuanria_messaging" && parsedData.type === "request") {
            const payload = parsedData.payload;
            if (payload && payload.functionId === "makeChanges") {
              const args = payload.args;
              if (args) {
                const [elementStart, elementLength, text, selStart, selLength, formatCommand] = args;
                editor.update(() => {
                  const selection = lexical.$getSelection();
                  if (lexical.$isRangeSelection(selection)) {
                    const anchor = selection.anchor;
                    let anchorNode = anchor.getNode();
                    let setSelStart = 0;
                    let setSelEnd = 0;
                    if (lexical.$isTextNode(anchorNode)) {
                      if (elementStart >= 0 && elementLength >= 0) {
                        setSelStart = elementStart;
                        setSelEnd = elementStart + elementLength;
                        selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                      }
                    }
                    if (setSelStart !== setSelEnd || text !== "") {
                      selection.insertRawText(text);
                      anchorNode = anchor.getNode();
                    }
                    if (lexical.$isTextNode(anchorNode)) {
                      setSelStart = selStart;
                      setSelEnd = selStart + selLength;
                      const anchorNodeTextLength = anchorNode.getTextContentSize();
                      setSelStart = setSelStart > anchorNodeTextLength ? anchorNodeTextLength : setSelStart;
                      setSelEnd = setSelEnd > anchorNodeTextLength ? anchorNodeTextLength : setSelEnd;
                      selection.setTextNodeRange(anchorNode, setSelStart, anchorNode, setSelEnd);
                    }
                    event.stopImmediatePropagation();
                  }
                });
              }
            }
          }
        }
      };
      window.addEventListener("message", handler, true);
      return () => {
        window.removeEventListener("message", handler, true);
      };
    }
    exports.registerDragonSupport = registerDragonSupport;
  }
});

// node_modules/@lexical/dragon/LexicalDragon.js
var require_LexicalDragon = __commonJS({
  "node_modules/@lexical/dragon/LexicalDragon.js"(exports, module) {
    "use strict";
    var LexicalDragon = true ? require_LexicalDragon_dev() : null;
    module.exports = LexicalDragon;
  }
});

// node_modules/@lexical/react/LexicalRichTextPlugin.dev.js
var require_LexicalRichTextPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalRichTextPlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var useLexicalEditable = require_useLexicalEditable();
    var React = require_react();
    var text = require_LexicalText();
    var utils = require_LexicalUtils();
    var reactDom = require_react_dom();
    var dragon = require_LexicalDragon();
    var richText = require_LexicalRichText();
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function canShowPlaceholderFromCurrentEditorState(editor) {
      const currentCanShowPlaceholder = editor.getEditorState().read(text.$canShowPlaceholderCurry(editor.isComposing()));
      return currentCanShowPlaceholder;
    }
    function useCanShowPlaceholder(editor) {
      const [canShowPlaceholder, setCanShowPlaceholder] = React.useState(() => canShowPlaceholderFromCurrentEditorState(editor));
      useLayoutEffect(() => {
        function resetCanShowPlaceholder() {
          const currentCanShowPlaceholder = canShowPlaceholderFromCurrentEditorState(editor);
          setCanShowPlaceholder(currentCanShowPlaceholder);
        }
        resetCanShowPlaceholder();
        return utils.mergeRegister(editor.registerUpdateListener(() => {
          resetCanShowPlaceholder();
        }), editor.registerEditableListener(() => {
          resetCanShowPlaceholder();
        }));
      }, [editor]);
      return canShowPlaceholder;
    }
    function useDecorators(editor, ErrorBoundary) {
      const [decorators, setDecorators] = React.useState(() => editor.getDecorators());
      useLayoutEffect(() => {
        return editor.registerDecoratorListener((nextDecorators) => {
          reactDom.flushSync(() => {
            setDecorators(nextDecorators);
          });
        });
      }, [editor]);
      React.useEffect(() => {
        setDecorators(editor.getDecorators());
      }, [editor]);
      return React.useMemo(() => {
        const decoratedPortals = [];
        const decoratorKeys = Object.keys(decorators);
        for (let i = 0; i < decoratorKeys.length; i++) {
          const nodeKey = decoratorKeys[i];
          const reactDecorator = React.createElement(ErrorBoundary, {
            onError: (e) => editor._onError(e)
          }, React.createElement(React.Suspense, {
            fallback: null
          }, decorators[nodeKey]));
          const element = editor.getElementByKey(nodeKey);
          if (element !== null) {
            decoratedPortals.push(reactDom.createPortal(reactDecorator, element, nodeKey));
          }
        }
        return decoratedPortals;
      }, [ErrorBoundary, decorators, editor]);
    }
    function useRichTextSetup(editor) {
      useLayoutEffect(() => {
        return utils.mergeRegister(richText.registerRichText(editor), dragon.registerDragonSupport(editor));
      }, [editor]);
    }
    function RichTextPlugin2({
      contentEditable,
      placeholder,
      ErrorBoundary
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const decorators = useDecorators(editor, ErrorBoundary);
      useRichTextSetup(editor);
      return React.createElement(React.Fragment, null, contentEditable, React.createElement(Placeholder, {
        content: placeholder
      }), decorators);
    }
    function Placeholder({
      content
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const showPlaceholder = useCanShowPlaceholder(editor);
      const editable = useLexicalEditable();
      if (!showPlaceholder) {
        return null;
      }
      if (typeof content === "function") {
        return content(editable);
      } else {
        return content;
      }
    }
    exports.RichTextPlugin = RichTextPlugin2;
  }
});

// node_modules/@lexical/react/LexicalRichTextPlugin.js
var require_LexicalRichTextPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalRichTextPlugin.js"(exports, module) {
    "use strict";
    var LexicalRichTextPlugin = true ? require_LexicalRichTextPlugin_dev() : null;
    module.exports = LexicalRichTextPlugin;
  }
});

// node_modules/@lexical/react/LexicalContentEditable.dev.js
var require_LexicalContentEditable_dev = __commonJS({
  "node_modules/@lexical/react/LexicalContentEditable.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var React = require_react();
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var useLayoutEffectImpl = CAN_USE_DOM ? React.useLayoutEffect : React.useEffect;
    var useLayoutEffect = useLayoutEffectImpl;
    function ContentEditable2({
      ariaActiveDescendant,
      ariaAutoComplete,
      ariaControls,
      ariaDescribedBy,
      ariaExpanded,
      ariaLabel,
      ariaLabelledBy,
      ariaMultiline,
      ariaOwns,
      ariaRequired,
      autoCapitalize,
      className,
      id,
      role = "textbox",
      spellCheck = true,
      style,
      tabIndex,
      "data-testid": testid,
      ...rest
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isEditable, setEditable] = React.useState(false);
      const ref = React.useCallback((rootElement) => {
        editor.setRootElement(rootElement);
      }, [editor]);
      useLayoutEffect(() => {
        setEditable(editor.isEditable());
        return editor.registerEditableListener((currentIsEditable) => {
          setEditable(currentIsEditable);
        });
      }, [editor]);
      return React.createElement("div", _extends({}, rest, {
        "aria-activedescendant": !isEditable ? void 0 : ariaActiveDescendant,
        "aria-autocomplete": !isEditable ? "none" : ariaAutoComplete,
        "aria-controls": !isEditable ? void 0 : ariaControls,
        "aria-describedby": ariaDescribedBy,
        "aria-expanded": !isEditable ? void 0 : role === "combobox" ? !!ariaExpanded : void 0,
        "aria-label": ariaLabel,
        "aria-labelledby": ariaLabelledBy,
        "aria-multiline": ariaMultiline,
        "aria-owns": !isEditable ? void 0 : ariaOwns,
        "aria-readonly": !isEditable ? true : void 0,
        "aria-required": ariaRequired,
        autoCapitalize,
        className,
        contentEditable: isEditable,
        "data-testid": testid,
        id,
        ref,
        role,
        spellCheck,
        style,
        tabIndex
      }));
    }
    exports.ContentEditable = ContentEditable2;
  }
});

// node_modules/@lexical/react/LexicalContentEditable.js
var require_LexicalContentEditable = __commonJS({
  "node_modules/@lexical/react/LexicalContentEditable.js"(exports, module) {
    "use strict";
    var LexicalContentEditable = true ? require_LexicalContentEditable_dev() : null;
    module.exports = LexicalContentEditable;
  }
});

// node_modules/@lexical/react/LexicalErrorBoundary.dev.js
var require_LexicalErrorBoundary_dev = __commonJS({
  "node_modules/@lexical/react/LexicalErrorBoundary.dev.js"(exports, module) {
    "use strict";
    var React = require_react();
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      _setPrototypeOf(subClass, superClass);
    }
    var changedArray = function changedArray2(a, b) {
      if (a === void 0) {
        a = [];
      }
      if (b === void 0) {
        b = [];
      }
      return a.length !== b.length || a.some(function(item, index) {
        return !Object.is(item, b[index]);
      });
    };
    var initialState = {
      error: null
    };
    var ErrorBoundary = function(_React$Component) {
      _inheritsLoose(ErrorBoundary2, _React$Component);
      function ErrorBoundary2() {
        var _this;
        for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {
          _args[_key] = arguments[_key];
        }
        _this = _React$Component.call.apply(_React$Component, [this].concat(_args)) || this;
        _this.state = initialState;
        _this.resetErrorBoundary = function() {
          var _this$props;
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          _this.props.onReset == null ? void 0 : (_this$props = _this.props).onReset.apply(_this$props, args);
          _this.reset();
        };
        return _this;
      }
      ErrorBoundary2.getDerivedStateFromError = function getDerivedStateFromError(error) {
        return {
          error
        };
      };
      var _proto = ErrorBoundary2.prototype;
      _proto.reset = function reset() {
        this.setState(initialState);
      };
      _proto.componentDidCatch = function componentDidCatch(error, info) {
        var _this$props$onError, _this$props2;
        (_this$props$onError = (_this$props2 = this.props).onError) == null ? void 0 : _this$props$onError.call(_this$props2, error, info);
      };
      _proto.componentDidUpdate = function componentDidUpdate(prevProps, prevState) {
        var error = this.state.error;
        var resetKeys = this.props.resetKeys;
        if (error !== null && prevState.error !== null && changedArray(prevProps.resetKeys, resetKeys)) {
          var _this$props$onResetKe, _this$props3;
          (_this$props$onResetKe = (_this$props3 = this.props).onResetKeysChange) == null ? void 0 : _this$props$onResetKe.call(_this$props3, prevProps.resetKeys, resetKeys);
          this.reset();
        }
      };
      _proto.render = function render() {
        var error = this.state.error;
        var _this$props4 = this.props, fallbackRender = _this$props4.fallbackRender, FallbackComponent = _this$props4.FallbackComponent, fallback = _this$props4.fallback;
        if (error !== null) {
          var _props = {
            error,
            resetErrorBoundary: this.resetErrorBoundary
          };
          if (React.isValidElement(fallback)) {
            return fallback;
          } else if (typeof fallbackRender === "function") {
            return fallbackRender(_props);
          } else if (FallbackComponent) {
            return React.createElement(FallbackComponent, _props);
          } else {
            throw new Error("react-error-boundary requires either a fallback, fallbackRender, or FallbackComponent prop");
          }
        }
        return this.props.children;
      };
      return ErrorBoundary2;
    }(React.Component);
    function LexicalErrorBoundary2({
      children,
      onError
    }) {
      return React.createElement(ErrorBoundary, {
        fallback: React.createElement("div", {
          style: {
            border: "1px solid #f00",
            color: "#f00",
            padding: "8px"
          }
        }, "An error was thrown."),
        onError
      }, children);
    }
    module.exports = LexicalErrorBoundary2;
  }
});

// node_modules/@lexical/react/LexicalErrorBoundary.js
var require_LexicalErrorBoundary = __commonJS({
  "node_modules/@lexical/react/LexicalErrorBoundary.js"(exports, module) {
    "use strict";
    var LexicalErrorBoundary2 = true ? require_LexicalErrorBoundary_dev() : null;
    module.exports = LexicalErrorBoundary2;
  }
});

// node_modules/@mdxeditor/editor/dist/MDXEditor.js
var import_react = __toESM(require_react());

// node_modules/@mdxeditor/editor/dist/styles/lexical-theme.module.css.js
var lightTheme = "_light-theme_13nbk_1";
var darkTheme = "_dark-theme_13nbk_1";
var bold = "_bold_13nbk_10";
var italic = "_italic_13nbk_14";
var underline = "_underline_13nbk_18";
var strikethrough = "_strikethrough_13nbk_34";
var underlineStrikethrough = "_underlineStrikethrough_13nbk_38";
var subscript = "_subscript_13nbk_42";
var superscript = "_superscript_13nbk_47";
var code = "_code_13nbk_52";
var nestedListItem = "_nestedListItem_13nbk_59";
var admonitionDanger = "_admonitionDanger_13nbk_63";
var admonitionInfo = "_admonitionInfo_13nbk_63";
var admonitionNote = "_admonitionNote_13nbk_63";
var admonitionTip = "_admonitionTip_13nbk_63";
var admonitionCaution = "_admonitionCaution_13nbk_63";
var styles2 = {
  lightTheme,
  darkTheme,
  bold,
  italic,
  underline,
  strikethrough,
  underlineStrikethrough,
  subscript,
  superscript,
  code,
  nestedListItem,
  admonitionDanger,
  admonitionInfo,
  admonitionNote,
  admonitionTip,
  admonitionCaution
};

// node_modules/@mdxeditor/editor/dist/styles/lexicalTheme.js
var lexicalTheme = {
  text: {
    bold: styles2.bold,
    italic: styles2.italic,
    underline: styles2.underline,
    code: styles2.code,
    strikethrough: styles2.strikethrough,
    subscript: styles2.subscript,
    superscript: styles2.superscript,
    underlineStrikethrough: styles2.underlineStrikethrough
  },
  list: {
    nested: {
      listitem: styles2.nestedListItem
    }
  },
  admonition: {
    danger: styles2.admonitionDanger,
    info: styles2.admonitionInfo,
    note: styles2.admonitionNote,
    tip: styles2.admonitionTip,
    caution: styles2.admonitionCaution
  }
};

// node_modules/@mdxeditor/editor/dist/MDXEditor.js
var import_LexicalComposer = __toESM(require_LexicalComposer());
var import_LexicalRichTextPlugin = __toESM(require_LexicalRichTextPlugin());
var import_LexicalContentEditable = __toESM(require_LexicalContentEditable());
var import_LexicalErrorBoundary = __toESM(require_LexicalErrorBoundary());
var import_classnames = __toESM(require_classnames());
var LexicalProvider = ({ children }) => {
  const [initialRootEditorState, nodes, readOnly] = corePluginHooks.useEmitterValues(
    "initialRootEditorState",
    "usedLexicalNodes",
    "readOnly"
  );
  return import_react.default.createElement(
    import_LexicalComposer.LexicalComposer,
    {
      initialConfig: {
        editable: !readOnly,
        editorState: initialRootEditorState,
        namespace: "MDXEditor",
        theme: lexicalTheme,
        nodes,
        onError: (error) => {
          throw error;
        }
      }
    },
    children
  );
};
var RichTextEditor = () => {
  const [contentEditableClassName, composerChildren, topAreaChildren, editorWrappers, placeholder] = corePluginHooks.useEmitterValues(
    "contentEditableClassName",
    "composerChildren",
    "topAreaChildren",
    "editorWrappers",
    "placeholder"
  );
  return import_react.default.createElement(import_react.default.Fragment, null, topAreaChildren.map((Child, index) => import_react.default.createElement(Child, { key: index })), import_react.default.createElement(RenderRecurisveWrappers, { wrappers: editorWrappers }, import_react.default.createElement("div", { className: (0, import_classnames.default)(styles.rootContentEditableWrapper) }, import_react.default.createElement(
    import_LexicalRichTextPlugin.RichTextPlugin,
    {
      contentEditable: import_react.default.createElement(import_LexicalContentEditable.ContentEditable, { className: (0, import_classnames.default)(styles.contentEditable, contentEditableClassName) }),
      placeholder: import_react.default.createElement("div", { className: (0, import_classnames.default)(styles.contentEditable, styles.placeholder, contentEditableClassName) }, import_react.default.createElement("p", null, placeholder)),
      ErrorBoundary: import_LexicalErrorBoundary.default
    }
  ))), composerChildren.map((Child, index) => import_react.default.createElement(Child, { key: index })));
};
var DEFAULT_MARKDOWN_OPTIONS = {
  listItemIndent: "one"
};
var RenderRecurisveWrappers = ({
  wrappers,
  children
}) => {
  if (wrappers.length === 0) {
    return import_react.default.createElement(import_react.default.Fragment, null, children);
  }
  const Wrapper = wrappers[0];
  return import_react.default.createElement(Wrapper, null, import_react.default.createElement(RenderRecurisveWrappers, { wrappers: wrappers.slice(1) }, children));
};
var EditorRootElement = ({ children, className }) => {
  const editorRootElementRef = import_react.default.useRef(null);
  const setEditorRootElementRef = corePluginHooks.usePublisher("editorRootElementRef");
  import_react.default.useEffect(() => {
    const popupContainer = document.createElement("div");
    popupContainer.classList.add(styles.editorRoot);
    if (className) {
      className.split(" ").forEach((c) => {
        popupContainer.classList.add(c);
      });
    }
    document.body.appendChild(popupContainer);
    editorRootElementRef.current = popupContainer;
    setEditorRootElementRef(editorRootElementRef);
    return () => {
      popupContainer.remove();
    };
  }, [className, editorRootElementRef, setEditorRootElementRef]);
  return import_react.default.createElement("div", { className: (0, import_classnames.default)(styles.editorRoot, styles.editorWrapper, className, "mdxeditor") }, children);
};
var Methods = ({ mdxRef }) => {
  const realm = corePluginHooks.useRealmContext();
  const hasDiffSourcePlugin = useHasPlugin("diff-source");
  import_react.default.useImperativeHandle(
    mdxRef,
    () => {
      return {
        getMarkdown: () => {
          if (hasDiffSourcePlugin) {
            if (realm.getKeyValue("viewMode") === "source") {
              return realm.getKeyValue("markdownSourceEditorValue");
            }
          }
          return realm.getKeyValue("markdown");
        },
        setMarkdown: (markdown) => {
          realm.pubKey("setMarkdown", markdown);
        },
        focus: (callbackFn, opts) => {
          var _a;
          (_a = realm.getKeyValue("rootEditor")) == null ? void 0 : _a.focus(callbackFn, opts);
        }
      };
    },
    [realm, hasDiffSourcePlugin]
  );
  return null;
};
var MDXEditor = import_react.default.forwardRef((props, ref) => {
  return import_react.default.createElement(
    RealmPluginInitializer,
    {
      plugins: [
        corePlugin({
          contentEditableClassName: props.contentEditableClassName ?? "",
          initialMarkdown: props.markdown,
          onChange: props.onChange ?? noop,
          onBlur: props.onBlur ?? noop,
          toMarkdownOptions: props.toMarkdownOptions ?? DEFAULT_MARKDOWN_OPTIONS,
          autoFocus: props.autoFocus ?? false,
          placeholder: props.placeholder ?? "",
          readOnly: Boolean(props.readOnly)
        }),
        ...props.plugins || []
      ]
    },
    import_react.default.createElement(EditorRootElement, { className: props.className }, import_react.default.createElement(LexicalProvider, null, import_react.default.createElement(RichTextEditor, null))),
    import_react.default.createElement(Methods, { mdxRef: ref })
  );
});
export {
  MDXEditor
};
//# sourceMappingURL=@mdxeditor_editor_MDXEditor.js.map
