{
  "version": 3,
  "sources": ["../../@lexical/react/useLexicalNodeSelection.dev.js", "../../@lexical/react/useLexicalNodeSelection.js", "../../@lexical/react/LexicalHorizontalRuleNode.dev.js", "../../@lexical/react/LexicalHorizontalRuleNode.js", "../../@lexical/react/LexicalHorizontalRulePlugin.dev.js", "../../@lexical/react/LexicalHorizontalRulePlugin.js", "../../@mdxeditor/editor/dist/plugins/thematic-break/MdastThematicBreakVisitor.js", "../../@mdxeditor/editor/dist/plugins/thematic-break/LexicalThematicBreakVisitor.js", "../../@mdxeditor/editor/dist/plugins/thematic-break/index.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction isNodeSelected(editor, key) {\n  return editor.getEditorState().read(() => {\n    const node = lexical.$getNodeByKey(key);\n\n    if (node === null) {\n      return false;\n    }\n\n    return node.isSelected();\n  });\n}\n\nfunction useLexicalNodeSelection(key) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));\n  react.useEffect(() => {\n    let isMounted = true;\n    const unregister = editor.registerUpdateListener(() => {\n      if (isMounted) {\n        setIsSelected(isNodeSelected(editor, key));\n      }\n    });\n    return () => {\n      isMounted = false;\n      unregister();\n    };\n  }, [editor, key]);\n  const setSelected = react.useCallback(selected => {\n    editor.update(() => {\n      let selection = lexical.$getSelection();\n\n      if (!lexical.$isNodeSelection(selection)) {\n        selection = lexical.$createNodeSelection();\n        lexical.$setSelection(selection);\n      }\n\n      if (selected) {\n        selection.add(key);\n      } else {\n        selection.delete(key);\n      }\n    });\n  }, [editor, key]);\n  const clearSelected = react.useCallback(() => {\n    editor.update(() => {\n      const selection = lexical.$getSelection();\n\n      if (lexical.$isNodeSelection(selection)) {\n        selection.clear();\n      }\n    });\n  }, [editor]);\n  return [isSelected, setSelected, clearSelected];\n}\n\nexports.useLexicalNodeSelection = useLexicalNodeSelection;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst useLexicalNodeSelection = process.env.NODE_ENV === 'development' ? require('./useLexicalNodeSelection.dev.js') : require('./useLexicalNodeSelection.prod.js')\nmodule.exports = useLexicalNodeSelection;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar useLexicalNodeSelection = require('@lexical/react/useLexicalNodeSelection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar React = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst INSERT_HORIZONTAL_RULE_COMMAND = lexical.createCommand('INSERT_HORIZONTAL_RULE_COMMAND');\n\nfunction HorizontalRuleComponent({\n  nodeKey\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);\n  const onDelete = React.useCallback(event => {\n    if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {\n      event.preventDefault();\n      const node = lexical.$getNodeByKey(nodeKey);\n\n      if ($isHorizontalRuleNode(node)) {\n        node.remove();\n      }\n    }\n\n    return false;\n  }, [isSelected, nodeKey]);\n  React.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, event => {\n      const hrElem = editor.getElementByKey(nodeKey);\n\n      if (event.target === hrElem) {\n        if (!event.shiftKey) {\n          clearSelection();\n        }\n\n        setSelected(!isSelected);\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));\n  }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);\n  React.useEffect(() => {\n    const hrElem = editor.getElementByKey(nodeKey);\n\n    if (hrElem !== null) {\n      hrElem.className = isSelected ? 'selected' : '';\n    }\n  }, [editor, isSelected, nodeKey]);\n  return null;\n}\n\nclass HorizontalRuleNode extends lexical.DecoratorNode {\n  static getType() {\n    return 'horizontalrule';\n  }\n\n  static clone(node) {\n    return new HorizontalRuleNode(node.__key);\n  }\n\n  static importJSON(serializedNode) {\n    return $createHorizontalRuleNode();\n  }\n\n  static importDOM() {\n    return {\n      hr: () => ({\n        conversion: convertHorizontalRuleElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportJSON() {\n    return {\n      type: 'horizontalrule',\n      version: 1\n    };\n  }\n\n  exportDOM() {\n    return {\n      element: document.createElement('hr')\n    };\n  }\n\n  createDOM() {\n    return document.createElement('hr');\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  isInline() {\n    return false;\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  decorate() {\n    return /*#__PURE__*/React.createElement(HorizontalRuleComponent, {\n      nodeKey: this.__key\n    });\n  }\n\n}\n\nfunction convertHorizontalRuleElement() {\n  return {\n    node: $createHorizontalRuleNode()\n  };\n}\n\nfunction $createHorizontalRuleNode() {\n  return lexical.$applyNodeReplacement(new HorizontalRuleNode());\n}\nfunction $isHorizontalRuleNode(node) {\n  return node instanceof HorizontalRuleNode;\n}\n\nexports.$createHorizontalRuleNode = $createHorizontalRuleNode;\nexports.$isHorizontalRuleNode = $isHorizontalRuleNode;\nexports.HorizontalRuleNode = HorizontalRuleNode;\nexports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHorizontalRuleNode = process.env.NODE_ENV === 'development' ? require('./LexicalHorizontalRuleNode.dev.js') : require('./LexicalHorizontalRuleNode.prod.js')\nmodule.exports = LexicalHorizontalRuleNode;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar LexicalHorizontalRuleNode = require('@lexical/react/LexicalHorizontalRuleNode');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction HorizontalRulePlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return editor.registerCommand(LexicalHorizontalRuleNode.INSERT_HORIZONTAL_RULE_COMMAND, type => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection)) {\n        return false;\n      }\n\n      const focusNode = selection.focus.getNode();\n\n      if (focusNode !== null) {\n        const horizontalRuleNode = LexicalHorizontalRuleNode.$createHorizontalRuleNode();\n        utils.$insertNodeToNearestRoot(horizontalRuleNode);\n      }\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_EDITOR);\n  }, [editor]);\n  return null;\n}\n\nexports.HorizontalRulePlugin = HorizontalRulePlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHorizontalRulePlugin = process.env.NODE_ENV === 'development' ? require('./LexicalHorizontalRulePlugin.dev.js') : require('./LexicalHorizontalRulePlugin.prod.js')\nmodule.exports = LexicalHorizontalRulePlugin;", "import { $createHorizontalRuleNode } from \"@lexical/react/LexicalHorizontalRuleNode.js\";\nconst MdastThematicBreakVisitor = {\n  testNode: \"thematicBreak\",\n  visitNode({ actions }) {\n    actions.addAndStepInto($createHorizontalRuleNode());\n  }\n};\nexport {\n  MdastThematicBreakVisitor\n};\n", "import { $isHorizontalRuleNode } from \"@lexical/react/LexicalHorizontalRuleNode.js\";\nconst LexicalThematicBreakVisitor = {\n  testLexicalNode: $isHorizontalRuleNode,\n  visitLexicalNode({ actions }) {\n    actions.addAndStepInto(\"thematicBreak\");\n  }\n};\nexport {\n  LexicalThematicBreakVisitor\n};\n", "import { coreSystem } from \"../core/index.js\";\nimport { MdastThematicBreakVisitor } from \"./MdastThematicBreakVisitor.js\";\nimport { LexicalThematicBreakVisitor } from \"./LexicalThematicBreakVisitor.js\";\nimport { INSERT_HORIZONTAL_RULE_COMMAND, HorizontalRuleNode } from \"@lexical/react/LexicalHorizontalRuleNode.js\";\nimport { HorizontalRulePlugin } from \"@lexical/react/LexicalHorizontalRulePlugin.js\";\nimport { system } from \"../../gurx/realmFactory.js\";\nimport { realmPlugin } from \"../../gurx/react.js\";\nconst thematicBreakSystem = system(\n  (r, [{ activeEditor }]) => {\n    const insertThematicBreak = r.node();\n    r.sub(r.pipe(insertThematicBreak, r.o.withLatestFrom(activeEditor)), ([, theEditor]) => {\n      theEditor == null ? void 0 : theEditor.dispatchCommand(INSERT_HORIZONTAL_RULE_COMMAND, void 0);\n    });\n    return {\n      insertThematicBreak\n    };\n  },\n  [coreSystem]\n);\nconst [\n  /** @internal */\n  thematicBreakPlugin,\n  /** @internal */\n  thematicBreakPluginHooks\n] = realmPlugin({\n  id: \"thematic-break\",\n  systemSpec: thematicBreakSystem,\n  init: (realm) => {\n    realm.pubKey(\"addImportVisitor\", MdastThematicBreakVisitor);\n    realm.pubKey(\"addLexicalNode\", HorizontalRuleNode);\n    realm.pubKey(\"addExportVisitor\", LexicalThematicBreakVisitor);\n    realm.pubKey(\"addComposerChild\", HorizontalRulePlugin);\n  }\n});\nexport {\n  thematicBreakPlugin,\n  thematicBreakPluginHooks,\n  thematicBreakSystem\n};\n"],
  "mappings": "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",
  "names": ["INSERT_HORIZONTAL_RULE_COMMAND", "$isHorizontalRuleNode", "HorizontalRuleNode", "$createHorizontalRuleNode", "HorizontalRulePlugin", "import_LexicalHorizontalRuleNode", "import_LexicalHorizontalRuleNode"]
}
