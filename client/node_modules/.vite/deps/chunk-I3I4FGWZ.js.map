{
  "version": 3,
  "sources": ["../../lexical/Lexical.dev.js", "../../lexical/Lexical.js", "../../@lexical/selection/LexicalSelection.dev.js", "../../@lexical/selection/LexicalSelection.js", "../../@lexical/utils/LexicalUtils.dev.js", "../../@lexical/utils/LexicalUtils.js", "../../@lexical/html/LexicalHtml.dev.js", "../../@lexical/html/LexicalHtml.js", "../../@lexical/clipboard/LexicalClipboard.dev.js", "../../@lexical/clipboard/LexicalClipboard.js", "../../@lexical/rich-text/LexicalRichText.dev.js", "../../@lexical/rich-text/LexicalRichText.js", "../../@lexical/react/LexicalComposerContext.dev.js", "../../@lexical/react/LexicalComposerContext.js", "../../@lexical/history/LexicalHistory.dev.js", "../../@lexical/history/LexicalHistory.js", "../../@lexical/react/LexicalHistoryPlugin.dev.js", "../../@lexical/react/LexicalHistoryPlugin.js", "../../@mdxeditor/editor/dist/FormatConstants.js", "../../@mdxeditor/editor/dist/utils/fp.js", "../../@mdxeditor/editor/dist/utils/detectMac.js", "../../@mdxeditor/editor/dist/utils/uuid4.js", "../../@mdxeditor/editor/dist/gurx/realm.js", "../../@mdxeditor/editor/dist/gurx/realmFactory.js", "../../@mdxeditor/editor/dist/gurx/react.js", "../../@mdxeditor/editor/dist/plugins/core/index.js", "../../@mdxeditor/editor/dist/exportMarkdownFromLexical.js", "../../mdast-util-to-markdown/lib/configure.js", "../../mdast-util-to-markdown/lib/handle/blockquote.js", "../../mdast-util-to-markdown/lib/handle/break.js", "../../longest-streak/index.js", "../../mdast-util-to-markdown/lib/util/format-code-as-indented.js", "../../mdast-util-to-markdown/lib/util/check-fence.js", "../../mdast-util-to-markdown/lib/handle/code.js", "../../mdast-util-to-markdown/lib/util/check-quote.js", "../../mdast-util-to-markdown/lib/handle/definition.js", "../../mdast-util-to-markdown/lib/util/check-emphasis.js", "../../mdast-util-to-markdown/lib/handle/emphasis.js", "../../mdast-util-to-markdown/lib/util/format-heading-as-setext.js", "../../mdast-util-to-markdown/lib/handle/heading.js", "../../mdast-util-to-markdown/lib/handle/html.js", "../../mdast-util-to-markdown/lib/handle/image.js", "../../mdast-util-to-markdown/lib/handle/image-reference.js", "../../mdast-util-to-markdown/lib/util/format-link-as-autolink.js", "../../mdast-util-to-markdown/lib/handle/link.js", "../../mdast-util-to-markdown/lib/handle/link-reference.js", "../../mdast-util-to-markdown/lib/util/check-bullet-other.js", "../../mdast-util-to-markdown/lib/util/check-bullet-ordered.js", "../../mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js", "../../mdast-util-to-markdown/lib/util/check-rule.js", "../../mdast-util-to-markdown/lib/handle/list.js", "../../mdast-util-to-markdown/lib/handle/paragraph.js", "../../mdast-util-phrasing/lib/index.js", "../../mdast-util-to-markdown/lib/handle/root.js", "../../mdast-util-to-markdown/lib/util/check-strong.js", "../../mdast-util-to-markdown/lib/handle/strong.js", "../../mdast-util-to-markdown/lib/handle/text.js", "../../mdast-util-to-markdown/lib/util/check-rule-repetition.js", "../../mdast-util-to-markdown/lib/handle/thematic-break.js", "../../mdast-util-to-markdown/lib/handle/index.js", "../../mdast-util-to-markdown/lib/join.js", "../../mdast-util-to-markdown/lib/unsafe.js", "../../mdast-util-to-markdown/lib/index.js", "../../@mdxeditor/editor/dist/importMarkdownToLexical.js", "../../@mdxeditor/editor/dist/plugins/core/LexicalLinebreakVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/LexicalParagraphVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/LexicalRootVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/LexicalTextVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/MdastFormattingVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/MdastInlineCodeVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/MdastParagraphVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/MdastRootVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/MdastTextVisitor.js", "../../@mdxeditor/editor/dist/plugins/core/SharedHistoryPlugin.js", "../../@mdxeditor/editor/dist/plugins/core/MdastBreakVisitor.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createCommand(type) {\n  return {\n    type\n  } ;\n}\nconst SELECTION_CHANGE_COMMAND = createCommand('SELECTION_CHANGE_COMMAND');\nconst CLICK_COMMAND = createCommand('CLICK_COMMAND');\nconst DELETE_CHARACTER_COMMAND = createCommand('DELETE_CHARACTER_COMMAND');\nconst INSERT_LINE_BREAK_COMMAND = createCommand('INSERT_LINE_BREAK_COMMAND');\nconst INSERT_PARAGRAPH_COMMAND = createCommand('INSERT_PARAGRAPH_COMMAND');\nconst CONTROLLED_TEXT_INSERTION_COMMAND = createCommand('CONTROLLED_TEXT_INSERTION_COMMAND');\nconst PASTE_COMMAND = createCommand('PASTE_COMMAND');\nconst REMOVE_TEXT_COMMAND = createCommand('REMOVE_TEXT_COMMAND');\nconst DELETE_WORD_COMMAND = createCommand('DELETE_WORD_COMMAND');\nconst DELETE_LINE_COMMAND = createCommand('DELETE_LINE_COMMAND');\nconst FORMAT_TEXT_COMMAND = createCommand('FORMAT_TEXT_COMMAND');\nconst UNDO_COMMAND = createCommand('UNDO_COMMAND');\nconst REDO_COMMAND = createCommand('REDO_COMMAND');\nconst KEY_DOWN_COMMAND = createCommand('KEYDOWN_COMMAND');\nconst KEY_ARROW_RIGHT_COMMAND = createCommand('KEY_ARROW_RIGHT_COMMAND');\nconst MOVE_TO_END = createCommand('MOVE_TO_END');\nconst KEY_ARROW_LEFT_COMMAND = createCommand('KEY_ARROW_LEFT_COMMAND');\nconst MOVE_TO_START = createCommand('MOVE_TO_START');\nconst KEY_ARROW_UP_COMMAND = createCommand('KEY_ARROW_UP_COMMAND');\nconst KEY_ARROW_DOWN_COMMAND = createCommand('KEY_ARROW_DOWN_COMMAND');\nconst KEY_ENTER_COMMAND = createCommand('KEY_ENTER_COMMAND');\nconst KEY_SPACE_COMMAND = createCommand('KEY_SPACE_COMMAND');\nconst KEY_BACKSPACE_COMMAND = createCommand('KEY_BACKSPACE_COMMAND');\nconst KEY_ESCAPE_COMMAND = createCommand('KEY_ESCAPE_COMMAND');\nconst KEY_DELETE_COMMAND = createCommand('KEY_DELETE_COMMAND');\nconst KEY_TAB_COMMAND = createCommand('KEY_TAB_COMMAND');\nconst INSERT_TAB_COMMAND = createCommand('INSERT_TAB_COMMAND');\nconst INDENT_CONTENT_COMMAND = createCommand('INDENT_CONTENT_COMMAND');\nconst OUTDENT_CONTENT_COMMAND = createCommand('OUTDENT_CONTENT_COMMAND');\nconst DROP_COMMAND = createCommand('DROP_COMMAND');\nconst FORMAT_ELEMENT_COMMAND = createCommand('FORMAT_ELEMENT_COMMAND');\nconst DRAGSTART_COMMAND = createCommand('DRAGSTART_COMMAND');\nconst DRAGOVER_COMMAND = createCommand('DRAGOVER_COMMAND');\nconst DRAGEND_COMMAND = createCommand('DRAGEND_COMMAND');\nconst COPY_COMMAND = createCommand('COPY_COMMAND');\nconst CUT_COMMAND = createCommand('CUT_COMMAND');\nconst SELECT_ALL_COMMAND = createCommand('SELECT_ALL_COMMAND');\nconst CLEAR_EDITOR_COMMAND = createCommand('CLEAR_EDITOR_COMMAND');\nconst CLEAR_HISTORY_COMMAND = createCommand('CLEAR_HISTORY_COMMAND');\nconst CAN_REDO_COMMAND = createCommand('CAN_REDO_COMMAND');\nconst CAN_UNDO_COMMAND = createCommand('CAN_UNDO_COMMAND');\nconst FOCUS_COMMAND = createCommand('FOCUS_COMMAND');\nconst BLUR_COMMAND = createCommand('BLUR_COMMAND');\nconst KEY_MODIFIER_COMMAND = createCommand('KEY_MODIFIER_COMMAND');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nconst IS_FIREFOX = CAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst DOM_ELEMENT_TYPE = 1;\nconst DOM_TEXT_TYPE = 3; // Reconciling\n\nconst NO_DIRTY_NODES = 0;\nconst HAS_DIRTY_NODES = 1;\nconst FULL_RECONCILE = 2; // Text node modes\n\nconst IS_NORMAL = 0;\nconst IS_TOKEN = 1;\nconst IS_SEGMENTED = 2; // IS_INERT = 3\n// Text node formatting\n\nconst IS_BOLD = 1;\nconst IS_ITALIC = 1 << 1;\nconst IS_STRIKETHROUGH = 1 << 2;\nconst IS_UNDERLINE = 1 << 3;\nconst IS_CODE = 1 << 4;\nconst IS_SUBSCRIPT = 1 << 5;\nconst IS_SUPERSCRIPT = 1 << 6;\nconst IS_HIGHLIGHT = 1 << 7;\nconst IS_ALL_FORMATTING = IS_BOLD | IS_ITALIC | IS_STRIKETHROUGH | IS_UNDERLINE | IS_CODE | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT; // Text node details\n\nconst IS_DIRECTIONLESS = 1;\nconst IS_UNMERGEABLE = 1 << 1; // Element node formatting\n\nconst IS_ALIGN_LEFT = 1;\nconst IS_ALIGN_CENTER = 2;\nconst IS_ALIGN_RIGHT = 3;\nconst IS_ALIGN_JUSTIFY = 4;\nconst IS_ALIGN_START = 5;\nconst IS_ALIGN_END = 6; // Reconciliation\n\nconst NON_BREAKING_SPACE = '\\u00A0';\nconst ZERO_WIDTH_SPACE = '\\u200b'; // For iOS/Safari we use a non breaking space, otherwise the cursor appears\n// overlapping the composed text.\n\nconst COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;\nconst DOUBLE_LINE_BREAK = '\\n\\n'; // For FF, we need to use a non-breaking space, or it gets composition\n// in a stuck state.\n\nconst COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;\nconst RTL = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\nconst LTR = 'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6' + '\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF\\u200E\\u2C00-\\uFB1C' + '\\uFE00-\\uFE6F\\uFEFD-\\uFFFF'; // eslint-disable-next-line no-misleading-character-class\n\nconst RTL_REGEX = new RegExp('^[^' + LTR + ']*[' + RTL + ']'); // eslint-disable-next-line no-misleading-character-class\n\nconst LTR_REGEX = new RegExp('^[^' + RTL + ']*[' + LTR + ']');\nconst TEXT_TYPE_TO_FORMAT = {\n  bold: IS_BOLD,\n  code: IS_CODE,\n  highlight: IS_HIGHLIGHT,\n  italic: IS_ITALIC,\n  strikethrough: IS_STRIKETHROUGH,\n  subscript: IS_SUBSCRIPT,\n  superscript: IS_SUPERSCRIPT,\n  underline: IS_UNDERLINE\n};\nconst DETAIL_TYPE_TO_DETAIL = {\n  directionless: IS_DIRECTIONLESS,\n  unmergeable: IS_UNMERGEABLE\n};\nconst ELEMENT_TYPE_TO_FORMAT = {\n  center: IS_ALIGN_CENTER,\n  end: IS_ALIGN_END,\n  justify: IS_ALIGN_JUSTIFY,\n  left: IS_ALIGN_LEFT,\n  right: IS_ALIGN_RIGHT,\n  start: IS_ALIGN_START\n};\nconst ELEMENT_FORMAT_TO_TYPE = {\n  [IS_ALIGN_CENTER]: 'center',\n  [IS_ALIGN_END]: 'end',\n  [IS_ALIGN_JUSTIFY]: 'justify',\n  [IS_ALIGN_LEFT]: 'left',\n  [IS_ALIGN_RIGHT]: 'right',\n  [IS_ALIGN_START]: 'start'\n};\nconst TEXT_MODE_TO_TYPE = {\n  normal: IS_NORMAL,\n  segmented: IS_SEGMENTED,\n  token: IS_TOKEN\n};\nconst TEXT_TYPE_TO_MODE = {\n  [IS_NORMAL]: 'normal',\n  [IS_SEGMENTED]: 'segmented',\n  [IS_TOKEN]: 'token'\n};\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst TEXT_MUTATION_VARIANCE = 100;\nlet isProcessingMutations = false;\nlet lastTextEntryTimeStamp = 0;\nfunction getIsProcesssingMutations() {\n  return isProcessingMutations;\n}\n\nfunction updateTimeStamp(event) {\n  lastTextEntryTimeStamp = event.timeStamp;\n}\n\nfunction initTextEntryListener(editor) {\n  if (lastTextEntryTimeStamp === 0) {\n    getWindow(editor).addEventListener('textInput', updateTimeStamp, true);\n  }\n}\n\nfunction isManagedLineBreak(dom, target, editor) {\n  return (// @ts-expect-error: internal field\n    target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.\n    dom[`__lexicalKey_${editor._key}`] !== undefined\n  );\n}\n\nfunction getLastSelection(editor) {\n  return editor.getEditorState().read(() => {\n    const selection = $getSelection();\n    return selection !== null ? selection.clone() : null;\n  });\n}\n\nfunction handleTextMutation(target, node, editor) {\n  const domSelection = getDOMSelection(editor._window);\n  let anchorOffset = null;\n  let focusOffset = null;\n\n  if (domSelection !== null && domSelection.anchorNode === target) {\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n  }\n\n  const text = target.nodeValue;\n\n  if (text !== null) {\n    $updateTextNodeFromDOMContent(node, text, anchorOffset, focusOffset, false);\n  }\n}\n\nfunction shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {\n  if ($isRangeSelection(selection)) {\n    const anchorNode = selection.anchor.getNode();\n\n    if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {\n      return false;\n    }\n  }\n\n  return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();\n}\n\nfunction $flushMutations$1(editor, mutations, observer) {\n  isProcessingMutations = true;\n  const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;\n\n  try {\n    updateEditor(editor, () => {\n      const selection = $getSelection() || getLastSelection(editor);\n      const badDOMTargets = new Map();\n      const rootElement = editor.getRootElement(); // We use the current editor state, as that reflects what is\n      // actually \"on screen\".\n\n      const currentEditorState = editor._editorState;\n      const blockCursorElement = editor._blockCursorElement;\n      let shouldRevertSelection = false;\n      let possibleTextForFirefoxPaste = '';\n\n      for (let i = 0; i < mutations.length; i++) {\n        const mutation = mutations[i];\n        const type = mutation.type;\n        const targetDOM = mutation.target;\n        let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);\n\n        if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode(targetNode)) {\n          continue;\n        }\n\n        if (type === 'characterData') {\n          // Text mutations are deferred and passed to mutation listeners to be\n          // processed outside of the Lexical engine.\n          if (shouldFlushTextMutations && $isTextNode(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {\n            handleTextMutation( // nodeType === DOM_TEXT_TYPE is a Text DOM node\n            targetDOM, targetNode, editor);\n          }\n        } else if (type === 'childList') {\n          shouldRevertSelection = true; // We attempt to \"undo\" any changes that have occurred outside\n          // of Lexical. We want Lexical's editor state to be source of truth.\n          // To the user, these will look like no-ops.\n\n          const addedDOMs = mutation.addedNodes;\n\n          for (let s = 0; s < addedDOMs.length; s++) {\n            const addedDOM = addedDOMs[s];\n            const node = getNodeFromDOMNode(addedDOM);\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== 'BR' || !isManagedLineBreak(addedDOM, parentDOM, editor))) {\n              if (IS_FIREFOX) {\n                const possibleText = addedDOM.innerText || addedDOM.nodeValue;\n\n                if (possibleText) {\n                  possibleTextForFirefoxPaste += possibleText;\n                }\n              }\n\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n\n          const removedDOMs = mutation.removedNodes;\n          const removedDOMsLength = removedDOMs.length;\n\n          if (removedDOMsLength > 0) {\n            let unremovedBRs = 0;\n\n            for (let s = 0; s < removedDOMsLength; s++) {\n              const removedDOM = removedDOMs[s];\n\n              if (removedDOM.nodeName === 'BR' && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {\n                targetDOM.appendChild(removedDOM);\n                unremovedBRs++;\n              }\n            }\n\n            if (removedDOMsLength !== unremovedBRs) {\n              if (targetDOM === rootElement) {\n                targetNode = internalGetRoot(currentEditorState);\n              }\n\n              badDOMTargets.set(targetDOM, targetNode);\n            }\n          }\n        }\n      } // Now we process each of the unique target nodes, attempting\n      // to restore their contents back to the source of truth, which\n      // is Lexical's \"current\" editor state. This is basically like\n      // an internal revert on the DOM.\n\n\n      if (badDOMTargets.size > 0) {\n        for (const [targetDOM, targetNode] of badDOMTargets) {\n          if ($isElementNode(targetNode)) {\n            const childKeys = targetNode.getChildrenKeys();\n            let currentDOM = targetDOM.firstChild;\n\n            for (let s = 0; s < childKeys.length; s++) {\n              const key = childKeys[s];\n              const correctDOM = editor.getElementByKey(key);\n\n              if (correctDOM === null) {\n                continue;\n              }\n\n              if (currentDOM == null) {\n                targetDOM.appendChild(correctDOM);\n                currentDOM = correctDOM;\n              } else if (currentDOM !== correctDOM) {\n                targetDOM.replaceChild(correctDOM, currentDOM);\n              }\n\n              currentDOM = currentDOM.nextSibling;\n            }\n          } else if ($isTextNode(targetNode)) {\n            targetNode.markDirty();\n          }\n        }\n      } // Capture all the mutations made during this function. This\n      // also prevents us having to process them on the next cycle\n      // of onMutation, as these mutations were made by us.\n\n\n      const records = observer.takeRecords(); // Check for any random auto-added <br> elements, and remove them.\n      // These get added by the browser when we undo the above mutations\n      // and this can lead to a broken UI.\n\n      if (records.length > 0) {\n        for (let i = 0; i < records.length; i++) {\n          const record = records[i];\n          const addedNodes = record.addedNodes;\n          const target = record.target;\n\n          for (let s = 0; s < addedNodes.length; s++) {\n            const addedDOM = addedNodes[s];\n            const parentDOM = addedDOM.parentNode;\n\n            if (parentDOM != null && addedDOM.nodeName === 'BR' && !isManagedLineBreak(addedDOM, target, editor)) {\n              parentDOM.removeChild(addedDOM);\n            }\n          }\n        } // Clear any of those removal mutations\n\n\n        observer.takeRecords();\n      }\n\n      if (selection !== null) {\n        if (shouldRevertSelection) {\n          selection.dirty = true;\n          $setSelection(selection);\n        }\n\n        if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n          selection.insertRawText(possibleTextForFirefoxPaste);\n        }\n      }\n    });\n  } finally {\n    isProcessingMutations = false;\n  }\n}\nfunction flushRootMutations(editor) {\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    const mutations = observer.takeRecords();\n    $flushMutations$1(editor, mutations, observer);\n  }\n}\nfunction initMutationObserver(editor) {\n  initTextEntryListener(editor);\n  editor._observer = new MutationObserver((mutations, observer) => {\n    $flushMutations$1(editor, mutations, observer);\n  });\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $canSimpleTextNodesBeMerged(node1, node2) {\n  const node1Mode = node1.__mode;\n  const node1Format = node1.__format;\n  const node1Style = node1.__style;\n  const node2Mode = node2.__mode;\n  const node2Format = node2.__format;\n  const node2Style = node2.__style;\n  return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);\n}\n\nfunction $mergeTextNodes(node1, node2) {\n  const writableNode1 = node1.mergeWithSibling(node2);\n\n  const normalizedNodes = getActiveEditor()._normalizedNodes;\n\n  normalizedNodes.add(node1.__key);\n  normalizedNodes.add(node2.__key);\n  return writableNode1;\n}\n\nfunction $normalizeTextNode(textNode) {\n  let node = textNode;\n\n  if (node.__text === '' && node.isSimpleText() && !node.isUnmergeable()) {\n    node.remove();\n    return;\n  } // Backward\n\n\n  let previousNode;\n\n  while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {\n    if (previousNode.__text === '') {\n      previousNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {\n      node = $mergeTextNodes(previousNode, node);\n      break;\n    } else {\n      break;\n    }\n  } // Forward\n\n\n  let nextNode;\n\n  while ((nextNode = node.getNextSibling()) !== null && $isTextNode(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {\n    if (nextNode.__text === '') {\n      nextNode.remove();\n    } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {\n      node = $mergeTextNodes(node, nextNode);\n      break;\n    } else {\n      break;\n    }\n  }\n}\nfunction $normalizeSelection(selection) {\n  $normalizePoint(selection.anchor);\n  $normalizePoint(selection.focus);\n  return selection;\n}\n\nfunction $normalizePoint(point) {\n  while (point.type === 'element') {\n    const node = point.getNode();\n    const offset = point.offset;\n    let nextNode;\n    let nextOffsetAtEnd;\n\n    if (offset === node.getChildrenSize()) {\n      nextNode = node.getChildAtIndex(offset - 1);\n      nextOffsetAtEnd = true;\n    } else {\n      nextNode = node.getChildAtIndex(offset);\n      nextOffsetAtEnd = false;\n    }\n\n    if ($isTextNode(nextNode)) {\n      point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, 'text');\n      break;\n    } else if (!$isElementNode(nextNode)) {\n      break;\n    }\n\n    point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, 'element');\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet keyCounter = 1;\nfunction generateRandomKey() {\n  return '' + keyCounter++;\n}\nfunction getRegisteredNodeOrThrow(editor, nodeType) {\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`registeredNode: Type ${nodeType} not found`);\n    }\n  }\n\n  return registeredNode;\n}\nconst scheduleMicroTask = typeof queueMicrotask === 'function' ? queueMicrotask : fn => {\n  // No window prefix intended (#1400)\n  Promise.resolve().then(fn);\n};\nfunction $isSelectionCapturedInDecorator(node) {\n  return $isDecoratorNode($getNearestNodeFromDOMNode(node));\n}\nfunction isSelectionCapturedInDecoratorInput(anchorDOM) {\n  const activeElement = document.activeElement;\n\n  if (activeElement === null) {\n    return false;\n  }\n\n  const nodeName = activeElement.nodeName;\n  return $isDecoratorNode($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === 'INPUT' || nodeName === 'TEXTAREA' || activeElement.contentEditable === 'true' && // @ts-ignore iternal field\n  activeElement.__lexicalEditor == null);\n}\nfunction isSelectionWithinEditor(editor, anchorDOM, focusDOM) {\n  const rootElement = editor.getRootElement();\n\n  try {\n    return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor\n    anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;\n  } catch (error) {\n    return false;\n  }\n}\nfunction getNearestEditorFromDOMNode(node) {\n  let currentNode = node;\n\n  while (currentNode != null) {\n    // @ts-expect-error: internal field\n    const editor = currentNode.__lexicalEditor;\n\n    if (editor != null) {\n      return editor;\n    }\n\n    currentNode = getParentElement(currentNode);\n  }\n\n  return null;\n}\nfunction getTextDirection(text) {\n  if (RTL_REGEX.test(text)) {\n    return 'rtl';\n  }\n\n  if (LTR_REGEX.test(text)) {\n    return 'ltr';\n  }\n\n  return null;\n}\nfunction $isTokenOrSegmented(node) {\n  return node.isToken() || node.isSegmented();\n}\n\nfunction isDOMNodeLexicalTextNode(node) {\n  return node.nodeType === DOM_TEXT_TYPE;\n}\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (isDOMNodeLexicalTextNode(node)) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\nfunction toggleTextFormatType(format, type, alignWithFormat) {\n  const activeFormat = TEXT_TYPE_TO_FORMAT[type];\n  const isStateFlagPresent = format & activeFormat;\n\n  if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {\n    // Remove the state flag.\n    return format ^ activeFormat;\n  }\n\n  if (alignWithFormat === null || alignWithFormat & activeFormat) {\n    // Add the state flag.\n    return format | activeFormat;\n  }\n\n  return format;\n}\nfunction $isLeafNode(node) {\n  return $isTextNode(node) || $isLineBreakNode(node) || $isDecoratorNode(node);\n}\nfunction $setNodeKey(node, existingKey) {\n  if (existingKey != null) {\n    node.__key = existingKey;\n    return;\n  }\n\n  errorOnReadOnly();\n  errorOnInfiniteTransforms();\n  const editor = getActiveEditor();\n  const editorState = getActiveEditorState();\n  const key = generateRandomKey();\n\n  editorState._nodeMap.set(key, node); // TODO Split this function into leaf/element\n\n\n  if ($isElementNode(node)) {\n    editor._dirtyElements.set(key, true);\n  } else {\n    editor._dirtyLeaves.add(key);\n  }\n\n  editor._cloneNotNeeded.add(key);\n\n  editor._dirtyType = HAS_DIRTY_NODES;\n  node.__key = key;\n}\n\nfunction internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {\n  let nextParentKey = parentKey;\n\n  while (nextParentKey !== null) {\n    if (dirtyElements.has(nextParentKey)) {\n      return;\n    }\n\n    const node = nodeMap.get(nextParentKey);\n\n    if (node === undefined) {\n      break;\n    }\n\n    dirtyElements.set(nextParentKey, false);\n    nextParentKey = node.__parent;\n  }\n}\n\nfunction removeFromParent(node) {\n  const oldParent = node.getParent();\n\n  if (oldParent !== null) {\n    const writableNode = node.getWritable();\n    const writableParent = oldParent.getWritable();\n    const prevSibling = node.getPreviousSibling();\n    const nextSibling = node.getNextSibling(); // TODO: this function duplicates a bunch of operations, can be simplified.\n\n    if (prevSibling === null) {\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableParent.__first = nextSibling.__key;\n        writableNextSibling.__prev = null;\n      } else {\n        writableParent.__first = null;\n      }\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n\n      if (nextSibling !== null) {\n        const writableNextSibling = nextSibling.getWritable();\n        writableNextSibling.__prev = writablePrevSibling.__key;\n        writablePrevSibling.__next = writableNextSibling.__key;\n      } else {\n        writablePrevSibling.__next = null;\n      }\n\n      writableNode.__prev = null;\n    }\n\n    if (nextSibling === null) {\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writableParent.__last = prevSibling.__key;\n        writablePrevSibling.__next = null;\n      } else {\n        writableParent.__last = null;\n      }\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n\n      if (prevSibling !== null) {\n        const writablePrevSibling = prevSibling.getWritable();\n        writablePrevSibling.__next = writableNextSibling.__key;\n        writableNextSibling.__prev = writablePrevSibling.__key;\n      } else {\n        writableNextSibling.__prev = null;\n      }\n\n      writableNode.__next = null;\n    }\n\n    writableParent.__size--;\n    writableNode.__parent = null;\n  }\n} // Never use this function directly! It will break\n// the cloning heuristic. Instead use node.getWritable().\n\nfunction internalMarkNodeAsDirty(node) {\n  errorOnInfiniteTransforms();\n  const latest = node.getLatest();\n  const parent = latest.__parent;\n  const editorState = getActiveEditorState();\n  const editor = getActiveEditor();\n  const nodeMap = editorState._nodeMap;\n  const dirtyElements = editor._dirtyElements;\n\n  if (parent !== null) {\n    internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);\n  }\n\n  const key = latest.__key;\n  editor._dirtyType = HAS_DIRTY_NODES;\n\n  if ($isElementNode(node)) {\n    dirtyElements.set(key, true);\n  } else {\n    // TODO split internally MarkNodeAsDirty into two dedicated Element/leave functions\n    editor._dirtyLeaves.add(key);\n  }\n}\nfunction internalMarkSiblingsAsDirty(node) {\n  const previousNode = node.getPreviousSibling();\n  const nextNode = node.getNextSibling();\n\n  if (previousNode !== null) {\n    internalMarkNodeAsDirty(previousNode);\n  }\n\n  if (nextNode !== null) {\n    internalMarkNodeAsDirty(nextNode);\n  }\n}\nfunction $setCompositionKey(compositionKey) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  const previousCompositionKey = editor._compositionKey;\n\n  if (compositionKey !== previousCompositionKey) {\n    editor._compositionKey = compositionKey;\n\n    if (previousCompositionKey !== null) {\n      const node = $getNodeByKey(previousCompositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n\n    if (compositionKey !== null) {\n      const node = $getNodeByKey(compositionKey);\n\n      if (node !== null) {\n        node.getWritable();\n      }\n    }\n  }\n}\nfunction $getCompositionKey() {\n  if (isCurrentlyReadOnlyMode()) {\n    return null;\n  }\n\n  const editor = getActiveEditor();\n  return editor._compositionKey;\n}\nfunction $getNodeByKey(key, _editorState) {\n  const editorState = _editorState || getActiveEditorState();\n\n  const node = editorState._nodeMap.get(key);\n\n  if (node === undefined) {\n    return null;\n  }\n\n  return node;\n}\nfunction getNodeFromDOMNode(dom, editorState) {\n  const editor = getActiveEditor(); // @ts-ignore We intentionally add this to the Node.\n\n  const key = dom[`__lexicalKey_${editor._key}`];\n\n  if (key !== undefined) {\n    return $getNodeByKey(key, editorState);\n  }\n\n  return null;\n}\nfunction $getNearestNodeFromDOMNode(startingDOM, editorState) {\n  let dom = startingDOM;\n\n  while (dom != null) {\n    const node = getNodeFromDOMNode(dom, editorState);\n\n    if (node !== null) {\n      return node;\n    }\n\n    dom = getParentElement(dom);\n  }\n\n  return null;\n}\nfunction cloneDecorators(editor) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = Object.assign({}, currentDecorators);\n  editor._pendingDecorators = pendingDecorators;\n  return pendingDecorators;\n}\nfunction getEditorStateTextContent(editorState) {\n  return editorState.read(() => $getRoot().getTextContent());\n}\nfunction markAllNodesAsDirty(editor, type) {\n  // Mark all existing text nodes as dirty\n  updateEditor(editor, () => {\n    const editorState = getActiveEditorState();\n\n    if (editorState.isEmpty()) {\n      return;\n    }\n\n    if (type === 'root') {\n      $getRoot().markDirty();\n      return;\n    }\n\n    const nodeMap = editorState._nodeMap;\n\n    for (const [, node] of nodeMap) {\n      node.markDirty();\n    }\n  }, editor._pendingEditorState === null ? {\n    tag: 'history-merge'\n  } : undefined);\n}\nfunction $getRoot() {\n  return internalGetRoot(getActiveEditorState());\n}\nfunction internalGetRoot(editorState) {\n  return editorState._nodeMap.get('root');\n}\nfunction $setSelection(selection) {\n  errorOnReadOnly();\n  const editorState = getActiveEditorState();\n\n  if (selection !== null) {\n    {\n      if (Object.isFrozen(selection)) {\n        {\n          throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);\n        }\n      }\n    }\n\n    selection.dirty = true;\n    selection._cachedNodes = null;\n  }\n\n  editorState._selection = selection;\n}\nfunction $flushMutations() {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n  flushRootMutations(editor);\n}\nfunction getNodeFromDOM(dom) {\n  const editor = getActiveEditor();\n  const nodeKey = getNodeKeyFromDOM(dom, editor);\n\n  if (nodeKey === null) {\n    const rootElement = editor.getRootElement();\n\n    if (dom === rootElement) {\n      return $getNodeByKey('root');\n    }\n\n    return null;\n  }\n\n  return $getNodeByKey(nodeKey);\n}\nfunction getTextNodeOffset(node, moveSelectionToEnd) {\n  return moveSelectionToEnd ? node.getTextContentSize() : 0;\n}\n\nfunction getNodeKeyFromDOM( // Note that node here refers to a DOM Node, not an Lexical Node\ndom, editor) {\n  let node = dom;\n\n  while (node != null) {\n    // @ts-ignore We intentionally add this to the Node.\n    const key = node[`__lexicalKey_${editor._key}`];\n\n    if (key !== undefined) {\n      return key;\n    }\n\n    node = getParentElement(node);\n  }\n\n  return null;\n}\n\nfunction doesContainGrapheme(str) {\n  return /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g.test(str);\n}\nfunction getEditorsToPropagate(editor) {\n  const editorsToPropagate = [];\n  let currentEditor = editor;\n\n  while (currentEditor !== null) {\n    editorsToPropagate.push(currentEditor);\n    currentEditor = currentEditor._parentEditor;\n  }\n\n  return editorsToPropagate;\n}\nfunction createUID() {\n  return Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 5);\n}\nfunction getAnchorTextFromDOM(anchorNode) {\n  if (anchorNode.nodeType === DOM_TEXT_TYPE) {\n    return anchorNode.nodeValue;\n  }\n\n  return null;\n}\nfunction $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {\n  // Update the text content with the latest composition text\n  const domSelection = getDOMSelection(editor._window);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const anchorNode = domSelection.anchorNode;\n  let {\n    anchorOffset,\n    focusOffset\n  } = domSelection;\n\n  if (anchorNode !== null) {\n    let textContent = getAnchorTextFromDOM(anchorNode);\n    const node = $getNearestNodeFromDOMNode(anchorNode);\n\n    if (textContent !== null && $isTextNode(node)) {\n      // Data is intentionally truthy, as we check for boolean, null and empty string.\n      if (textContent === COMPOSITION_SUFFIX && data) {\n        const offset = data.length;\n        textContent = data;\n        anchorOffset = offset;\n        focusOffset = offset;\n      }\n\n      if (textContent !== null) {\n        $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);\n      }\n    }\n  }\n}\nfunction $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {\n  let node = textNode;\n\n  if (node.isAttached() && (compositionEnd || !node.isDirty())) {\n    const isComposing = node.isComposing();\n    let normalizedTextContent = textContent;\n\n    if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {\n      normalizedTextContent = textContent.slice(0, -1);\n    }\n\n    const prevTextContent = node.getTextContent();\n\n    if (compositionEnd || normalizedTextContent !== prevTextContent) {\n      if (normalizedTextContent === '') {\n        $setCompositionKey(null);\n\n        if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {\n          // For composition (mainly Android), we have to remove the node on a later update\n          const editor = getActiveEditor();\n          setTimeout(() => {\n            editor.update(() => {\n              if (node.isAttached()) {\n                node.remove();\n              }\n            });\n          }, 20);\n        } else {\n          node.remove();\n        }\n\n        return;\n      }\n\n      const parent = node.getParent();\n      const prevSelection = $getPreviousSelection();\n      const prevTextContentSize = node.getTextContentSize();\n      const compositionKey = $getCompositionKey();\n      const nodeKey = node.getKey();\n\n      if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need\n      // to clear this input from occurring as that action wasn't permitted.\n      $isRangeSelection(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter())) {\n        node.markDirty();\n        return;\n      }\n\n      const selection = $getSelection();\n\n      if (!$isRangeSelection(selection) || anchorOffset === null || focusOffset === null) {\n        node.setTextContent(normalizedTextContent);\n        return;\n      }\n\n      selection.setTextNodeRange(node, anchorOffset, node, focusOffset);\n\n      if (node.isSegmented()) {\n        const originalTextContent = node.getTextContent();\n        const replacement = $createTextNode(originalTextContent);\n        node.replace(replacement);\n        node = replacement;\n      }\n\n      node.setTextContent(normalizedTextContent);\n    }\n  }\n}\n\nfunction $previousSiblingDoesNotAcceptText(node) {\n  const previousSibling = node.getPreviousSibling();\n  return ($isTextNode(previousSibling) || $isElementNode(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();\n} // This function is connected to $shouldPreventDefaultAndInsertText and determines whether the\n// TextNode boundaries are writable or we should use the previous/next sibling instead. For example,\n// in the case of a LinkNode, boundaries are not writable.\n\n\nfunction $shouldInsertTextAfterOrBeforeTextNode(selection, node) {\n  if (node.isSegmented()) {\n    return true;\n  }\n\n  if (!selection.isCollapsed()) {\n    return false;\n  }\n\n  const offset = selection.anchor.offset;\n  const parent = node.getParentOrThrow();\n  const isToken = node.isToken();\n\n  if (offset === 0) {\n    return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);\n  } else if (offset === node.getTextContentSize()) {\n    return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;\n  } else {\n    return false;\n  }\n}\nfunction isTab(keyCode, altKey, ctrlKey, metaKey) {\n  return keyCode === 9 && !altKey && !ctrlKey && !metaKey;\n}\nfunction isBold(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 66 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isItalic(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 73 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isUnderline(keyCode, altKey, metaKey, ctrlKey) {\n  return keyCode === 85 && !altKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isParagraph(keyCode, shiftKey) {\n  return isReturn(keyCode) && !shiftKey;\n}\nfunction isLineBreak(keyCode, shiftKey) {\n  return isReturn(keyCode) && shiftKey;\n} // Inserts a new line after the selection\n\nfunction isOpenLineBreak(keyCode, ctrlKey) {\n  // 79 = KeyO\n  return IS_APPLE && ctrlKey && keyCode === 79;\n}\nfunction isDeleteWordBackward(keyCode, altKey, ctrlKey) {\n  return isBackspace(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteWordForward(keyCode, altKey, ctrlKey) {\n  return isDelete(keyCode) && (IS_APPLE ? altKey : ctrlKey);\n}\nfunction isDeleteLineBackward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isBackspace(keyCode);\n}\nfunction isDeleteLineForward(keyCode, metaKey) {\n  return IS_APPLE && metaKey && isDelete(keyCode);\n}\nfunction isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    if (altKey || metaKey) {\n      return false;\n    }\n\n    return isBackspace(keyCode) || keyCode === 72 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isBackspace(keyCode);\n}\nfunction isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  if (IS_APPLE) {\n    if (shiftKey || altKey || metaKey) {\n      return false;\n    }\n\n    return isDelete(keyCode) || keyCode === 68 && ctrlKey;\n  }\n\n  if (ctrlKey || altKey || metaKey) {\n    return false;\n  }\n\n  return isDelete(keyCode);\n}\nfunction isUndo(keyCode, shiftKey, metaKey, ctrlKey) {\n  return keyCode === 90 && !shiftKey && controlOrMeta(metaKey, ctrlKey);\n}\nfunction isRedo(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return keyCode === 90 && metaKey && shiftKey;\n  }\n\n  return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;\n}\nfunction isCopy(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 67) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\nfunction isCut(keyCode, shiftKey, metaKey, ctrlKey) {\n  if (shiftKey) {\n    return false;\n  }\n\n  if (keyCode === 88) {\n    return IS_APPLE ? metaKey : ctrlKey;\n  }\n\n  return false;\n}\n\nfunction isArrowLeft(keyCode) {\n  return keyCode === 37;\n}\n\nfunction isArrowRight(keyCode) {\n  return keyCode === 39;\n}\n\nfunction isArrowUp(keyCode) {\n  return keyCode === 38;\n}\n\nfunction isArrowDown(keyCode) {\n  return keyCode === 40;\n}\n\nfunction isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveForward(keyCode, ctrlKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;\n}\nfunction isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {\n  return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);\n}\nfunction isMoveUp(keyCode, ctrlKey, metaKey) {\n  return isArrowUp(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isMoveDown(keyCode, ctrlKey, metaKey) {\n  return isArrowDown(keyCode) && !ctrlKey && !metaKey;\n}\nfunction isModifier(ctrlKey, shiftKey, altKey, metaKey) {\n  return ctrlKey || shiftKey || altKey || metaKey;\n}\nfunction isSpace(keyCode) {\n  return keyCode === 32;\n}\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n\n  return ctrlKey;\n}\nfunction isReturn(keyCode) {\n  return keyCode === 13;\n}\nfunction isBackspace(keyCode) {\n  return keyCode === 8;\n}\nfunction isEscape(keyCode) {\n  return keyCode === 27;\n}\nfunction isDelete(keyCode) {\n  return keyCode === 46;\n}\nfunction isSelectAll(keyCode, metaKey, ctrlKey) {\n  return keyCode === 65 && controlOrMeta(metaKey, ctrlKey);\n}\nfunction $selectAll() {\n  const root = $getRoot();\n  const selection = root.select(0, root.getChildrenSize());\n  $setSelection($normalizeSelection(selection));\n}\nfunction getCachedClassNameArray(classNamesTheme, classNameThemeType) {\n  if (classNamesTheme.__lexicalClassNameCache === undefined) {\n    classNamesTheme.__lexicalClassNameCache = {};\n  }\n\n  const classNamesCache = classNamesTheme.__lexicalClassNameCache;\n  const cachedClassNames = classNamesCache[classNameThemeType];\n\n  if (cachedClassNames !== undefined) {\n    return cachedClassNames;\n  }\n\n  const classNames = classNamesTheme[classNameThemeType]; // As we're using classList, we need\n  // to handle className tokens that have spaces.\n  // The easiest way to do this to convert the\n  // className tokens to an array that can be\n  // applied to classList.add()/remove().\n\n  if (typeof classNames === 'string') {\n    const classNamesArr = classNames.split(' ');\n    classNamesCache[classNameThemeType] = classNamesArr;\n    return classNamesArr;\n  }\n\n  return classNames;\n}\nfunction setMutatedNode(mutatedNodes, registeredNodes, mutationListeners, node, mutation) {\n  if (mutationListeners.size === 0) {\n    return;\n  }\n\n  const nodeType = node.__type;\n  const nodeKey = node.__key;\n  const registeredNode = registeredNodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Type ${nodeType} not in registeredNodes`);\n    }\n  }\n\n  const klass = registeredNode.klass;\n  let mutatedNodesByType = mutatedNodes.get(klass);\n\n  if (mutatedNodesByType === undefined) {\n    mutatedNodesByType = new Map();\n    mutatedNodes.set(klass, mutatedNodesByType);\n  }\n\n  const prevMutation = mutatedNodesByType.get(nodeKey); // If the node has already been \"destroyed\", yet we are\n  // re-making it, then this means a move likely happened.\n  // We should change the mutation to be that of \"updated\"\n  // instead.\n\n  const isMove = prevMutation === 'destroyed' && mutation === 'created';\n\n  if (prevMutation === undefined || isMove) {\n    mutatedNodesByType.set(nodeKey, isMove ? 'updated' : mutation);\n  }\n}\nfunction $nodesOfType(klass) {\n  const editorState = getActiveEditorState();\n  const readOnly = editorState._readOnly;\n  const klassType = klass.getType();\n  const nodes = editorState._nodeMap;\n  const nodesOfType = [];\n\n  for (const [, node] of nodes) {\n    if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {\n      nodesOfType.push(node);\n    }\n  }\n\n  return nodesOfType;\n}\n\nfunction resolveElement(element, isBackward, focusOffset) {\n  const parent = element.getParent();\n  let offset = focusOffset;\n  let block = element;\n\n  if (parent !== null) {\n    if (isBackward && focusOffset === 0) {\n      offset = block.getIndexWithinParent();\n      block = parent;\n    } else if (!isBackward && focusOffset === block.getChildrenSize()) {\n      offset = block.getIndexWithinParent() + 1;\n      block = parent;\n    }\n  }\n\n  return block.getChildAtIndex(isBackward ? offset - 1 : offset);\n}\n\nfunction $getAdjacentNode(focus, isBackward) {\n  const focusOffset = focus.offset;\n\n  if (focus.type === 'element') {\n    const block = focus.getNode();\n    return resolveElement(block, isBackward, focusOffset);\n  } else {\n    const focusNode = focus.getNode();\n\n    if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {\n      const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();\n\n      if (possibleNode === null) {\n        return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));\n      }\n\n      return possibleNode;\n    }\n  }\n\n  return null;\n}\nfunction isFirefoxClipboardEvents(editor) {\n  const event = getWindow(editor).event;\n  const inputType = event && event.inputType;\n  return inputType === 'insertFromPaste' || inputType === 'insertFromPasteAsQuotation';\n}\nfunction dispatchCommand(editor, command, payload) {\n  return triggerCommandListeners(editor, command, payload);\n}\nfunction $textContentRequiresDoubleLinebreakAtEnd(node) {\n  return !$isRootNode(node) && !node.isLastChild() && !node.isInline();\n}\nfunction getElementByKeyOrThrow(editor, key) {\n  const element = editor._keyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\nfunction getParentElement(node) {\n  const parentElement = node.assignedSlot || node.parentElement;\n  return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;\n}\nfunction scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {\n  const doc = rootElement.ownerDocument;\n  const defaultView = doc.defaultView;\n\n  if (defaultView === null) {\n    return;\n  }\n\n  let {\n    top: currentTop,\n    bottom: currentBottom\n  } = selectionRect;\n  let targetTop = 0;\n  let targetBottom = 0;\n  let element = rootElement;\n\n  while (element !== null) {\n    const isBodyElement = element === doc.body;\n\n    if (isBodyElement) {\n      targetTop = 0;\n      targetBottom = getWindow(editor).innerHeight;\n    } else {\n      const targetRect = element.getBoundingClientRect();\n      targetTop = targetRect.top;\n      targetBottom = targetRect.bottom;\n    }\n\n    let diff = 0;\n\n    if (currentTop < targetTop) {\n      diff = -(targetTop - currentTop);\n    } else if (currentBottom > targetBottom) {\n      diff = currentBottom - targetBottom;\n    }\n\n    if (diff !== 0) {\n      if (isBodyElement) {\n        // Only handles scrolling of Y axis\n        defaultView.scrollBy(0, diff);\n      } else {\n        const scrollTop = element.scrollTop;\n        element.scrollTop += diff;\n        const yOffset = element.scrollTop - scrollTop;\n        currentTop -= yOffset;\n        currentBottom -= yOffset;\n      }\n    }\n\n    if (isBodyElement) {\n      break;\n    }\n\n    element = getParentElement(element);\n  }\n}\nfunction $hasUpdateTag(tag) {\n  const editor = getActiveEditor();\n  return editor._updateTags.has(tag);\n}\nfunction $addUpdateTag(tag) {\n  errorOnReadOnly();\n  const editor = getActiveEditor();\n\n  editor._updateTags.add(tag);\n}\nfunction $maybeMoveChildrenSelectionToParent(parentNode) {\n  const selection = $getSelection();\n\n  if (!$isRangeSelection(selection) || !$isElementNode(parentNode)) {\n    return selection;\n  }\n\n  const {\n    anchor,\n    focus\n  } = selection;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if ($hasAncestor(anchorNode, parentNode)) {\n    anchor.set(parentNode.__key, 0, 'element');\n  }\n\n  if ($hasAncestor(focusNode, parentNode)) {\n    focus.set(parentNode.__key, 0, 'element');\n  }\n\n  return selection;\n}\nfunction $hasAncestor(child, targetNode) {\n  let parent = child.getParent();\n\n  while (parent !== null) {\n    if (parent.is(targetNode)) {\n      return true;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return false;\n}\nfunction getDefaultView(domElem) {\n  const ownerDoc = domElem.ownerDocument;\n  return ownerDoc && ownerDoc.defaultView || null;\n}\nfunction getWindow(editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    {\n      throw Error(`window object not found`);\n    }\n  }\n\n  return windowObj;\n}\nfunction $isInlineElementOrDecoratorNode(node) {\n  return $isElementNode(node) && node.isInline() || $isDecoratorNode(node) && node.isInline();\n}\nfunction $getNearestRootOrShadowRoot(node) {\n  let parent = node.getParentOrThrow();\n\n  while (parent !== null) {\n    if ($isRootOrShadowRoot(parent)) {\n      return parent;\n    }\n\n    parent = parent.getParentOrThrow();\n  }\n\n  return parent;\n}\nfunction $isRootOrShadowRoot(node) {\n  return $isRootNode(node) || $isElementNode(node) && node.isShadowRoot();\n}\nfunction $copyNode(node) {\n  // @ts-ignore\n  const copy = node.constructor.clone(node);\n  $setNodeKey(copy, null);\n  return copy;\n}\nfunction $applyNodeReplacement(node) {\n  const editor = getActiveEditor();\n  const nodeType = node.constructor.getType();\n\n  const registeredNode = editor._nodes.get(nodeType);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the \"nodes\" array in the editor config.`);\n    }\n  }\n\n  const replaceFunc = registeredNode.replace;\n\n  if (replaceFunc !== null) {\n    const replacementNode = replaceFunc(node);\n\n    if (!(replacementNode instanceof node.constructor)) {\n      {\n        throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);\n      }\n    }\n\n    return replacementNode;\n  }\n\n  return node;\n}\nfunction errorOnInsertTextNodeOnRoot(node, insertNode) {\n  const parentNode = node.getParent();\n\n  if ($isRootNode(parentNode) && !$isElementNode(insertNode) && !$isDecoratorNode(insertNode)) {\n    {\n      throw Error(`Only element or decorator nodes can be inserted in to the root node`);\n    }\n  }\n}\n\nfunction createBlockCursorElement(editorConfig) {\n  const theme = editorConfig.theme;\n  const element = document.createElement('div');\n  element.contentEditable = 'false';\n  element.setAttribute('data-lexical-cursor', 'true');\n  let blockCursorTheme = theme.blockCursor;\n\n  if (blockCursorTheme !== undefined) {\n    if (typeof blockCursorTheme === 'string') {\n      const classNamesArr = blockCursorTheme.split(' '); // @ts-expect-error: intentional\n\n      blockCursorTheme = theme.blockCursor = classNamesArr;\n    }\n\n    if (blockCursorTheme !== undefined) {\n      element.classList.add(...blockCursorTheme);\n    }\n  }\n\n  return element;\n}\n\nfunction needsBlockCursor(node) {\n  return ($isDecoratorNode(node) || $isElementNode(node) && !node.canBeEmpty()) && !node.isInline();\n}\n\nfunction removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {\n  rootElement.style.removeProperty('caret-color');\n  editor._blockCursorElement = null;\n  const parentElement = blockCursorElement.parentElement;\n\n  if (parentElement !== null) {\n    parentElement.removeChild(blockCursorElement);\n  }\n}\nfunction updateDOMBlockCursorElement(editor, rootElement, nextSelection) {\n  let blockCursorElement = editor._blockCursorElement;\n\n  if ($isRangeSelection(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === 'element' && rootElement.contains(document.activeElement)) {\n    const anchor = nextSelection.anchor;\n    const elementNode = anchor.getNode();\n    const offset = anchor.offset;\n    const elementNodeSize = elementNode.getChildrenSize();\n    let isBlockCursor = false;\n    let insertBeforeElement = null;\n\n    if (offset === elementNodeSize) {\n      const child = elementNode.getChildAtIndex(offset - 1);\n\n      if (needsBlockCursor(child)) {\n        isBlockCursor = true;\n      }\n    } else {\n      const child = elementNode.getChildAtIndex(offset);\n\n      if (needsBlockCursor(child)) {\n        const sibling = child.getPreviousSibling();\n\n        if (sibling === null || needsBlockCursor(sibling)) {\n          isBlockCursor = true;\n          insertBeforeElement = editor.getElementByKey(child.__key);\n        }\n      }\n    }\n\n    if (isBlockCursor) {\n      const elementDOM = editor.getElementByKey(elementNode.__key);\n\n      if (blockCursorElement === null) {\n        editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);\n      }\n\n      rootElement.style.caretColor = 'transparent';\n\n      if (insertBeforeElement === null) {\n        elementDOM.appendChild(blockCursorElement);\n      } else {\n        elementDOM.insertBefore(blockCursorElement, insertBeforeElement);\n      }\n\n      return;\n    }\n  } // Remove cursor\n\n\n  if (blockCursorElement !== null) {\n    removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n  }\n}\nfunction getDOMSelection(targetWindow) {\n  return !CAN_USE_DOM ? null : (targetWindow || window).getSelection();\n}\nfunction $splitNode(node, offset) {\n  let startNode = node.getChildAtIndex(offset);\n\n  if (startNode == null) {\n    startNode = node;\n  }\n\n  if (!!$isRootOrShadowRoot(node)) {\n    throw Error(`Can not call $splitNode() on root element`);\n  }\n\n  const recurse = currentNode => {\n    const parent = currentNode.getParentOrThrow();\n    const isParentRoot = $isRootOrShadowRoot(parent); // The node we start split from (leaf) is moved, but its recursive\n    // parents are copied to create separate tree\n\n    const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);\n\n    if (isParentRoot) {\n      currentNode.insertAfter(nodeToMove);\n      return [currentNode, nodeToMove, nodeToMove];\n    } else {\n      const [leftTree, rightTree, newParent] = recurse(parent);\n      const nextSiblings = currentNode.getNextSiblings();\n      newParent.append(nodeToMove, ...nextSiblings);\n      return [leftTree, rightTree, nodeToMove];\n    }\n  };\n\n  const [leftTree, rightTree] = recurse(startNode);\n  return [leftTree, rightTree];\n}\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== $getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\nfunction $getChildrenRecursively(node) {\n  const nodes = [];\n  const stack = [node];\n\n  while (stack.length > 0) {\n    const currentNode = stack.pop();\n\n    if (!(currentNode !== undefined)) {\n      throw Error(`Stack.length > 0; can't be undefined`);\n    }\n\n    if ($isElementNode(currentNode)) {\n      stack.unshift(...currentNode.getChildren());\n    }\n\n    if (currentNode !== node) {\n      nodes.push(currentNode);\n    }\n  }\n\n  return nodes;\n}\n/**\n * @param x - The element being tested\n * @returns Returns true if x is an HTML anchor tag, false otherwise\n */\n\nfunction isHTMLAnchorElement(x) {\n  return isHTMLElement(x) && x.tagName === 'A';\n}\n/**\n * @param x - The element being testing\n * @returns Returns true if x is an HTML element, false otherwise.\n */\n\nfunction isHTMLElement(x) {\n  // @ts-ignore-next-line - strict check on nodeType here should filter out non-Element EventTarget implementors\n  return x.nodeType === 1;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction $garbageCollectDetachedDecorators(editor, pendingEditorState) {\n  const currentDecorators = editor._decorators;\n  const pendingDecorators = editor._pendingDecorators;\n  let decorators = pendingDecorators || currentDecorators;\n  const nodeMap = pendingEditorState._nodeMap;\n  let key;\n\n  for (key in decorators) {\n    if (!nodeMap.has(key)) {\n      if (decorators === currentDecorators) {\n        decorators = cloneDecorators(editor);\n      }\n\n      delete decorators[key];\n    }\n  }\n}\n\nfunction $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {\n  let child = node.getFirstChild();\n\n  while (child !== null) {\n    const childKey = child.__key; // TODO Revise condition below, redundant? LexicalNode already cleans up children when moving Nodes\n\n    if (child.__parent === parentKey) {\n      if ($isElementNode(child)) {\n        $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);\n      } // If we have created a node and it was dereferenced, then also\n      // remove it from out dirty nodes Set.\n\n\n      if (!prevNodeMap.has(childKey)) {\n        dirtyNodes.delete(childKey);\n      }\n\n      nodeMapDelete.push(childKey);\n    }\n\n    child = child.getNextSibling();\n  }\n}\n\nfunction $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {\n  const prevNodeMap = prevEditorState._nodeMap;\n  const nodeMap = editorState._nodeMap; // Store dirtyElements in a queue for later deletion; deleting dirty subtrees too early will\n  // hinder accessing .__next on child nodes\n\n  const nodeMapDelete = [];\n\n  for (const [nodeKey] of dirtyElements) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined) {\n      // Garbage collect node and its children if they exist\n      if (!node.isAttached()) {\n        if ($isElementNode(node)) {\n          $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);\n        } // If we have created a node and it was dereferenced, then also\n        // remove it from out dirty nodes Set.\n\n\n        if (!prevNodeMap.has(nodeKey)) {\n          dirtyElements.delete(nodeKey);\n        }\n\n        nodeMapDelete.push(nodeKey);\n      }\n    }\n  }\n\n  for (const nodeKey of nodeMapDelete) {\n    nodeMap.delete(nodeKey);\n  }\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node !== undefined && !node.isAttached()) {\n      if (!prevNodeMap.has(nodeKey)) {\n        dirtyLeaves.delete(nodeKey);\n      }\n\n      nodeMap.delete(nodeKey);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet subTreeTextContent = '';\nlet subTreeDirectionedTextContent = '';\nlet editorTextContent = '';\nlet activeEditorConfig;\nlet activeEditor$1;\nlet activeEditorNodes;\nlet treatAllNodesAsDirty = false;\nlet activeEditorStateReadOnly = false;\nlet activeMutationListeners;\nlet activeTextDirection = null;\nlet activeDirtyElements;\nlet activeDirtyLeaves;\nlet activePrevNodeMap;\nlet activeNextNodeMap;\nlet activePrevKeyToDOMMap;\nlet mutatedNodes;\n\nfunction destroyNode(key, parentDOM) {\n  const node = activePrevNodeMap.get(key);\n\n  if (parentDOM !== null) {\n    const dom = getPrevElementByKeyOrThrow(key);\n\n    if (dom.parentNode === parentDOM) {\n      parentDOM.removeChild(dom);\n    }\n  } // This logic is really important, otherwise we will leak DOM nodes\n  // when their corresponding LexicalNodes are removed from the editor state.\n\n\n  if (!activeNextNodeMap.has(key)) {\n    activeEditor$1._keyToDOMMap.delete(key);\n  }\n\n  if ($isElementNode(node)) {\n    const children = createChildrenArray(node, activePrevNodeMap);\n    destroyChildren(children, 0, children.length - 1, null);\n  }\n\n  if (node !== undefined) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'destroyed');\n  }\n}\n\nfunction destroyChildren(children, _startIndex, endIndex, dom) {\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    const child = children[startIndex];\n\n    if (child !== undefined) {\n      destroyNode(child, dom);\n    }\n  }\n}\n\nfunction setTextAlign(domStyle, value) {\n  domStyle.setProperty('text-align', value);\n}\n\nconst DEFAULT_INDENT_VALUE = '40px';\n\nfunction setElementIndent(dom, indent) {\n  const indentClassName = activeEditorConfig.theme.indent;\n\n  if (typeof indentClassName === 'string') {\n    const elementHasClassName = dom.classList.contains(indentClassName);\n\n    if (indent > 0 && !elementHasClassName) {\n      dom.classList.add(indentClassName);\n    } else if (indent < 1 && elementHasClassName) {\n      dom.classList.remove(indentClassName);\n    }\n  }\n\n  const indentationBaseValue = getComputedStyle(dom).getPropertyValue('--lexical-indent-base-value') || DEFAULT_INDENT_VALUE;\n  dom.style.setProperty('padding-inline-start', indent === 0 ? '' : `calc(${indent} * ${indentationBaseValue})`);\n}\n\nfunction setElementFormat(dom, format) {\n  const domStyle = dom.style;\n\n  if (format === 0) {\n    setTextAlign(domStyle, '');\n  } else if (format === IS_ALIGN_LEFT) {\n    setTextAlign(domStyle, 'left');\n  } else if (format === IS_ALIGN_CENTER) {\n    setTextAlign(domStyle, 'center');\n  } else if (format === IS_ALIGN_RIGHT) {\n    setTextAlign(domStyle, 'right');\n  } else if (format === IS_ALIGN_JUSTIFY) {\n    setTextAlign(domStyle, 'justify');\n  } else if (format === IS_ALIGN_START) {\n    setTextAlign(domStyle, 'start');\n  } else if (format === IS_ALIGN_END) {\n    setTextAlign(domStyle, 'end');\n  }\n}\n\nfunction createNode(key, parentDOM, insertDOM) {\n  const node = activeNextNodeMap.get(key);\n\n  if (node === undefined) {\n    {\n      throw Error(`createNode: node does not exist in nodeMap`);\n    }\n  }\n\n  const dom = node.createDOM(activeEditorConfig, activeEditor$1);\n  storeDOMWithKey(key, dom, activeEditor$1); // This helps preserve the text, and stops spell check tools from\n  // merging or break the spans (which happens if they are missing\n  // this attribute).\n\n  if ($isTextNode(node)) {\n    dom.setAttribute('data-lexical-text', 'true');\n  } else if ($isDecoratorNode(node)) {\n    dom.setAttribute('data-lexical-decorator', 'true');\n  }\n\n  if ($isElementNode(node)) {\n    const indent = node.__indent;\n    const childrenSize = node.__size;\n\n    if (indent !== 0) {\n      setElementIndent(dom, indent);\n    }\n\n    if (childrenSize !== 0) {\n      const endIndex = childrenSize - 1;\n      const children = createChildrenArray(node, activeNextNodeMap);\n      createChildrenWithDirection(children, endIndex, node, dom);\n    }\n\n    const format = node.__format;\n\n    if (format !== 0) {\n      setElementFormat(dom, format);\n    }\n\n    if (!node.isInline()) {\n      reconcileElementTerminatingLineBreak(null, node, dom);\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(node)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = node.getTextContent();\n\n    if ($isDecoratorNode(node)) {\n      const decorator = node.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      } // Decorators are always non editable\n\n\n      dom.contentEditable = 'false';\n    } else if ($isTextNode(node)) {\n      if (!node.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (parentDOM !== null) {\n    if (insertDOM != null) {\n      parentDOM.insertBefore(dom, insertDOM);\n    } else {\n      // @ts-expect-error: internal field\n      const possibleLineBreak = parentDOM.__lexicalLineBreak;\n\n      if (possibleLineBreak != null) {\n        parentDOM.insertBefore(dom, possibleLineBreak);\n      } else {\n        parentDOM.appendChild(dom);\n      }\n    }\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(node);\n  }\n\n  setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, 'created');\n  return dom;\n}\n\nfunction createChildrenWithDirection(children, endIndex, element, dom) {\n  const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  createChildren(children, element, 0, endIndex, dom, null);\n  reconcileBlockDirection(element, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;\n}\n\nfunction createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  subTreeTextContent = '';\n  let startIndex = _startIndex;\n\n  for (; startIndex <= endIndex; ++startIndex) {\n    createNode(children[startIndex], dom, insertDOM);\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(element)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction isLastChildLineBreakOrDecorator(childKey, nodeMap) {\n  const node = nodeMap.get(childKey);\n  return $isLineBreakNode(node) || $isDecoratorNode(node) && node.isInline();\n} // If we end an element with a LineBreakNode, then we need to add an additional <br>\n\n\nfunction reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {\n  const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));\n  const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);\n\n  if (prevLineBreak) {\n    if (!nextLineBreak) {\n      // @ts-expect-error: internal field\n      const element = dom.__lexicalLineBreak;\n\n      if (element != null) {\n        dom.removeChild(element);\n      } // @ts-expect-error: internal field\n\n\n      dom.__lexicalLineBreak = null;\n    }\n  } else if (nextLineBreak) {\n    const element = document.createElement('br'); // @ts-expect-error: internal field\n\n    dom.__lexicalLineBreak = element;\n    dom.appendChild(element);\n  }\n}\n\nfunction reconcileBlockDirection(element, dom) {\n  const previousSubTreeDirectionTextContent = // @ts-expect-error: internal field\n  dom.__lexicalDirTextContent; // @ts-expect-error: internal field\n\n  const previousDirection = dom.__lexicalDir;\n\n  if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {\n    const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === '';\n    const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);\n\n    if (direction !== previousDirection) {\n      const classList = dom.classList;\n      const theme = activeEditorConfig.theme;\n      let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : undefined;\n      let nextDirectionTheme = direction !== null ? theme[direction] : undefined; // Remove the old theme classes if they exist\n\n      if (previousDirectionTheme !== undefined) {\n        if (typeof previousDirectionTheme === 'string') {\n          const classNamesArr = previousDirectionTheme.split(' ');\n          previousDirectionTheme = theme[previousDirection] = classNamesArr;\n        } // @ts-ignore: intentional\n\n\n        classList.remove(...previousDirectionTheme);\n      }\n\n      if (direction === null || hasEmptyDirectionedTextContent && direction === 'ltr') {\n        // Remove direction\n        dom.removeAttribute('dir');\n      } else {\n        // Apply the new theme classes if they exist\n        if (nextDirectionTheme !== undefined) {\n          if (typeof nextDirectionTheme === 'string') {\n            const classNamesArr = nextDirectionTheme.split(' '); // @ts-expect-error: intentional\n\n            nextDirectionTheme = theme[direction] = classNamesArr;\n          }\n\n          if (nextDirectionTheme !== undefined) {\n            classList.add(...nextDirectionTheme);\n          }\n        } // Update direction\n\n\n        dom.dir = direction;\n      }\n\n      if (!activeEditorStateReadOnly) {\n        const writableNode = element.getWritable();\n        writableNode.__dir = direction;\n      }\n    }\n\n    activeTextDirection = direction; // @ts-expect-error: internal field\n\n    dom.__lexicalDirTextContent = subTreeDirectionedTextContent; // @ts-expect-error: internal field\n\n    dom.__lexicalDir = direction;\n  }\n}\n\nfunction reconcileChildrenWithDirection(prevElement, nextElement, dom) {\n  const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;\n  subTreeDirectionedTextContent = '';\n  reconcileChildren(prevElement, nextElement, dom);\n  reconcileBlockDirection(nextElement, dom);\n  subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;\n}\n\nfunction createChildrenArray(element, nodeMap) {\n  const children = [];\n  let nodeKey = element.__first;\n\n  while (nodeKey !== null) {\n    const node = nodeMap.get(nodeKey);\n\n    if (node === undefined) {\n      {\n        throw Error(`createChildrenArray: node does not exist in nodeMap`);\n      }\n    }\n\n    children.push(nodeKey);\n    nodeKey = node.__next;\n  }\n\n  return children;\n}\n\nfunction reconcileChildren(prevElement, nextElement, dom) {\n  const previousSubTreeTextContent = subTreeTextContent;\n  const prevChildrenSize = prevElement.__size;\n  const nextChildrenSize = nextElement.__size;\n  subTreeTextContent = '';\n\n  if (prevChildrenSize === 1 && nextChildrenSize === 1) {\n    const prevFirstChildKey = prevElement.__first;\n    const nextFrstChildKey = nextElement.__first;\n\n    if (prevFirstChildKey === nextFrstChildKey) {\n      reconcileNode(prevFirstChildKey, dom);\n    } else {\n      const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);\n      const replacementDOM = createNode(nextFrstChildKey, null, null);\n      dom.replaceChild(replacementDOM, lastDOM);\n      destroyNode(prevFirstChildKey, null);\n    }\n  } else {\n    const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);\n    const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);\n\n    if (prevChildrenSize === 0) {\n      if (nextChildrenSize !== 0) {\n        createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);\n      }\n    } else if (nextChildrenSize === 0) {\n      if (prevChildrenSize !== 0) {\n        // @ts-expect-error: internal field\n        const lexicalLineBreak = dom.__lexicalLineBreak;\n        const canUseFastPath = lexicalLineBreak == null;\n        destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);\n\n        if (canUseFastPath) {\n          // Fast path for removing DOM nodes\n          dom.textContent = '';\n        }\n      }\n    } else {\n      reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);\n    }\n  }\n\n  if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {\n    subTreeTextContent += DOUBLE_LINE_BREAK;\n  } // @ts-expect-error: internal field\n\n\n  dom.__lexicalTextContent = subTreeTextContent;\n  subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;\n}\n\nfunction reconcileNode(key, parentDOM) {\n  const prevNode = activePrevNodeMap.get(key);\n  let nextNode = activeNextNodeMap.get(key);\n\n  if (prevNode === undefined || nextNode === undefined) {\n    {\n      throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);\n    }\n  }\n\n  const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);\n  const dom = getElementByKeyOrThrow(activeEditor$1, key); // If the node key points to the same instance in both states\n  // and isn't dirty, we just update the text content cache\n  // and return the existing DOM Node.\n\n  if (prevNode === nextNode && !isDirty) {\n    if ($isElementNode(prevNode)) {\n      // @ts-expect-error: internal field\n      const previousSubTreeTextContent = dom.__lexicalTextContent;\n\n      if (previousSubTreeTextContent !== undefined) {\n        subTreeTextContent += previousSubTreeTextContent;\n        editorTextContent += previousSubTreeTextContent;\n      } // @ts-expect-error: internal field\n\n\n      const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;\n\n      if (previousSubTreeDirectionTextContent !== undefined) {\n        subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;\n      }\n    } else {\n      const text = prevNode.getTextContent();\n\n      if ($isTextNode(prevNode) && !prevNode.isDirectionless()) {\n        subTreeDirectionedTextContent += text;\n      }\n\n      editorTextContent += text;\n      subTreeTextContent += text;\n    }\n\n    return dom;\n  } // If the node key doesn't point to the same instance in both maps,\n  // it means it were cloned. If they're also dirty, we mark them as mutated.\n\n\n  if (prevNode !== nextNode && isDirty) {\n    setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, 'updated');\n  } // Update node. If it returns true, we need to unmount and re-create the node\n\n\n  if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {\n    const replacementDOM = createNode(key, null, null);\n\n    if (parentDOM === null) {\n      {\n        throw Error(`reconcileNode: parentDOM is null`);\n      }\n    }\n\n    parentDOM.replaceChild(replacementDOM, dom);\n    destroyNode(key, null);\n    return replacementDOM;\n  }\n\n  if ($isElementNode(prevNode) && $isElementNode(nextNode)) {\n    // Reconcile element children\n    const nextIndent = nextNode.__indent;\n\n    if (nextIndent !== prevNode.__indent) {\n      setElementIndent(dom, nextIndent);\n    }\n\n    const nextFormat = nextNode.__format;\n\n    if (nextFormat !== prevNode.__format) {\n      setElementFormat(dom, nextFormat);\n    }\n\n    if (isDirty) {\n      reconcileChildrenWithDirection(prevNode, nextNode, dom);\n\n      if (!$isRootNode(nextNode) && !nextNode.isInline()) {\n        reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);\n      }\n    }\n\n    if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {\n      subTreeTextContent += DOUBLE_LINE_BREAK;\n      editorTextContent += DOUBLE_LINE_BREAK;\n    }\n  } else {\n    const text = nextNode.getTextContent();\n\n    if ($isDecoratorNode(nextNode)) {\n      const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);\n\n      if (decorator !== null) {\n        reconcileDecorator(key, decorator);\n      }\n    } else if ($isTextNode(nextNode) && !nextNode.isDirectionless()) {\n      // Handle text content, for LTR, LTR cases.\n      subTreeDirectionedTextContent += text;\n    }\n\n    subTreeTextContent += text;\n    editorTextContent += text;\n  }\n\n  if (!activeEditorStateReadOnly && $isRootNode(nextNode) && nextNode.__cachedText !== editorTextContent) {\n    // Cache the latest text content.\n    nextNode = nextNode.getWritable();\n    nextNode.__cachedText = editorTextContent;\n  }\n\n  {\n    // Freeze the node in DEV to prevent accidental mutations\n    Object.freeze(nextNode);\n  }\n\n  return dom;\n}\n\nfunction reconcileDecorator(key, decorator) {\n  let pendingDecorators = activeEditor$1._pendingDecorators;\n  const currentDecorators = activeEditor$1._decorators;\n\n  if (pendingDecorators === null) {\n    if (currentDecorators[key] === decorator) {\n      return;\n    }\n\n    pendingDecorators = cloneDecorators(activeEditor$1);\n  }\n\n  pendingDecorators[key] = decorator;\n}\n\nfunction getFirstChild(element) {\n  return element.firstChild;\n}\n\nfunction getNextSibling(element) {\n  let nextSibling = element.nextSibling;\n\n  if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {\n    nextSibling = nextSibling.nextSibling;\n  }\n\n  return nextSibling;\n}\n\nfunction reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {\n  const prevEndIndex = prevChildrenLength - 1;\n  const nextEndIndex = nextChildrenLength - 1;\n  let prevChildrenSet;\n  let nextChildrenSet;\n  let siblingDOM = getFirstChild(dom);\n  let prevIndex = 0;\n  let nextIndex = 0;\n\n  while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {\n    const prevKey = prevChildren[prevIndex];\n    const nextKey = nextChildren[nextIndex];\n\n    if (prevKey === nextKey) {\n      siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n      prevIndex++;\n      nextIndex++;\n    } else {\n      if (prevChildrenSet === undefined) {\n        prevChildrenSet = new Set(prevChildren);\n      }\n\n      if (nextChildrenSet === undefined) {\n        nextChildrenSet = new Set(nextChildren);\n      }\n\n      const nextHasPrevKey = nextChildrenSet.has(prevKey);\n      const prevHasNextKey = prevChildrenSet.has(nextKey);\n\n      if (!nextHasPrevKey) {\n        // Remove prev\n        siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));\n        destroyNode(prevKey, dom);\n        prevIndex++;\n      } else if (!prevHasNextKey) {\n        // Create next\n        createNode(nextKey, dom, siblingDOM);\n        nextIndex++;\n      } else {\n        // Move next\n        const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);\n\n        if (childDOM === siblingDOM) {\n          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));\n        } else {\n          if (siblingDOM != null) {\n            dom.insertBefore(childDOM, siblingDOM);\n          } else {\n            dom.appendChild(childDOM);\n          }\n\n          reconcileNode(nextKey, dom);\n        }\n\n        prevIndex++;\n        nextIndex++;\n      }\n    }\n  }\n\n  const appendNewChildren = prevIndex > prevEndIndex;\n  const removeOldChildren = nextIndex > nextEndIndex;\n\n  if (appendNewChildren && !removeOldChildren) {\n    const previousNode = nextChildren[nextEndIndex + 1];\n    const insertDOM = previousNode === undefined ? null : activeEditor$1.getElementByKey(previousNode);\n    createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);\n  } else if (removeOldChildren && !appendNewChildren) {\n    destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);\n  }\n}\n\nfunction reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {\n  // We cache text content to make retrieval more efficient.\n  // The cache must be rebuilt during reconciliation to account for any changes.\n  subTreeTextContent = '';\n  editorTextContent = '';\n  subTreeDirectionedTextContent = ''; // Rather than pass around a load of arguments through the stack recursively\n  // we instead set them as bindings within the scope of the module.\n\n  treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;\n  activeTextDirection = null;\n  activeEditor$1 = editor;\n  activeEditorConfig = editor._config;\n  activeEditorNodes = editor._nodes;\n  activeMutationListeners = activeEditor$1._listeners.mutation;\n  activeDirtyElements = dirtyElements;\n  activeDirtyLeaves = dirtyLeaves;\n  activePrevNodeMap = prevEditorState._nodeMap;\n  activeNextNodeMap = nextEditorState._nodeMap;\n  activeEditorStateReadOnly = nextEditorState._readOnly;\n  activePrevKeyToDOMMap = new Map(editor._keyToDOMMap); // We keep track of mutated nodes so we can trigger mutation\n  // listeners later in the update cycle.\n\n  const currentMutatedNodes = new Map();\n  mutatedNodes = currentMutatedNodes;\n  reconcileNode('root', null); // We don't want a bunch of void checks throughout the scope\n  // so instead we make it seem that these values are always set.\n  // We also want to make sure we clear them down, otherwise we\n  // can leak memory.\n  // @ts-ignore\n\n  activeEditor$1 = undefined; // @ts-ignore\n\n  activeEditorNodes = undefined; // @ts-ignore\n\n  activeDirtyElements = undefined; // @ts-ignore\n\n  activeDirtyLeaves = undefined; // @ts-ignore\n\n  activePrevNodeMap = undefined; // @ts-ignore\n\n  activeNextNodeMap = undefined; // @ts-ignore\n\n  activeEditorConfig = undefined; // @ts-ignore\n\n  activePrevKeyToDOMMap = undefined; // @ts-ignore\n\n  mutatedNodes = undefined;\n  return currentMutatedNodes;\n}\nfunction storeDOMWithKey(key, dom, editor) {\n  const keyToDOMMap = editor._keyToDOMMap; // @ts-ignore We intentionally add this to the Node.\n\n  dom['__lexicalKey_' + editor._key] = key;\n  keyToDOMMap.set(key, dom);\n}\n\nfunction getPrevElementByKeyOrThrow(key) {\n  const element = activePrevKeyToDOMMap.get(key);\n\n  if (element === undefined) {\n    {\n      throw Error(`Reconciliation: could not find DOM element for node key ${key}`);\n    }\n  }\n\n  return element;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst PASS_THROUGH_COMMAND = Object.freeze({});\nconst ANDROID_COMPOSITION_LATENCY = 30;\nconst rootElementEvents = [['keydown', onKeyDown], ['pointerdown', onPointerDown], ['compositionstart', onCompositionStart], ['compositionend', onCompositionEnd], ['input', onInput], ['click', onClick], ['cut', PASS_THROUGH_COMMAND], ['copy', PASS_THROUGH_COMMAND], ['dragstart', PASS_THROUGH_COMMAND], ['dragover', PASS_THROUGH_COMMAND], ['dragend', PASS_THROUGH_COMMAND], ['paste', PASS_THROUGH_COMMAND], ['focus', PASS_THROUGH_COMMAND], ['blur', PASS_THROUGH_COMMAND], ['drop', PASS_THROUGH_COMMAND]];\n\nif (CAN_USE_BEFORE_INPUT) {\n  rootElementEvents.push(['beforeinput', (event, editor) => onBeforeInput(event, editor)]);\n}\n\nlet lastKeyDownTimeStamp = 0;\nlet lastKeyCode = 0;\nlet lastBeforeInputInsertTextTimeStamp = 0;\nlet unprocessedBeforeInputData = null;\nlet rootElementsRegistered = 0;\nlet isSelectionChangeFromDOMUpdate = false;\nlet isSelectionChangeFromMouseDown = false;\nlet isInsertLineBreak = false;\nlet isFirefoxEndingComposition = false;\nlet collapsedSelectionFormat = [0, '', 0, 'root', 0]; // This function is used to determine if Lexical should attempt to override\n// the default browser behavior for insertion of text and use its own internal\n// heuristics. This is an extremely important function, and makes much of Lexical\n// work as intended between different browsers and across word, line and character\n// boundary/formats. It also is important for text replacement, node schemas and\n// composition mechanics.\n\nfunction $shouldPreventDefaultAndInsertText(selection, domTargetRange, text, timeStamp, isBeforeInput) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const editor = getActiveEditor();\n  const domSelection = getDOMSelection(editor._window);\n  const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;\n  const anchorKey = anchor.key;\n  const backingAnchorElement = editor.getElementByKey(anchorKey);\n  const textLength = text.length;\n  return anchorKey !== focus.key || // If we're working with a non-text node.\n  !$isTextNode(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.\n  (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been\n  // a recent beforeinput event for \"textInput\". If there has been one in the last\n  // 50ms then we proceed as normal. However, if there is not, then this is likely\n  // a dangling `input` event caused by execCommand('insertText').\n  lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.\n  $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either\n  // dealing with this in \"beforeinput\" or where the node has already recently\n  // been changed (thus is dirty).\n  anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.\n  (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts\n  // of the editor.\n  domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.\n  anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.\n  $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);\n}\n\nfunction shouldSkipSelectionChange(domNode, offset) {\n  return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;\n}\n\nfunction onSelectionChange(domSelection, editor, isActive) {\n  const {\n    anchorNode: anchorDOM,\n    anchorOffset,\n    focusNode: focusDOM,\n    focusOffset\n  } = domSelection;\n\n  if (isSelectionChangeFromDOMUpdate) {\n    isSelectionChangeFromDOMUpdate = false; // If native DOM selection is on a DOM element, then\n    // we should continue as usual, as Lexical's selection\n    // may have normalized to a better child. If the DOM\n    // element is a text node, we can safely apply this\n    // optimization and skip the selection change entirely.\n    // We also need to check if the offset is at the boundary,\n    // because in this case, we might need to normalize to a\n    // sibling instead.\n\n    if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {\n      return;\n    }\n  }\n\n  updateEditor(editor, () => {\n    // Non-active editor don't need any extra logic for selection, it only needs update\n    // to reconcile selection (set it to null) to ensure that only one editor has non-null selection.\n    if (!isActive) {\n      $setSelection(null);\n      return;\n    }\n\n    if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return;\n    }\n\n    const selection = $getSelection(); // Update the selection format\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n\n      if (selection.isCollapsed()) {\n        // Badly interpreted range selection when collapsed - #1482\n        if (domSelection.type === 'Range' && domSelection.anchorNode === domSelection.focusNode) {\n          selection.dirty = true;\n        } // If we have marked a collapsed selection format, and we're\n        // within the given time range – then attempt to use that format\n        // instead of getting the format from the anchor node.\n\n\n        const windowEvent = getWindow(editor).event;\n        const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();\n        const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;\n\n        if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {\n          selection.format = lastFormat;\n          selection.style = lastStyle;\n        } else {\n          if (anchor.type === 'text') {\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          } else if (anchor.type === 'element') {\n            selection.format = 0;\n            selection.style = '';\n          }\n        }\n      } else {\n        let combinedFormat = IS_ALL_FORMATTING;\n        let hasTextNodes = false;\n        const nodes = selection.getNodes();\n        const nodesLength = nodes.length;\n\n        for (let i = 0; i < nodesLength; i++) {\n          const node = nodes[i];\n\n          if ($isTextNode(node)) {\n            // TODO: what about style?\n            hasTextNodes = true;\n            combinedFormat &= node.getFormat();\n\n            if (combinedFormat === 0) {\n              break;\n            }\n          }\n        }\n\n        selection.format = hasTextNodes ? combinedFormat : 0;\n      }\n    }\n\n    dispatchCommand(editor, SELECTION_CHANGE_COMMAND, undefined);\n  });\n} // This is a work-around is mainly Chrome specific bug where if you select\n// the contents of an empty block, you cannot easily unselect anything.\n// This results in a tiny selection box that looks buggy/broken. This can\n// also help other browsers when selection might \"appear\" lost, when it\n// really isn't.\n\n\nfunction onClick(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const domSelection = getDOMSelection(editor._window);\n    const lastSelection = $getPreviousSelection();\n\n    if (domSelection) {\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const anchorNode = anchor.getNode();\n\n        if (anchor.type === 'element' && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode(anchorNode) && $getRoot().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {\n          domSelection.removeAllRanges();\n          selection.dirty = true;\n        } else if (event.detail === 3 && !selection.isCollapsed()) {\n          // Tripple click causing selection to overflow into the nearest element. In that\n          // case visually it looks like a single element content is selected, focus node\n          // is actually at the beginning of the next element (if present) and any manipulations\n          // with selection (formatting) are affecting second element as well\n          const focus = selection.focus;\n          const focusNode = focus.getNode();\n\n          if (anchorNode !== focusNode) {\n            if ($isElementNode(anchorNode)) {\n              anchorNode.select(0);\n            } else {\n              anchorNode.getParentOrThrow().select(0);\n            }\n          }\n        }\n      } else if (event.pointerType === 'touch') {\n        // This is used to update the selection on touch devices when the user clicks on text after a\n        // node selection. See isSelectionChangeFromMouseDown for the inverse\n        const domAnchorNode = domSelection.anchorNode;\n\n        if (domAnchorNode !== null) {\n          const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n          // we should attempt create a range selection.\n          // When we click on an empty paragraph node or the end of a paragraph that ends\n          // with an image/poll, the nodeType will be ELEMENT_NODE\n\n          if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {\n            const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor);\n            $setSelection(newSelection);\n          }\n        }\n      }\n    }\n\n    dispatchCommand(editor, CLICK_COMMAND, event);\n  });\n}\n\nfunction onPointerDown(event, editor) {\n  // TODO implement text drag & drop\n  const target = event.target;\n  const pointerType = event.pointerType;\n\n  if (target instanceof Node && pointerType !== 'touch') {\n    updateEditor(editor, () => {\n      // Drag & drop should not recompute selection until mouse up; otherwise the initially\n      // selected content is lost.\n      if (!$isSelectionCapturedInDecorator(target)) {\n        isSelectionChangeFromMouseDown = true;\n      }\n    });\n  }\n}\n\nfunction getTargetRange(event) {\n  if (!event.getTargetRanges) {\n    return null;\n  }\n\n  const targetRanges = event.getTargetRanges();\n\n  if (targetRanges.length === 0) {\n    return null;\n  }\n\n  return targetRanges[0];\n}\n\nfunction $canRemoveText(anchorNode, focusNode) {\n  return anchorNode !== focusNode || $isElementNode(anchorNode) || $isElementNode(focusNode) || !anchorNode.isToken() || !focusNode.isToken();\n}\n\nfunction isPossiblyAndroidKeyPress(timeStamp) {\n  return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;\n}\n\nfunction onBeforeInput(event, editor) {\n  const inputType = event.inputType;\n  const targetRange = getTargetRange(event); // We let the browser do its own thing for composition.\n\n  if (inputType === 'deleteCompositionText' || // If we're pasting in FF, we shouldn't get this event\n  // as the `paste` event should have triggered, unless the\n  // user has dom.event.clipboardevents.enabled disabled in\n  // about:config. In that case, we need to process the\n  // pasted content in the DOM mutation phase.\n  IS_FIREFOX && isFirefoxClipboardEvents(editor)) {\n    return;\n  } else if (inputType === 'insertCompositionText') {\n    return;\n  }\n\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if (inputType === 'deleteContentBackward') {\n      if (selection === null) {\n        // Use previous selection\n        const prevSelection = $getPreviousSelection();\n\n        if (!$isRangeSelection(prevSelection)) {\n          return;\n        }\n\n        $setSelection(prevSelection.clone());\n      }\n\n      if ($isRangeSelection(selection)) {\n        // Used for handling backspace in Android.\n        if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {\n          $setCompositionKey(null);\n          lastKeyDownTimeStamp = 0; // Fixes an Android bug where selection flickers when backspacing\n\n          setTimeout(() => {\n            updateEditor(editor, () => {\n              $setCompositionKey(null);\n            });\n          }, ANDROID_COMPOSITION_LATENCY);\n\n          if ($isRangeSelection(selection)) {\n            const anchorNode = selection.anchor.getNode();\n            anchorNode.markDirty();\n            selection.format = anchorNode.getFormat();\n            selection.style = anchorNode.getStyle();\n          }\n        } else {\n          event.preventDefault();\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n        }\n\n        return;\n      }\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return;\n    }\n\n    const data = event.data; // This represents the case when two beforeinput events are triggered at the same time (without a\n    // full event loop ending at input). This happens with MacOS with the default keyboard settings,\n    // a combination of autocorrection + autocapitalization.\n    // Having Lexical run everything in controlled mode would fix the issue without additional code\n    // but this would kill the massive performance win from the most common typing event.\n    // Alternatively, when this happens we can prematurely update our EditorState based on the DOM\n    // content, a job that would usually be the input event's responsibility.\n\n    if (unprocessedBeforeInputData !== null) {\n      $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);\n    }\n\n    if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode(selection.anchor.getNode()) && targetRange !== null) {\n      selection.applyDOMRange(targetRange);\n    }\n\n    unprocessedBeforeInputData = null;\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n    const anchorNode = anchor.getNode();\n    const focusNode = focus.getNode();\n\n    if (inputType === 'insertText' || inputType === 'insertTranspose') {\n      if (data === '\\n') {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n      } else if (data === DOUBLE_LINE_BREAK) {\n        event.preventDefault();\n        dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n      } else if (data == null && event.dataTransfer) {\n        // Gets around a Safari text replacement bug.\n        const text = event.dataTransfer.getData('text/plain');\n        event.preventDefault();\n        selection.insertRawText(text);\n      } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {\n        event.preventDefault();\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      } else {\n        unprocessedBeforeInputData = data;\n      }\n\n      lastBeforeInputInsertTextTimeStamp = event.timeStamp;\n      return;\n    } // Prevent the browser from carrying out\n    // the input event, so we can control the\n    // output.\n\n\n    event.preventDefault();\n\n    switch (inputType) {\n      case 'insertFromYank':\n      case 'insertFromDrop':\n      case 'insertReplacementText':\n        {\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertFromComposition':\n        {\n          // This is the end of composition\n          $setCompositionKey(null);\n          dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);\n          break;\n        }\n\n      case 'insertLineBreak':\n        {\n          // Used for Android\n          $setCompositionKey(null);\n          dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          break;\n        }\n\n      case 'insertParagraph':\n        {\n          // Used for Android\n          $setCompositionKey(null); // Safari does not provide the type \"insertLineBreak\".\n          // So instead, we need to infer it from the keyboard event.\n          // We do not apply this logic to iOS to allow newline auto-capitalization\n          // work without creating linebreaks when pressing Enter\n\n          if (isInsertLineBreak && !IS_IOS) {\n            isInsertLineBreak = false;\n            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);\n          } else {\n            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, undefined);\n          }\n\n          break;\n        }\n\n      case 'insertFromPaste':\n      case 'insertFromPasteAsQuotation':\n        {\n          dispatchCommand(editor, PASTE_COMMAND, event);\n          break;\n        }\n\n      case 'deleteByComposition':\n        {\n          if ($canRemoveText(anchorNode, focusNode)) {\n            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          }\n\n          break;\n        }\n\n      case 'deleteByDrag':\n      case 'deleteByCut':\n        {\n          dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);\n          break;\n        }\n\n      case 'deleteContent':\n        {\n          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n          break;\n        }\n\n      case 'deleteHardLineBackward':\n      case 'deleteSoftLineBackward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n          break;\n        }\n\n      case 'deleteContentForward':\n      case 'deleteHardLineForward':\n      case 'deleteSoftLineForward':\n        {\n          dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n          break;\n        }\n\n      case 'formatStrikeThrough':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'strikethrough');\n          break;\n        }\n\n      case 'formatBold':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n          break;\n        }\n\n      case 'formatItalic':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n          break;\n        }\n\n      case 'formatUnderline':\n        {\n          dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n          break;\n        }\n\n      case 'historyUndo':\n        {\n          dispatchCommand(editor, UNDO_COMMAND, undefined);\n          break;\n        }\n\n      case 'historyRedo':\n        {\n          dispatchCommand(editor, REDO_COMMAND, undefined);\n          break;\n        }\n\n    }\n  });\n}\n\nfunction onInput(event, editor) {\n  // We don't want the onInput to bubble, in the case of nested editors.\n  event.stopPropagation();\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n    const data = event.data;\n    const targetRange = getTargetRange(event);\n\n    if (data != null && $isRangeSelection(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {\n      // Given we're over-riding the default behavior, we will need\n      // to ensure to disable composition before dispatching the\n      // insertText command for when changing the sequence for FF.\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data);\n        isFirefoxEndingComposition = false;\n      }\n\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const domSelection = getDOMSelection(editor._window);\n\n      if (domSelection === null) {\n        return;\n      }\n\n      const offset = anchor.offset; // If the content is the same as inserted, then don't dispatch an insertion.\n      // Given onInput doesn't take the current selection (it uses the previous)\n      // we can compare that against what the DOM currently says.\n\n      if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);\n      }\n\n      const textLength = data.length; // Another hack for FF, as it's possible that the IME is still\n      // open, even though compositionend has already fired (sigh).\n\n      if (IS_FIREFOX && textLength > 1 && event.inputType === 'insertCompositionText' && !editor.isComposing()) {\n        selection.anchor.offset -= textLength;\n      } // This ensures consistency on Android.\n\n\n      if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {\n        lastKeyDownTimeStamp = 0;\n        $setCompositionKey(null);\n      }\n    } else {\n      const characterData = data !== null ? data : undefined;\n      $updateSelectedTextFromDOM(false, editor, characterData); // onInput always fires after onCompositionEnd for FF.\n\n      if (isFirefoxEndingComposition) {\n        onCompositionEndImpl(editor, data || undefined);\n        isFirefoxEndingComposition = false;\n      }\n    } // Also flush any other mutations that might have occurred\n    // since the change.\n\n\n    $flushMutations();\n  });\n  unprocessedBeforeInputData = null;\n}\n\nfunction onCompositionStart(event, editor) {\n  updateEditor(editor, () => {\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection) && !editor.isComposing()) {\n      const anchor = selection.anchor;\n      const node = selection.anchor.getNode();\n      $setCompositionKey(anchor.key);\n\n      if ( // If it has been 30ms since the last keydown, then we should\n      // apply the empty space heuristic. We can't do this for Safari,\n      // as the keydown fires after composition start.\n      event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also\n      // need to invoke the empty space heuristic below.\n      anchor.type === 'element' || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style) {\n        // We insert a zero width character, ready for the composition\n        // to get inserted into the new node we create. If\n        // we don't do this, Safari will fail on us because\n        // there is no text node matching the selection.\n        dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);\n      }\n    }\n  });\n}\n\nfunction onCompositionEndImpl(editor, data) {\n  const compositionKey = editor._compositionKey;\n  $setCompositionKey(null); // Handle termination of composition.\n\n  if (compositionKey !== null && data != null) {\n    // Composition can sometimes move to an adjacent DOM node when backspacing.\n    // So check for the empty case.\n    if (data === '') {\n      const node = $getNodeByKey(compositionKey);\n      const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));\n\n      if (textNode !== null && textNode.nodeValue !== null && $isTextNode(node)) {\n        $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);\n      }\n\n      return;\n    } // Composition can sometimes be that of a new line. In which case, we need to\n    // handle that accordingly.\n\n\n    if (data[data.length - 1] === '\\n') {\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        // If the last character is a line break, we also need to insert\n        // a line break.\n        const focus = selection.focus;\n        selection.anchor.set(focus.key, focus.offset, focus.type);\n        dispatchCommand(editor, KEY_ENTER_COMMAND, null);\n        return;\n      }\n    }\n  }\n\n  $updateSelectedTextFromDOM(true, editor, data);\n}\n\nfunction onCompositionEnd(event, editor) {\n  // Firefox fires onCompositionEnd before onInput, but Chrome/Webkit,\n  // fire onInput before onCompositionEnd. To ensure the sequence works\n  // like Chrome/Webkit we use the isFirefoxEndingComposition flag to\n  // defer handling of onCompositionEnd in Firefox till we have processed\n  // the logic in onInput.\n  if (IS_FIREFOX) {\n    isFirefoxEndingComposition = true;\n  } else {\n    updateEditor(editor, () => {\n      onCompositionEndImpl(editor, event.data);\n    });\n  }\n}\n\nfunction onKeyDown(event, editor) {\n  lastKeyDownTimeStamp = event.timeStamp;\n  lastKeyCode = event.keyCode;\n\n  if (editor.isComposing()) {\n    return;\n  }\n\n  const {\n    keyCode,\n    shiftKey,\n    ctrlKey,\n    metaKey,\n    altKey\n  } = event;\n\n  if (dispatchCommand(editor, KEY_DOWN_COMMAND, event)) {\n    return;\n  }\n\n  if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);\n  } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_END, event);\n  } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);\n  } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, MOVE_TO_START, event);\n  } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);\n  } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);\n  } else if (isLineBreak(keyCode, shiftKey)) {\n    isInsertLineBreak = true;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isSpace(keyCode)) {\n    dispatchCommand(editor, KEY_SPACE_COMMAND, event);\n  } else if (isOpenLineBreak(keyCode, ctrlKey)) {\n    event.preventDefault();\n    isInsertLineBreak = true;\n    dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);\n  } else if (isParagraph(keyCode, shiftKey)) {\n    isInsertLineBreak = false;\n    dispatchCommand(editor, KEY_ENTER_COMMAND, event);\n  } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {\n    if (isBackspace(keyCode)) {\n      dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);\n    }\n  } else if (isEscape(keyCode)) {\n    dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);\n  } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {\n    if (isDelete(keyCode)) {\n      dispatchCommand(editor, KEY_DELETE_COMMAND, event);\n    } else {\n      event.preventDefault();\n      dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);\n    }\n  } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, true);\n  } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_WORD_COMMAND, false);\n  } else if (isDeleteLineBackward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, true);\n  } else if (isDeleteLineForward(keyCode, metaKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, DELETE_LINE_COMMAND, false);\n  } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'bold');\n  } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'underline');\n  } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, FORMAT_TEXT_COMMAND, 'italic');\n  } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {\n    dispatchCommand(editor, KEY_TAB_COMMAND, event);\n  } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, UNDO_COMMAND, undefined);\n  } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {\n    event.preventDefault();\n    dispatchCommand(editor, REDO_COMMAND, undefined);\n  } else {\n    const prevSelection = editor._editorState._selection;\n\n    if ($isNodeSelection(prevSelection)) {\n      if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, COPY_COMMAND, event);\n      } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, CUT_COMMAND, event);\n      } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {\n        event.preventDefault();\n        dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n      } // FF does it well (no need to override behavior)\n\n    } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {\n      event.preventDefault();\n      dispatchCommand(editor, SELECT_ALL_COMMAND, event);\n    }\n  }\n\n  if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {\n    dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);\n  }\n}\n\nfunction getRootElementRemoveHandles(rootElement) {\n  // @ts-expect-error: internal field\n  let eventHandles = rootElement.__lexicalEventHandles;\n\n  if (eventHandles === undefined) {\n    eventHandles = []; // @ts-expect-error: internal field\n\n    rootElement.__lexicalEventHandles = eventHandles;\n  }\n\n  return eventHandles;\n} // Mapping root editors to their active nested editors, contains nested editors\n// mapping only, so if root editor is selected map will have no reference to free up memory\n\n\nconst activeNestedEditorsMap = new Map();\n\nfunction onDocumentSelectionChange(event) {\n  const target = event.target;\n  const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;\n  const domSelection = getDOMSelection(targetWindow);\n\n  if (domSelection === null) {\n    return;\n  }\n\n  const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);\n\n  if (nextActiveEditor === null) {\n    return;\n  }\n\n  if (isSelectionChangeFromMouseDown) {\n    isSelectionChangeFromMouseDown = false;\n    updateEditor(nextActiveEditor, () => {\n      const lastSelection = $getPreviousSelection();\n      const domAnchorNode = domSelection.anchorNode;\n\n      if (domAnchorNode === null) {\n        return;\n      }\n\n      const nodeType = domAnchorNode.nodeType; // If the user is attempting to click selection back onto text, then\n      // we should attempt create a range selection.\n      // When we click on an empty paragraph node or the end of a paragraph that ends\n      // with an image/poll, the nodeType will be ELEMENT_NODE\n\n      if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {\n        return;\n      }\n\n      const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);\n      $setSelection(newSelection);\n    });\n  } // When editor receives selection change event, we're checking if\n  // it has any sibling editors (within same parent editor) that were active\n  // before, and trigger selection change on it to nullify selection.\n\n\n  const editors = getEditorsToPropagate(nextActiveEditor);\n  const rootEditor = editors[editors.length - 1];\n  const rootEditorKey = rootEditor._key;\n  const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);\n  const prevActiveEditor = activeNestedEditor || rootEditor;\n\n  if (prevActiveEditor !== nextActiveEditor) {\n    onSelectionChange(domSelection, prevActiveEditor, false);\n  }\n\n  onSelectionChange(domSelection, nextActiveEditor, true); // If newly selected editor is nested, then add it to the map, clean map otherwise\n\n  if (nextActiveEditor !== rootEditor) {\n    activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);\n  } else if (activeNestedEditor) {\n    activeNestedEditorsMap.delete(rootEditorKey);\n  }\n}\n\nfunction stopLexicalPropagation(event) {\n  // We attach a special property to ensure the same event doesn't re-fire\n  // for parent editors.\n  // @ts-ignore\n  event._lexicalHandled = true;\n}\n\nfunction hasStoppedLexicalPropagation(event) {\n  // @ts-ignore\n  const stopped = event._lexicalHandled === true;\n  return stopped;\n}\n\nfunction addRootElementEvents(rootElement, editor) {\n  // We only want to have a single global selectionchange event handler, shared\n  // between all editor instances.\n  if (rootElementsRegistered === 0) {\n    const doc = rootElement.ownerDocument;\n    doc.addEventListener('selectionchange', onDocumentSelectionChange);\n  }\n\n  rootElementsRegistered++; // @ts-expect-error: internal field\n\n  rootElement.__lexicalEditor = editor;\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < rootElementEvents.length; i++) {\n    const [eventName, onEvent] = rootElementEvents[i];\n    const eventHandler = typeof onEvent === 'function' ? event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        onEvent(event, editor);\n      }\n    } : event => {\n      if (hasStoppedLexicalPropagation(event)) {\n        return;\n      }\n\n      stopLexicalPropagation(event);\n\n      if (editor.isEditable()) {\n        switch (eventName) {\n          case 'cut':\n            return dispatchCommand(editor, CUT_COMMAND, event);\n\n          case 'copy':\n            return dispatchCommand(editor, COPY_COMMAND, event);\n\n          case 'paste':\n            return dispatchCommand(editor, PASTE_COMMAND, event);\n\n          case 'dragstart':\n            return dispatchCommand(editor, DRAGSTART_COMMAND, event);\n\n          case 'dragover':\n            return dispatchCommand(editor, DRAGOVER_COMMAND, event);\n\n          case 'dragend':\n            return dispatchCommand(editor, DRAGEND_COMMAND, event);\n\n          case 'focus':\n            return dispatchCommand(editor, FOCUS_COMMAND, event);\n\n          case 'blur':\n            {\n              return dispatchCommand(editor, BLUR_COMMAND, event);\n            }\n\n          case 'drop':\n            return dispatchCommand(editor, DROP_COMMAND, event);\n        }\n      }\n    };\n    rootElement.addEventListener(eventName, eventHandler);\n    removeHandles.push(() => {\n      rootElement.removeEventListener(eventName, eventHandler);\n    });\n  }\n}\nfunction removeRootElementEvents(rootElement) {\n  if (rootElementsRegistered !== 0) {\n    rootElementsRegistered--; // We only want to have a single global selectionchange event handler, shared\n    // between all editor instances.\n\n    if (rootElementsRegistered === 0) {\n      const doc = rootElement.ownerDocument;\n      doc.removeEventListener('selectionchange', onDocumentSelectionChange);\n    }\n  } // @ts-expect-error: internal field\n\n\n  const editor = rootElement.__lexicalEditor;\n\n  if (editor !== null && editor !== undefined) {\n    cleanActiveNestedEditorsMap(editor); // @ts-expect-error: internal field\n\n    rootElement.__lexicalEditor = null;\n  }\n\n  const removeHandles = getRootElementRemoveHandles(rootElement);\n\n  for (let i = 0; i < removeHandles.length; i++) {\n    removeHandles[i]();\n  } // @ts-expect-error: internal field\n\n\n  rootElement.__lexicalEventHandles = [];\n}\n\nfunction cleanActiveNestedEditorsMap(editor) {\n  if (editor._parentEditor !== null) {\n    // For nested editor cleanup map if this editor was marked as active\n    const editors = getEditorsToPropagate(editor);\n    const rootEditor = editors[editors.length - 1];\n    const rootEditorKey = rootEditor._key;\n\n    if (activeNestedEditorsMap.get(rootEditorKey) === editor) {\n      activeNestedEditorsMap.delete(rootEditorKey);\n    }\n  } else {\n    // For top-level editors cleanup map\n    activeNestedEditorsMap.delete(editor._key);\n  }\n}\n\nfunction markSelectionChangeFromDOMUpdate() {\n  isSelectionChangeFromDOMUpdate = true;\n}\nfunction markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {\n  collapsedSelectionFormat = [format, style, offset, key, timeStamp];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {\n  errorOnReadOnly();\n  const key = nodeToRemove.__key;\n  const parent = nodeToRemove.getParent();\n\n  if (parent === null) {\n    return;\n  }\n\n  const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);\n  let selectionMoved = false;\n\n  if ($isRangeSelection(selection) && restoreSelection) {\n    const anchor = selection.anchor;\n    const focus = selection.focus;\n\n    if (anchor.key === key) {\n      moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n\n    if (focus.key === key) {\n      moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());\n      selectionMoved = true;\n    }\n  } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {\n    nodeToRemove.selectPrevious();\n  }\n\n  if ($isRangeSelection(selection) && restoreSelection && !selectionMoved) {\n    // Doing this is O(n) so lets avoid it unless we need to do it\n    const index = nodeToRemove.getIndexWithinParent();\n    removeFromParent(nodeToRemove);\n    $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);\n  } else {\n    removeFromParent(nodeToRemove);\n  }\n\n  if (!preserveEmptyParent && !$isRootOrShadowRoot(parent) && !parent.canBeEmpty() && parent.isEmpty()) {\n    removeNode(parent, restoreSelection);\n  }\n\n  if (restoreSelection && $isRootNode(parent) && parent.isEmpty()) {\n    parent.selectEnd();\n  }\n}\nclass LexicalNode {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  // Flow doesn't support abstract classes unfortunately, so we can't _force_\n  // subclasses of Node to implement statics. All subclasses of Node should have\n  // a static getType and clone method though. We define getType and clone here so we can call it\n  // on any  Node, and we throw this error by default since the subclass should provide\n  // their own implementation.\n\n  /**\n   * Returns the string type of this node. Every node must\n   * implement this and it MUST BE UNIQUE amongst nodes registered\n   * on the editor.\n   *\n   */\n  static getType() {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);\n    }\n  }\n  /**\n   * Clones this node, creating a new node with a different key\n   * and adding it to the EditorState (but not attaching it anywhere!). All nodes must\n   * implement this method.\n   *\n   */\n\n\n  static clone(_data) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);\n    }\n  }\n\n  constructor(key) {\n    // @ts-expect-error\n    this.__type = this.constructor.getType();\n    this.__parent = null;\n    this.__prev = null;\n    this.__next = null;\n    $setNodeKey(this, key);\n\n    {\n      if (this.__type !== 'root') {\n        errorOnReadOnly();\n        errorOnTypeKlassMismatch(this.__type, // @ts-expect-error\n        this.constructor);\n      }\n    }\n  } // Getters and Traversers\n\n  /**\n   * Returns the string type of this node.\n   */\n\n\n  getType() {\n    return this.__type;\n  }\n  /**\n   * Returns true if there is a path between this node and the RootNode, false otherwise.\n   * This is a way of determining if the node is \"attached\" EditorState. Unattached nodes\n   * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.\n   */\n\n\n  isAttached() {\n    let nodeKey = this.__key;\n\n    while (nodeKey !== null) {\n      if (nodeKey === 'root') {\n        return true;\n      }\n\n      const node = $getNodeByKey(nodeKey);\n\n      if (node === null) {\n        break;\n      }\n\n      nodeKey = node.__parent;\n    }\n\n    return false;\n  }\n  /**\n   * Returns true if this node is contained within the provided Selection., false otherwise.\n   * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine\n   * what's included.\n   *\n   * @param selection - The selection that we want to determine if the node is in.\n   */\n\n\n  isSelected(selection) {\n    const targetSelection = selection || $getSelection();\n\n    if (targetSelection == null) {\n      return false;\n    }\n\n    const isSelected = targetSelection.getNodes().some(n => n.__key === this.__key);\n\n    if ($isTextNode(this)) {\n      return isSelected;\n    } // For inline images inside of element nodes.\n    // Without this change the image will be selected if the cursor is before or after it.\n\n\n    if ($isRangeSelection(targetSelection) && targetSelection.anchor.type === 'element' && targetSelection.focus.type === 'element' && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {\n      return false;\n    }\n\n    return isSelected;\n  }\n  /**\n   * Returns this nodes key.\n   */\n\n\n  getKey() {\n    // Key is stable between copies\n    return this.__key;\n  }\n  /**\n   * Returns the zero-based index of this node within the parent.\n   */\n\n\n  getIndexWithinParent() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return -1;\n    }\n\n    let node = parent.getFirstChild();\n    let index = 0;\n\n    while (node !== null) {\n      if (this.is(node)) {\n        return index;\n      }\n\n      index++;\n      node = node.getNextSibling();\n    }\n\n    return -1;\n  }\n  /**\n   * Returns the parent of this node, or null if none is found.\n   */\n\n\n  getParent() {\n    const parent = this.getLatest().__parent;\n\n    if (parent === null) {\n      return null;\n    }\n\n    return $getNodeByKey(parent);\n  }\n  /**\n   * Returns the parent of this node, or throws if none is found.\n   */\n\n\n  getParentOrThrow() {\n    const parent = this.getParent();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a parent.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElement() {\n    let node = this;\n\n    while (node !== null) {\n      const parent = node.getParent();\n\n      if ($isRootOrShadowRoot(parent)) {\n        return node;\n      }\n\n      node = parent;\n    }\n\n    return null;\n  }\n  /**\n   * Returns the highest (in the EditorState tree)\n   * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}\n   * for more information on which Elements comprise \"roots\".\n   */\n\n\n  getTopLevelElementOrThrow() {\n    const parent = this.getTopLevelElement();\n\n    if (parent === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a top parent element.`);\n      }\n    }\n\n    return parent;\n  }\n  /**\n   * Returns a list of the every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParents() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns a list of the keys of every ancestor of this node,\n   * all the way up to the RootNode.\n   *\n   */\n\n\n  getParentKeys() {\n    const parents = [];\n    let node = this.getParent();\n\n    while (node !== null) {\n      parents.push(node.__key);\n      node = node.getParent();\n    }\n\n    return parents;\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the node that comes\n   * before this one in the same parent.\n   *\n   */\n\n\n  getPreviousSibling() {\n    const self = this.getLatest();\n    const prevKey = self.__prev;\n    return prevKey === null ? null : $getNodeByKey(prevKey);\n  }\n  /**\n   * Returns the \"previous\" siblings - that is, the nodes that come between\n   * this one and the first child of it's parent, inclusive.\n   *\n   */\n\n\n  getPreviousSiblings() {\n    const siblings = [];\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return siblings;\n    }\n\n    let node = parent.getFirstChild();\n\n    while (node !== null) {\n      if (node.is(this)) {\n        break;\n      }\n\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the \"next\" siblings - that is, the node that comes\n   * after this one in the same parent\n   *\n   */\n\n\n  getNextSibling() {\n    const self = this.getLatest();\n    const nextKey = self.__next;\n    return nextKey === null ? null : $getNodeByKey(nextKey);\n  }\n  /**\n   * Returns all \"next\" siblings - that is, the nodes that come between this\n   * one and the last child of it's parent, inclusive.\n   *\n   */\n\n\n  getNextSiblings() {\n    const siblings = [];\n    let node = this.getNextSibling();\n\n    while (node !== null) {\n      siblings.push(node);\n      node = node.getNextSibling();\n    }\n\n    return siblings;\n  }\n  /**\n   * Returns the closest common ancestor of this node and the provided one or null\n   * if one cannot be found.\n   *\n   * @param node - the other node to find the common ancestor of.\n   */\n\n\n  getCommonAncestor(node) {\n    const a = this.getParents();\n    const b = node.getParents();\n\n    if ($isElementNode(this)) {\n      a.unshift(this);\n    }\n\n    if ($isElementNode(node)) {\n      b.unshift(node);\n    }\n\n    const aLength = a.length;\n    const bLength = b.length;\n\n    if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {\n      return null;\n    }\n\n    const bSet = new Set(b);\n\n    for (let i = 0; i < aLength; i++) {\n      const ancestor = a[i];\n\n      if (bSet.has(ancestor)) {\n        return ancestor;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.\n   * Always use this instead of referential equality.\n   *\n   * @param object - the node to perform the equality comparison on.\n   */\n\n\n  is(object) {\n    if (object == null) {\n      return false;\n    }\n\n    return this.__key === object.__key;\n  }\n  /**\n   * Returns true if this node logical precedes the target node in the editor state.\n   *\n   * @param targetNode - the node we're testing to see if it's after this one.\n   */\n\n\n  isBefore(targetNode) {\n    if (this === targetNode) {\n      return false;\n    }\n\n    if (targetNode.isParentOf(this)) {\n      return true;\n    }\n\n    if (this.isParentOf(targetNode)) {\n      return false;\n    }\n\n    const commonAncestor = this.getCommonAncestor(targetNode);\n    let indexA = 0;\n    let indexB = 0;\n    let node = this;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexA = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    node = targetNode;\n\n    while (true) {\n      const parent = node.getParentOrThrow();\n\n      if (parent === commonAncestor) {\n        indexB = node.getIndexWithinParent();\n        break;\n      }\n\n      node = parent;\n    }\n\n    return indexA < indexB;\n  }\n  /**\n   * Returns true if this node is the parent of the target node, false otherwise.\n   *\n   * @param targetNode - the would-be child node.\n   */\n\n\n  isParentOf(targetNode) {\n    const key = this.__key;\n\n    if (key === targetNode.__key) {\n      return false;\n    }\n\n    let node = targetNode;\n\n    while (node !== null) {\n      if (node.__key === key) {\n        return true;\n      }\n\n      node = node.getParent();\n    }\n\n    return false;\n  } // TO-DO: this function can be simplified a lot\n\n  /**\n   * Returns a list of nodes that are between this node and\n   * the target node in the EditorState.\n   *\n   * @param targetNode - the node that marks the other end of the range of nodes to be returned.\n   */\n\n\n  getNodesBetween(targetNode) {\n    const isBefore = this.isBefore(targetNode);\n    const nodes = [];\n    const visited = new Set();\n    let node = this;\n\n    while (true) {\n      const key = node.__key;\n\n      if (!visited.has(key)) {\n        visited.add(key);\n        nodes.push(node);\n      }\n\n      if (node === targetNode) {\n        break;\n      }\n\n      const child = $isElementNode(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;\n\n      if (child !== null) {\n        node = child;\n        continue;\n      }\n\n      const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();\n\n      if (nextSibling !== null) {\n        node = nextSibling;\n        continue;\n      }\n\n      const parent = node.getParentOrThrow();\n\n      if (!visited.has(parent.__key)) {\n        nodes.push(parent);\n      }\n\n      if (parent === targetNode) {\n        break;\n      }\n\n      let parentSibling = null;\n      let ancestor = parent;\n\n      do {\n        if (ancestor === null) {\n          {\n            throw Error(`getNodesBetween: ancestor is null`);\n          }\n        }\n\n        parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();\n        ancestor = ancestor.getParent();\n\n        if (ancestor !== null) {\n          if (parentSibling === null && !visited.has(ancestor.__key)) {\n            nodes.push(ancestor);\n          }\n        }\n      } while (parentSibling === null);\n\n      node = parentSibling;\n    }\n\n    if (!isBefore) {\n      nodes.reverse();\n    }\n\n    return nodes;\n  }\n  /**\n   * Returns true if this node has been marked dirty during this update cycle.\n   *\n   */\n\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyLeaves = editor._dirtyLeaves;\n    return dirtyLeaves !== null && dirtyLeaves.has(this.__key);\n  }\n  /**\n   * Returns the latest version of the node from the active EditorState.\n   * This is used to avoid getting values from stale node references.\n   *\n   */\n\n\n  getLatest() {\n    const latest = $getNodeByKey(this.__key);\n\n    if (latest === null) {\n      {\n        throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);\n      }\n    }\n\n    return latest;\n  }\n  /**\n   * Returns a mutable version of the node. Will throw an error if\n   * called outside of a Lexical Editor {@link LexicalEditor.update} callback.\n   *\n   */\n\n\n  getWritable() {\n    errorOnReadOnly();\n    const editorState = getActiveEditorState();\n    const editor = getActiveEditor();\n    const nodeMap = editorState._nodeMap;\n    const key = this.__key; // Ensure we get the latest node from pending state\n\n    const latestNode = this.getLatest();\n    const parent = latestNode.__parent;\n    const cloneNotNeeded = editor._cloneNotNeeded;\n    const selection = $getSelection();\n\n    if (selection !== null) {\n      selection._cachedNodes = null;\n    }\n\n    if (cloneNotNeeded.has(key)) {\n      // Transforms clear the dirty node set on each iteration to keep track on newly dirty nodes\n      internalMarkNodeAsDirty(latestNode);\n      return latestNode;\n    }\n\n    const constructor = latestNode.constructor; // @ts-expect-error\n\n    const mutableNode = constructor.clone(latestNode);\n    mutableNode.__parent = parent;\n    mutableNode.__next = latestNode.__next;\n    mutableNode.__prev = latestNode.__prev;\n\n    if ($isElementNode(latestNode) && $isElementNode(mutableNode)) {\n      mutableNode.__first = latestNode.__first;\n      mutableNode.__last = latestNode.__last;\n      mutableNode.__size = latestNode.__size;\n      mutableNode.__indent = latestNode.__indent;\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__dir = latestNode.__dir;\n    } else if ($isTextNode(latestNode) && $isTextNode(mutableNode)) {\n      mutableNode.__format = latestNode.__format;\n      mutableNode.__style = latestNode.__style;\n      mutableNode.__mode = latestNode.__mode;\n      mutableNode.__detail = latestNode.__detail;\n    }\n\n    cloneNotNeeded.add(key);\n    mutableNode.__key = key;\n    internalMarkNodeAsDirty(mutableNode); // Update reference in node map\n\n    nodeMap.set(key, mutableNode);\n    return mutableNode;\n  }\n  /**\n   * Returns the text content of the node. Override this for\n   * custom nodes that should have a representation in plain text\n   * format (for copy + paste, for example)\n   *\n   */\n\n\n  getTextContent() {\n    return '';\n  }\n  /**\n   * Returns the length of the string produced by calling getTextContent on this node.\n   *\n   */\n\n\n  getTextContentSize() {\n    return this.getTextContent().length;\n  } // View\n\n  /**\n   * Called during the reconciliation process to determine which nodes\n   * to insert into the DOM for this Lexical Node.\n   *\n   * This method must return exactly one HTMLElement. Nested elements are not supported.\n   *\n   * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.\n   *\n   * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.\n   * @param _editor - allows access to the editor for context during reconciliation.\n   *\n   * */\n\n\n  createDOM(_config, _editor) {\n    {\n      throw Error(`createDOM: base method not extended`);\n    }\n  }\n  /**\n   * Called when a node changes and should update the DOM\n   * in whatever way is necessary to make it align with any changes that might\n   * have happened during the update.\n   *\n   * Returning \"true\" here will cause lexical to unmount and recreate the DOM node\n   * (by calling createDOM). You would need to do this if the element tag changes,\n   * for instance.\n   *\n   * */\n\n\n  updateDOM(_prevNode, _dom, _config) {\n    {\n      throw Error(`updateDOM: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is serialized to HTML. This is important for\n   * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,\n   * in which case the primary transfer format is HTML. It's also important if you're serializing\n   * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could\n   * also use this method to build your own HTML renderer.\n   *\n   * */\n\n\n  exportDOM(editor) {\n    const element = this.createDOM(editor._config, editor);\n    return {\n      element\n    };\n  }\n  /**\n   * Controls how the this node is serialized to JSON. This is important for\n   * copy and paste between Lexical editors sharing the same namespace. It's also important\n   * if you're serializing to JSON for persistent storage somewhere.\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  exportJSON() {\n    {\n      throw Error(`exportJSON: base method not extended`);\n    }\n  }\n  /**\n   * Controls how the this node is deserialized from JSON. This is usually boilerplate,\n   * but provides an abstraction between the node implementation and serialized interface that can\n   * be important if you ever make breaking changes to a node schema (by adding or removing properties).\n   * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).\n   *\n   * */\n\n\n  static importJSON(_serializedNode) {\n    {\n      throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);\n    }\n  }\n  /**\n   * @experimental\n   *\n   * Registers the returned function as a transform on the node during\n   * Editor initialization. Most such use cases should be addressed via\n   * the {@link LexicalEditor.registerNodeTransform} API.\n   *\n   * Experimental - use at your own risk.\n   */\n\n\n  static transform() {\n    return null;\n  } // Setters and mutators\n\n  /**\n   * Removes this LexicalNode from the EditorState. If the node isn't re-inserted\n   * somewhere, the Lexical garbage collector will eventually clean it up.\n   *\n   * @param preserveEmptyParent - If falsy, the node's parent will be removed if\n   * it's empty after the removal operation. This is the default behavior, subject to\n   * other node heuristics such as {@link ElementNode#canBeEmpty}\n   * */\n\n\n  remove(preserveEmptyParent) {\n    removeNode(this, true, preserveEmptyParent);\n  }\n  /**\n   * Replaces this LexicalNode with the provided node, optionally transferring the children\n   * of the replaced node to the replacing node.\n   *\n   * @param replaceWith - The node to replace this one with.\n   * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.\n   * */\n\n\n  replace(replaceWith, includeChildren) {\n    errorOnReadOnly();\n    let selection = $getSelection();\n    if (selection !== null) selection = selection.clone();\n    errorOnInsertTextNodeOnRoot(this, replaceWith);\n    const self = this.getLatest();\n    const toReplaceKey = this.__key;\n    const key = replaceWith.__key;\n    const writableReplaceWith = replaceWith.getWritable();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const size = writableParent.__size;\n    removeFromParent(writableReplaceWith);\n    const prevSibling = self.getPreviousSibling();\n    const nextSibling = self.getNextSibling();\n    const prevKey = self.__prev;\n    const nextKey = self.__next;\n    const parentKey = self.__parent;\n    removeNode(self, false, true);\n\n    if (prevSibling === null) {\n      writableParent.__first = key;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = key;\n    }\n\n    writableReplaceWith.__prev = prevKey;\n\n    if (nextSibling === null) {\n      writableParent.__last = key;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = key;\n    }\n\n    writableReplaceWith.__next = nextKey;\n    writableReplaceWith.__parent = parentKey;\n    writableParent.__size = size;\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        writableReplaceWith.append(child);\n      });\n    }\n\n    if ($isRangeSelection(selection)) {\n      $setSelection(selection);\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor.key === toReplaceKey) {\n        $moveSelectionPointToEnd(anchor, writableReplaceWith);\n      }\n\n      if (focus.key === toReplaceKey) {\n        $moveSelectionPointToEnd(focus, writableReplaceWith);\n      }\n    }\n\n    if ($getCompositionKey() === toReplaceKey) {\n      $setCompositionKey(key);\n    }\n\n    return writableReplaceWith;\n  }\n  /**\n   * Inserts a node after this LexicalNode (as the next sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertAfter(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const oldParent = writableNodeToInsert.getParent();\n    const selection = $getSelection();\n    let elementAnchorSelectionOnNode = false;\n    let elementFocusSelectionOnNode = false;\n\n    if (oldParent !== null) {\n      // TODO: this is O(n), can we improve?\n      const oldIndex = nodeToInsert.getIndexWithinParent();\n      removeFromParent(writableNodeToInsert);\n\n      if ($isRangeSelection(selection)) {\n        const oldParentKey = oldParent.__key;\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        elementAnchorSelectionOnNode = anchor.type === 'element' && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;\n        elementFocusSelectionOnNode = focus.type === 'element' && focus.key === oldParentKey && focus.offset === oldIndex + 1;\n      }\n    }\n\n    const nextSibling = this.getNextSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    const nextKey = writableSelf.__next;\n\n    if (nextSibling === null) {\n      writableParent.__last = insertKey;\n    } else {\n      const writableNextSibling = nextSibling.getWritable();\n      writableNextSibling.__prev = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__next = insertKey;\n    writableNodeToInsert.__next = nextKey;\n    writableNodeToInsert.__prev = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const index = this.getIndexWithinParent();\n      $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);\n      const writableParentKey = writableParent.__key;\n\n      if (elementAnchorSelectionOnNode) {\n        selection.anchor.set(writableParentKey, index + 2, 'element');\n      }\n\n      if (elementFocusSelectionOnNode) {\n        selection.focus.set(writableParentKey, index + 2, 'element');\n      }\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Inserts a node before this LexicalNode (as the previous sibling).\n   *\n   * @param nodeToInsert - The node to insert after this one.\n   * @param restoreSelection - Whether or not to attempt to resolve the\n   * selection to the appropriate place after the operation is complete.\n   * */\n\n\n  insertBefore(nodeToInsert, restoreSelection = true) {\n    errorOnReadOnly();\n    errorOnInsertTextNodeOnRoot(this, nodeToInsert);\n    const writableSelf = this.getWritable();\n    const writableNodeToInsert = nodeToInsert.getWritable();\n    const insertKey = writableNodeToInsert.__key;\n    removeFromParent(writableNodeToInsert);\n    const prevSibling = this.getPreviousSibling();\n    const writableParent = this.getParentOrThrow().getWritable();\n    const prevKey = writableSelf.__prev; // TODO: this is O(n), can we improve?\n\n    const index = this.getIndexWithinParent();\n\n    if (prevSibling === null) {\n      writableParent.__first = insertKey;\n    } else {\n      const writablePrevSibling = prevSibling.getWritable();\n      writablePrevSibling.__next = insertKey;\n    }\n\n    writableParent.__size++;\n    writableSelf.__prev = insertKey;\n    writableNodeToInsert.__prev = prevKey;\n    writableNodeToInsert.__next = writableSelf.__key;\n    writableNodeToInsert.__parent = writableSelf.__parent;\n    const selection = $getSelection();\n\n    if (restoreSelection && $isRangeSelection(selection)) {\n      const parent = this.getParentOrThrow();\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, index);\n    }\n\n    return nodeToInsert;\n  }\n  /**\n   * Whether or not this node has a required parent. Used during copy + paste operations\n   * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without\n   * a ListNode parent or TextNodes with a ParagraphNode parent.\n   *\n   * */\n\n\n  isParentRequired() {\n    return false;\n  }\n  /**\n   * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.\n   *\n   * */\n\n\n  createParentElementNode() {\n    return $createParagraphNode();\n  }\n  /**\n   * Moves selection to the previous sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectPrevious(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const prevSibling = this.getPreviousSibling();\n    const parent = this.getParentOrThrow();\n\n    if (prevSibling === null) {\n      return parent.select(0, 0);\n    }\n\n    if ($isElementNode(prevSibling)) {\n      return prevSibling.select();\n    } else if (!$isTextNode(prevSibling)) {\n      const index = prevSibling.getIndexWithinParent() + 1;\n      return parent.select(index, index);\n    }\n\n    return prevSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Moves selection to the next sibling of this node, at the specified offsets.\n   *\n   * @param anchorOffset - The anchor offset for selection.\n   * @param focusOffset -  The focus offset for selection\n   * */\n\n\n  selectNext(anchorOffset, focusOffset) {\n    errorOnReadOnly();\n    const nextSibling = this.getNextSibling();\n    const parent = this.getParentOrThrow();\n\n    if (nextSibling === null) {\n      return parent.select();\n    }\n\n    if ($isElementNode(nextSibling)) {\n      return nextSibling.select(0, 0);\n    } else if (!$isTextNode(nextSibling)) {\n      const index = nextSibling.getIndexWithinParent();\n      return parent.select(index, index);\n    }\n\n    return nextSibling.select(anchorOffset, focusOffset);\n  }\n  /**\n   * Marks a node dirty, triggering transforms and\n   * forcing it to be reconciled during the update cycle.\n   *\n   * */\n\n\n  markDirty() {\n    this.getWritable();\n  }\n\n}\n\nfunction errorOnTypeKlassMismatch(type, klass) {\n  const registeredNode = getActiveEditor()._nodes.get(type); // Common error - split in its own invariant\n\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);\n    }\n  }\n\n  const editorKlass = registeredNode.klass;\n\n  if (editorKlass !== klass) {\n    {\n      throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass LineBreakNode extends LexicalNode {\n  static getType() {\n    return 'linebreak';\n  }\n\n  static clone(node) {\n    return new LineBreakNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  }\n\n  getTextContent() {\n    return '\\n';\n  }\n\n  createDOM() {\n    return document.createElement('br');\n  }\n\n  updateDOM() {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      br: node => {\n        const parentElement = node.parentElement; // If the <br> is the only child, then skip including it\n\n        let firstChild;\n        let lastChild;\n\n        if (parentElement !== null && ((firstChild = parentElement.firstChild) === node || firstChild.nextSibling === node && firstChild.nodeType === DOM_TEXT_TYPE && (firstChild.textContent || '').match(/^( |\\t|\\r?\\n)+$/) !== null) && ((lastChild = parentElement.lastChild) === node || lastChild.previousSibling === node && lastChild.nodeType === DOM_TEXT_TYPE && (lastChild.textContent || '').match(/^( |\\t|\\r?\\n)+$/) !== null)) {\n          return null;\n        }\n\n        return {\n          conversion: convertLineBreakElement,\n          priority: 0\n        };\n      }\n    };\n  }\n\n  static importJSON(serializedLineBreakNode) {\n    return $createLineBreakNode();\n  }\n\n  exportJSON() {\n    return {\n      type: 'linebreak',\n      version: 1\n    };\n  }\n\n}\n\nfunction convertLineBreakElement(node) {\n  return {\n    node: $createLineBreakNode()\n  };\n}\n\nfunction $createLineBreakNode() {\n  return $applyNodeReplacement(new LineBreakNode());\n}\nfunction $isLineBreakNode(node) {\n  return node instanceof LineBreakNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getElementOuterTag(node, format) {\n  if (format & IS_CODE) {\n    return 'code';\n  }\n\n  if (format & IS_HIGHLIGHT) {\n    return 'mark';\n  }\n\n  if (format & IS_SUBSCRIPT) {\n    return 'sub';\n  }\n\n  if (format & IS_SUPERSCRIPT) {\n    return 'sup';\n  }\n\n  return null;\n}\n\nfunction getElementInnerTag(node, format) {\n  if (format & IS_BOLD) {\n    return 'strong';\n  }\n\n  if (format & IS_ITALIC) {\n    return 'em';\n  }\n\n  return 'span';\n}\n\nfunction setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {\n  const domClassList = dom.classList; // Firstly we handle the base theme.\n\n  let classNames = getCachedClassNameArray(textClassNames, 'base');\n\n  if (classNames !== undefined) {\n    domClassList.add(...classNames);\n  } // Secondly we handle the special case: underline + strikethrough.\n  // We have to do this as we need a way to compose the fact that\n  // the same CSS property will need to be used: text-decoration.\n  // In an ideal world we shouldn't have to do this, but there's no\n  // easy workaround for many atomic CSS systems today.\n\n\n  classNames = getCachedClassNameArray(textClassNames, 'underlineStrikethrough');\n  let hasUnderlineStrikethrough = false;\n  const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE && prevFormat & IS_STRIKETHROUGH;\n  const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE && nextFormat & IS_STRIKETHROUGH;\n\n  if (classNames !== undefined) {\n    if (nextUnderlineStrikethrough) {\n      hasUnderlineStrikethrough = true;\n\n      if (!prevUnderlineStrikethrough) {\n        domClassList.add(...classNames);\n      }\n    } else if (prevUnderlineStrikethrough) {\n      domClassList.remove(...classNames);\n    }\n  }\n\n  for (const key in TEXT_TYPE_TO_FORMAT) {\n    const format = key;\n    const flag = TEXT_TYPE_TO_FORMAT[format];\n    classNames = getCachedClassNameArray(textClassNames, key);\n\n    if (classNames !== undefined) {\n      if (nextFormat & flag) {\n        if (hasUnderlineStrikethrough && (key === 'underline' || key === 'strikethrough')) {\n          if (prevFormat & flag) {\n            domClassList.remove(...classNames);\n          }\n\n          continue;\n        }\n\n        if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === 'underline' || key === 'strikethrough') {\n          domClassList.add(...classNames);\n        }\n      } else if (prevFormat & flag) {\n        domClassList.remove(...classNames);\n      }\n    }\n  }\n}\n\nfunction diffComposedText(a, b) {\n  const aLength = a.length;\n  const bLength = b.length;\n  let left = 0;\n  let right = 0;\n\n  while (left < aLength && left < bLength && a[left] === b[left]) {\n    left++;\n  }\n\n  while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {\n    right++;\n  }\n\n  return [left, aLength - left - right, b.slice(left, bLength - right)];\n}\n\nfunction setTextContent(nextText, dom, node) {\n  const firstChild = dom.firstChild;\n  const isComposing = node.isComposing(); // Always add a suffix if we're composing a node\n\n  const suffix = isComposing ? COMPOSITION_SUFFIX : '';\n  const text = nextText + suffix;\n\n  if (firstChild == null) {\n    dom.textContent = text;\n  } else {\n    const nodeValue = firstChild.nodeValue;\n\n    if (nodeValue !== text) {\n      if (isComposing || IS_FIREFOX) {\n        // We also use the diff composed text for general text in FF to avoid\n        // the spellcheck red line from flickering.\n        const [index, remove, insert] = diffComposedText(nodeValue, text);\n\n        if (remove !== 0) {\n          // @ts-expect-error\n          firstChild.deleteData(index, remove);\n        } // @ts-expect-error\n\n\n        firstChild.insertData(index, insert);\n      } else {\n        firstChild.nodeValue = text;\n      }\n    }\n  }\n}\n\nfunction createTextInnerDOM(innerDOM, node, innerTag, format, text, config) {\n  setTextContent(text, innerDOM, node);\n  const theme = config.theme; // Apply theme class names\n\n  const textClassNames = theme.text;\n\n  if (textClassNames !== undefined) {\n    setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);\n  }\n}\n\nfunction wrapElementWith(element, tag) {\n  const el = document.createElement(tag);\n  el.appendChild(element);\n  return el;\n}\n/** @noInheritDoc */\n\n\nclass TextNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'text';\n  }\n\n  static clone(node) {\n    return new TextNode(node.__text, node.__key);\n  }\n\n  constructor(text, key) {\n    super(key);\n    this.__text = text;\n    this.__format = 0;\n    this.__style = '';\n    this.__mode = 0;\n    this.__detail = 0;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.\n   *\n   * @returns a number representing the format of the text node.\n   */\n\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n  /**\n   * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the\n   * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless\n   * or TextNode.isUnmergeable instead.\n   *\n   * @returns a number representing the detail of the text node.\n   */\n\n\n  getDetail() {\n    const self = this.getLatest();\n    return self.__detail;\n  }\n  /**\n   * Returns the mode (TextModeType) of the TextNode, which may be \"normal\", \"token\", or \"segmented\"\n   *\n   * @returns TextModeType.\n   */\n\n\n  getMode() {\n    const self = this.getLatest();\n    return TEXT_TYPE_TO_MODE[self.__mode];\n  }\n  /**\n   * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.\n   *\n   * @returns CSSText-like string of styles applied to the underlying DOM node.\n   */\n\n\n  getStyle() {\n    const self = this.getLatest();\n    return self.__style;\n  }\n  /**\n   * Returns whether or not the node is in \"token\" mode. TextNodes in token mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted as a single entity (not invdividually by character).\n   *\n   * @returns true if the node is in token mode, false otherwise.\n   */\n\n\n  isToken() {\n    const self = this.getLatest();\n    return self.__mode === IS_TOKEN;\n  }\n  /**\n   *\n   * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to\n   * mutate the TextNode, false otherwise.\n   */\n\n\n  isComposing() {\n    return this.__key === $getCompositionKey();\n  }\n  /**\n   * Returns whether or not the node is in \"segemented\" mode. TextNodes in segemented mode can be navigated through character-by-character\n   * with a RangeSelection, but are deleted in space-delimited \"segments\".\n   *\n   * @returns true if the node is in segmented mode, false otherwise.\n   */\n\n\n  isSegmented() {\n    const self = this.getLatest();\n    return self.__mode === IS_SEGMENTED;\n  }\n  /**\n   * Returns whether or not the node is \"directionless\". Directionless nodes don't respect changes between RTL and LTR modes.\n   *\n   * @returns true if the node is directionless, false otherwise.\n   */\n\n\n  isDirectionless() {\n    const self = this.getLatest();\n    return (self.__detail & IS_DIRECTIONLESS) !== 0;\n  }\n  /**\n   * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge\n   * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.\n   *\n   * @returns true if the node is unmergeable, false otherwise.\n   */\n\n\n  isUnmergeable() {\n    const self = this.getLatest();\n    return (self.__detail & IS_UNMERGEABLE) !== 0;\n  }\n  /**\n   * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType\n   * string values to get the format of a TextNode.\n   *\n   * @param type - the TextFormatType to check for.\n   *\n   * @returns true if the node has the provided format, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.getFormat() & formatFlag) !== 0;\n  }\n  /**\n   * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type \"text\"\n   * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).\n   *\n   * @returns true if the node is simple text, false otherwise.\n   */\n\n\n  isSimpleText() {\n    return this.__type === 'text' && this.__mode === 0;\n  }\n  /**\n   * Returns the text content of the node as a string.\n   *\n   * @returns a string representing the text content of the node.\n   */\n\n\n  getTextContent() {\n    const self = this.getLatest();\n    return self.__text;\n  }\n  /**\n   * Returns the format flags applied to the node as a 32-bit integer.\n   *\n   * @returns a number representing the TextFormatTypes applied to the node.\n   */\n\n\n  getFormatFlags(type, alignWithFormat) {\n    const self = this.getLatest();\n    const format = self.__format;\n    return toggleTextFormatType(format, type, alignWithFormat);\n  } // View\n\n\n  createDOM(config) {\n    const format = this.__format;\n    const outerTag = getElementOuterTag(this, format);\n    const innerTag = getElementInnerTag(this, format);\n    const tag = outerTag === null ? innerTag : outerTag;\n    const dom = document.createElement(tag);\n    let innerDOM = dom;\n\n    if (this.hasFormat('code')) {\n      dom.setAttribute('spellcheck', 'false');\n    }\n\n    if (outerTag !== null) {\n      innerDOM = document.createElement(innerTag);\n      dom.appendChild(innerDOM);\n    }\n\n    const text = this.__text;\n    createTextInnerDOM(innerDOM, this, innerTag, format, text, config);\n    const style = this.__style;\n\n    if (style !== '') {\n      dom.style.cssText = style;\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const nextText = this.__text;\n    const prevFormat = prevNode.__format;\n    const nextFormat = this.__format;\n    const prevOuterTag = getElementOuterTag(this, prevFormat);\n    const nextOuterTag = getElementOuterTag(this, nextFormat);\n    const prevInnerTag = getElementInnerTag(this, prevFormat);\n    const nextInnerTag = getElementInnerTag(this, nextFormat);\n    const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;\n    const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;\n\n    if (prevTag !== nextTag) {\n      return true;\n    }\n\n    if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {\n      // should always be an element\n      const prevInnerDOM = dom.firstChild;\n\n      if (prevInnerDOM == null) {\n        {\n          throw Error(`updateDOM: prevInnerDOM is null or undefined`);\n        }\n      }\n\n      const nextInnerDOM = document.createElement(nextInnerTag);\n      createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);\n      dom.replaceChild(nextInnerDOM, prevInnerDOM);\n      return false;\n    }\n\n    let innerDOM = dom;\n\n    if (nextOuterTag !== null) {\n      if (prevOuterTag !== null) {\n        innerDOM = dom.firstChild;\n\n        if (innerDOM == null) {\n          {\n            throw Error(`updateDOM: innerDOM is null or undefined`);\n          }\n        }\n      }\n    }\n\n    setTextContent(nextText, innerDOM, this);\n    const theme = config.theme; // Apply theme class names\n\n    const textClassNames = theme.text;\n\n    if (textClassNames !== undefined && prevFormat !== nextFormat) {\n      setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);\n    }\n\n    const prevStyle = prevNode.__style;\n    const nextStyle = this.__style;\n\n    if (prevStyle !== nextStyle) {\n      dom.style.cssText = nextStyle;\n    }\n\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      '#text': () => ({\n        conversion: convertTextDOMNode,\n        priority: 0\n      }),\n      b: () => ({\n        conversion: convertBringAttentionToElement,\n        priority: 0\n      }),\n      code: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      em: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      i: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      s: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      span: () => ({\n        conversion: convertSpanElement,\n        priority: 0\n      }),\n      strong: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sub: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      sup: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      }),\n      u: () => ({\n        conversion: convertTextFormatElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createTextNode(serializedNode.text);\n    node.setFormat(serializedNode.format);\n    node.setDetail(serializedNode.detail);\n    node.setMode(serializedNode.mode);\n    node.setStyle(serializedNode.style);\n    return node;\n  } // This improves Lexical's basic text output in copy+paste plus\n  // for headless mode where people might use Lexical to generate\n  // HTML content and not have the ability to use CSS classes.\n\n\n  exportDOM(editor) {\n    let {\n      element\n    } = super.exportDOM(editor);\n\n    if (!(element !== null && isHTMLElement(element))) {\n      throw Error(`Expected TextNode createDOM to always return a HTMLElement`);\n    }\n\n    element.style.whiteSpace = 'pre-wrap'; // This is the only way to properly add support for most clients,\n    // even if it's semantically incorrect to have to resort to using\n    // <b>, <u>, <s>, <i> elements.\n\n    if (this.hasFormat('bold')) {\n      element = wrapElementWith(element, 'b');\n    }\n\n    if (this.hasFormat('italic')) {\n      element = wrapElementWith(element, 'i');\n    }\n\n    if (this.hasFormat('strikethrough')) {\n      element = wrapElementWith(element, 's');\n    }\n\n    if (this.hasFormat('underline')) {\n      element = wrapElementWith(element, 'u');\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return {\n      detail: this.getDetail(),\n      format: this.getFormat(),\n      mode: this.getMode(),\n      style: this.getStyle(),\n      text: this.getTextContent(),\n      type: 'text',\n      version: 1\n    };\n  } // Mutators\n\n\n  selectionTransform(prevSelection, nextSelection) {\n    return;\n  }\n  /**\n   * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType\n   * version of the argument can only specify one format and doing so will remove all other formats that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}\n   *\n   * @param format - TextFormatType or 32-bit integer representing the node format.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setFormat(format) {\n    const self = this.getWritable();\n    self.__format = typeof format === 'string' ? TEXT_TYPE_TO_FORMAT[format] : format;\n    return self;\n  }\n  /**\n   * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType\n   * version of the argument can only specify one detail value and doing so will remove all other detail values that\n   * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}\n   * or {@link TextNode.togglerUnmergeable}\n   *\n   * @param detail - TextDetailType or 32-bit integer representing the node detail.\n   *\n   * @returns this TextNode.\n   * // TODO 0.12 This should just be a `string`.\n   */\n\n\n  setDetail(detail) {\n    const self = this.getWritable();\n    self.__detail = typeof detail === 'string' ? DETAIL_TYPE_TO_DETAIL[detail] : detail;\n    return self;\n  }\n  /**\n   * Sets the node style to the provided CSSText-like string. Set this property as you\n   * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.\n   *\n   * @param style - CSSText to be applied to the underlying HTMLElement.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setStyle(style) {\n    const self = this.getWritable();\n    self.__style = style;\n    return self;\n  }\n  /**\n   * Applies the provided format to this TextNode if it's not present. Removes it if it is present.\n   * Prefer using this method to turn specific formats on and off.\n   *\n   * @param type - TextFormatType to toggle.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return this.setFormat(this.getFormat() ^ formatFlag);\n  }\n  /**\n   * Toggles the directionless detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleDirectionless() {\n    const self = this.getWritable();\n    self.__detail ^= IS_DIRECTIONLESS;\n    return self;\n  }\n  /**\n   * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.\n   *\n   * @returns this TextNode.\n   */\n\n\n  toggleUnmergeable() {\n    const self = this.getWritable();\n    self.__detail ^= IS_UNMERGEABLE;\n    return self;\n  }\n  /**\n   * Sets the mode of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setMode(type) {\n    const mode = TEXT_MODE_TO_TYPE[type];\n\n    if (this.__mode === mode) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__mode = mode;\n    return self;\n  }\n  /**\n   * Sets the text content of the node.\n   *\n   * @param text - the string to set as the text value of the node.\n   *\n   * @returns this TextNode.\n   */\n\n\n  setTextContent(text) {\n    if (this.__text === text) {\n      return this;\n    }\n\n    const self = this.getWritable();\n    self.__text = text;\n    return self;\n  }\n  /**\n   * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.\n   *\n   * @param _anchorOffset - the offset at which the Selection anchor will be placed.\n   * @param _focusOffset - the offset at which the Selection focus will be placed.\n   *\n   * @returns the new RangeSelection.\n   */\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const selection = $getSelection();\n    const text = this.getTextContent();\n    const key = this.__key;\n\n    if (typeof text === 'string') {\n      const lastOffset = text.length;\n\n      if (anchorOffset === undefined) {\n        anchorOffset = lastOffset;\n      }\n\n      if (focusOffset === undefined) {\n        focusOffset = lastOffset;\n      }\n    } else {\n      anchorOffset = 0;\n      focusOffset = 0;\n    }\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'text', 'text');\n    } else {\n      const compositionKey = $getCompositionKey();\n\n      if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {\n        $setCompositionKey(key);\n      }\n\n      selection.setTextNodeRange(this, anchorOffset, this, focusOffset);\n    }\n\n    return selection;\n  }\n  /**\n   * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters\n   * specified. Can optionally calculate a new selection after the operation is complete.\n   *\n   * @param offset - the offset at which the splice operation should begin.\n   * @param delCount - the number of characters to delete, starting from the offset.\n   * @param newText - the text to insert into the TextNode at the offset.\n   * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.\n   *\n   * @returns this TextNode.\n   */\n\n\n  spliceText(offset, delCount, newText, moveSelection) {\n    const writableSelf = this.getWritable();\n    const text = writableSelf.__text;\n    const handledTextLength = newText.length;\n    let index = offset;\n\n    if (index < 0) {\n      index = handledTextLength + index;\n\n      if (index < 0) {\n        index = 0;\n      }\n    }\n\n    const selection = $getSelection();\n\n    if (moveSelection && $isRangeSelection(selection)) {\n      const newOffset = offset + handledTextLength;\n      selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);\n    }\n\n    const updatedText = text.slice(0, index) + newText + text.slice(index + delCount);\n    writableSelf.__text = updatedText;\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted before the node, false otherwise.\n   */\n\n\n  canInsertTextBefore() {\n    return true;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt\n   * to insert text into this node. If false, it will insert the text in a new sibling node.\n   *\n   * @returns true if text can be inserted after the node, false otherwise.\n   */\n\n\n  canInsertTextAfter() {\n    return true;\n  }\n  /**\n   * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings\n   * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.\n   *\n   * @param splitOffsets - rest param of the text content character offsets at which this node should be split.\n   *\n   * @returns an Array containing the newly-created TextNodes.\n   */\n\n\n  splitText(...splitOffsets) {\n    errorOnReadOnly();\n    const self = this.getLatest();\n    const textContent = self.getTextContent();\n    const key = self.__key;\n    const compositionKey = $getCompositionKey();\n    const offsetsSet = new Set(splitOffsets);\n    const parts = [];\n    const textLength = textContent.length;\n    let string = '';\n\n    for (let i = 0; i < textLength; i++) {\n      if (string !== '' && offsetsSet.has(i)) {\n        parts.push(string);\n        string = '';\n      }\n\n      string += textContent[i];\n    }\n\n    if (string !== '') {\n      parts.push(string);\n    }\n\n    const partsLength = parts.length;\n\n    if (partsLength === 0) {\n      return [];\n    } else if (parts[0] === textContent) {\n      return [self];\n    }\n\n    const firstPart = parts[0];\n    const parent = self.getParentOrThrow();\n    let writableNode;\n    const format = self.getFormat();\n    const style = self.getStyle();\n    const detail = self.__detail;\n    let hasReplacedSelf = false;\n\n    if (self.isSegmented()) {\n      // Create a new TextNode\n      writableNode = $createTextNode(firstPart);\n      writableNode.__format = format;\n      writableNode.__style = style;\n      writableNode.__detail = detail;\n      hasReplacedSelf = true;\n    } else {\n      // For the first part, update the existing node\n      writableNode = self.getWritable();\n      writableNode.__text = firstPart;\n    } // Handle selection\n\n\n    const selection = $getSelection(); // Then handle all other parts\n\n    const splitNodes = [writableNode];\n    let textSize = firstPart.length;\n\n    for (let i = 1; i < partsLength; i++) {\n      const part = parts[i];\n      const partSize = part.length;\n      const sibling = $createTextNode(part).getWritable();\n      sibling.__format = format;\n      sibling.__style = style;\n      sibling.__detail = detail;\n      const siblingKey = sibling.__key;\n      const nextTextSize = textSize + partSize;\n\n      if ($isRangeSelection(selection)) {\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n\n        if (anchor.key === key && anchor.type === 'text' && anchor.offset > textSize && anchor.offset <= nextTextSize) {\n          anchor.key = siblingKey;\n          anchor.offset -= textSize;\n          selection.dirty = true;\n        }\n\n        if (focus.key === key && focus.type === 'text' && focus.offset > textSize && focus.offset <= nextTextSize) {\n          focus.key = siblingKey;\n          focus.offset -= textSize;\n          selection.dirty = true;\n        }\n      }\n\n      if (compositionKey === key) {\n        $setCompositionKey(siblingKey);\n      }\n\n      textSize = nextTextSize;\n      splitNodes.push(sibling);\n    } // Insert the nodes into the parent's children\n\n\n    internalMarkSiblingsAsDirty(this);\n    const writableParent = parent.getWritable();\n    const insertionIndex = this.getIndexWithinParent();\n\n    if (hasReplacedSelf) {\n      writableParent.splice(insertionIndex, 0, splitNodes);\n      this.remove();\n    } else {\n      writableParent.splice(insertionIndex, 1, splitNodes);\n    }\n\n    if ($isRangeSelection(selection)) {\n      $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);\n    }\n\n    return splitNodes;\n  }\n  /**\n   * Merges the target TextNode into this TextNode, removing the target node.\n   *\n   * @param target - the TextNode to merge into this one.\n   *\n   * @returns this TextNode.\n   */\n\n\n  mergeWithSibling(target) {\n    const isBefore = target === this.getPreviousSibling();\n\n    if (!isBefore && target !== this.getNextSibling()) {\n      {\n        throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);\n      }\n    }\n\n    const key = this.__key;\n    const targetKey = target.__key;\n    const text = this.__text;\n    const textLength = text.length;\n    const compositionKey = $getCompositionKey();\n\n    if (compositionKey === targetKey) {\n      $setCompositionKey(key);\n    }\n\n    const selection = $getSelection();\n\n    if ($isRangeSelection(selection)) {\n      const anchor = selection.anchor;\n      const focus = selection.focus;\n\n      if (anchor !== null && anchor.key === targetKey) {\n        adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n\n      if (focus !== null && focus.key === targetKey) {\n        adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);\n        selection.dirty = true;\n      }\n    }\n\n    const targetText = target.__text;\n    const newText = isBefore ? targetText + text : text + targetText;\n    this.setTextContent(newText);\n    const writableSelf = this.getWritable();\n    target.remove();\n    return writableSelf;\n  }\n  /**\n   * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes\n   * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the\n   * node class that you create and replace matched text with should return true from this method.\n   *\n   * @returns true if the node is to be treated as a \"text entity\", false otherwise.\n   */\n\n\n  isTextEntity() {\n    return false;\n  }\n\n}\n\nfunction convertSpanElement(domNode) {\n  // domNode is a <span> since we matched it by nodeName\n  const span = domNode; // Google Docs uses span tags + font-weight for bold text\n\n  const hasBoldFontWeight = span.style.fontWeight === '700'; // Google Docs uses span tags + text-decoration: line-through for strikethrough text\n\n  const hasLinethroughTextDecoration = span.style.textDecoration === 'line-through'; // Google Docs uses span tags + font-style for italic text\n\n  const hasItalicFontStyle = span.style.fontStyle === 'italic'; // Google Docs uses span tags + text-decoration: underline for underline text\n\n  const hasUnderlineTextDecoration = span.style.textDecoration === 'underline'; // Google Docs uses span tags + vertical-align to specify subscript and superscript\n\n  const verticalAlign = span.style.verticalAlign;\n  return {\n    forChild: lexicalNode => {\n      if (!$isTextNode(lexicalNode)) {\n        return lexicalNode;\n      }\n\n      if (hasBoldFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      if (hasLinethroughTextDecoration) {\n        lexicalNode.toggleFormat('strikethrough');\n      }\n\n      if (hasItalicFontStyle) {\n        lexicalNode.toggleFormat('italic');\n      }\n\n      if (hasUnderlineTextDecoration) {\n        lexicalNode.toggleFormat('underline');\n      }\n\n      if (verticalAlign === 'sub') {\n        lexicalNode.toggleFormat('subscript');\n      }\n\n      if (verticalAlign === 'super') {\n        lexicalNode.toggleFormat('superscript');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction convertBringAttentionToElement(domNode) {\n  // domNode is a <b> since we matched it by nodeName\n  const b = domNode; // Google Docs wraps all copied HTML in a <b> with font-weight normal\n\n  const hasNormalFontWeight = b.style.fontWeight === 'normal';\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !hasNormalFontWeight) {\n        lexicalNode.toggleFormat('bold');\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nconst preParentCache = new WeakMap();\n\nfunction isNodePre(node) {\n  return node.nodeName === 'PRE' || node.nodeType === DOM_ELEMENT_TYPE && node.style.whiteSpace.startsWith('pre');\n}\n\nfunction findParentPreDOMNode(node) {\n  let cached;\n  let parent = node.parentNode;\n  const visited = [node];\n\n  while (parent !== null && (cached = preParentCache.get(parent)) === undefined && !isNodePre(parent)) {\n    visited.push(parent);\n    parent = parent.parentNode;\n  }\n\n  const resultNode = cached === undefined ? parent : cached;\n\n  for (let i = 0; i < visited.length; i++) {\n    preParentCache.set(visited[i], resultNode);\n  }\n\n  return resultNode;\n}\n\nfunction convertTextDOMNode(domNode) {\n  const domNode_ = domNode;\n  const parentDom = domNode.parentElement;\n\n  if (!(parentDom !== null)) {\n    throw Error(`Expected parentElement of Text not to be null`);\n  }\n\n  let textContent = domNode_.textContent || ''; // No collapse and preserve segment break for pre, pre-wrap and pre-line\n\n  if (findParentPreDOMNode(domNode_) !== null) {\n    const parts = textContent.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else if (part !== '') {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    return {\n      node: nodes\n    };\n  }\n\n  textContent = textContent.replace(/\\r/g, '').replace(/[ \\t\\n]+/g, ' ');\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  if (textContent[0] === ' ') {\n    // Traverse backward while in the same line. If content contains new line or tab -> pontential\n    // delete, other elements can borrow from this one. Deletion depends on whether it's also the\n    // last space (see next condition: textContent[textContent.length - 1] === ' '))\n    let previousText = domNode_;\n    let isStartOfLine = true;\n\n    while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {\n      const previousTextContent = previousText.textContent || '';\n\n      if (previousTextContent.length > 0) {\n        if (/[ \\t\\n]$/.test(previousTextContent)) {\n          textContent = textContent.slice(1);\n        }\n\n        isStartOfLine = false;\n        break;\n      }\n    }\n\n    if (isStartOfLine) {\n      textContent = textContent.slice(1);\n    }\n  }\n\n  if (textContent[textContent.length - 1] === ' ') {\n    // Traverse forward while in the same line, preserve if next inline will require a space\n    let nextText = domNode_;\n    let isEndOfLine = true;\n\n    while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {\n      const nextTextContent = (nextText.textContent || '').replace(/^( |\\t|\\r?\\n)+/, '');\n\n      if (nextTextContent.length > 0) {\n        isEndOfLine = false;\n        break;\n      }\n    }\n\n    if (isEndOfLine) {\n      textContent = textContent.slice(0, textContent.length - 1);\n    }\n  }\n\n  if (textContent === '') {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    node: $createTextNode(textContent)\n  };\n}\n\nconst inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, 'i');\n\nfunction findTextInLine(text, forward) {\n  let node = text; // eslint-disable-next-line no-constant-condition\n\n  while (true) {\n    let sibling;\n\n    while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {\n      const parentElement = node.parentElement;\n\n      if (parentElement === null) {\n        return null;\n      }\n\n      node = parentElement;\n    }\n\n    node = sibling;\n\n    if (node.nodeType === DOM_ELEMENT_TYPE) {\n      const display = node.style.display;\n\n      if (display === '' && node.nodeName.match(inlineParents) === null || display !== '' && !display.startsWith('inline')) {\n        return null;\n      }\n    }\n\n    let descendant = node;\n\n    while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {\n      node = descendant;\n    }\n\n    if (node.nodeType === DOM_TEXT_TYPE) {\n      return node;\n    } else if (node.nodeName === 'BR') {\n      return null;\n    }\n  }\n}\n\nconst nodeNameToTextFormat = {\n  code: 'code',\n  em: 'italic',\n  i: 'italic',\n  s: 'strikethrough',\n  strong: 'bold',\n  sub: 'subscript',\n  sup: 'superscript',\n  u: 'underline'\n};\n\nfunction convertTextFormatElement(domNode) {\n  const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];\n\n  if (format === undefined) {\n    return {\n      node: null\n    };\n  }\n\n  return {\n    forChild: lexicalNode => {\n      if ($isTextNode(lexicalNode) && !lexicalNode.hasFormat(format)) {\n        lexicalNode.toggleFormat(format);\n      }\n\n      return lexicalNode;\n    },\n    node: null\n  };\n}\n\nfunction $createTextNode(text = '') {\n  return $applyNodeReplacement(new TextNode(text));\n}\nfunction $isTextNode(node) {\n  return node instanceof TextNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass TabNode extends TextNode {\n  static getType() {\n    return 'tab';\n  }\n\n  static clone(node) {\n    const newNode = new TabNode(node.__key); // TabNode __text can be either '\\t' or ''. insertText will remove the empty Node\n\n    newNode.__text = node.__text;\n    newNode.__format = node.__format;\n    newNode.__style = node.__style;\n    return newNode;\n  }\n\n  constructor(key) {\n    super('\\t', key);\n    this.__detail = IS_UNMERGEABLE;\n  }\n\n  static importDOM() {\n    return null;\n  }\n\n  static importJSON(serializedTabNode) {\n    const node = $createTabNode();\n    node.setFormat(serializedTabNode.format);\n    node.setStyle(serializedTabNode.style);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'tab',\n      version: 1\n    };\n  }\n\n  setTextContent(_text) {\n    {\n      throw Error(`TabNode does not support setTextContent`);\n    }\n  }\n\n  setDetail(_detail) {\n    {\n      throw Error(`TabNode does not support setDetail`);\n    }\n  }\n\n  setMode(_type) {\n    {\n      throw Error(`TabNode does not support setMode`);\n    }\n  }\n\n  canInsertTextBefore() {\n    return false;\n  }\n\n  canInsertTextAfter() {\n    return false;\n  }\n\n}\nfunction $createTabNode() {\n  return $applyNodeReplacement(new TabNode());\n}\nfunction $isTabNode(node) {\n  return node instanceof TabNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass Point {\n  constructor(key, offset, type) {\n    this._selection = null;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n  }\n\n  is(point) {\n    return this.key === point.key && this.offset === point.offset && this.type === point.type;\n  }\n\n  isBefore(b) {\n    let aNode = this.getNode();\n    let bNode = b.getNode();\n    const aOffset = this.offset;\n    const bOffset = b.offset;\n\n    if ($isElementNode(aNode)) {\n      const aNodeDescendant = aNode.getDescendantByIndex(aOffset);\n      aNode = aNodeDescendant != null ? aNodeDescendant : aNode;\n    }\n\n    if ($isElementNode(bNode)) {\n      const bNodeDescendant = bNode.getDescendantByIndex(bOffset);\n      bNode = bNodeDescendant != null ? bNodeDescendant : bNode;\n    }\n\n    if (aNode === bNode) {\n      return aOffset < bOffset;\n    }\n\n    return aNode.isBefore(bNode);\n  }\n\n  getNode() {\n    const key = this.key;\n    const node = $getNodeByKey(key);\n\n    if (node === null) {\n      {\n        throw Error(`Point.getNode: node not found`);\n      }\n    }\n\n    return node;\n  }\n\n  set(key, offset, type) {\n    const selection = this._selection;\n    const oldKey = this.key;\n    this.key = key;\n    this.offset = offset;\n    this.type = type;\n\n    if (!isCurrentlyReadOnlyMode()) {\n      if ($getCompositionKey() === oldKey) {\n        $setCompositionKey(key);\n      }\n\n      if (selection !== null) {\n        selection._cachedNodes = null;\n        selection.dirty = true;\n      }\n    }\n  }\n\n}\n\nfunction $createPoint(key, offset, type) {\n  // @ts-expect-error: intentionally cast as we use a class for perf reasons\n  return new Point(key, offset, type);\n}\n\nfunction selectPointOnNode(point, node) {\n  let key = node.__key;\n  let offset = point.offset;\n  let type = 'element';\n\n  if ($isTextNode(node)) {\n    type = 'text';\n    const textContentLength = node.getTextContentSize();\n\n    if (offset > textContentLength) {\n      offset = textContentLength;\n    }\n  } else if (!$isElementNode(node)) {\n    const nextSibling = node.getNextSibling();\n\n    if ($isTextNode(nextSibling)) {\n      key = nextSibling.__key;\n      offset = 0;\n      type = 'text';\n    } else {\n      const parentNode = node.getParent();\n\n      if (parentNode) {\n        key = parentNode.__key;\n        offset = node.getIndexWithinParent() + 1;\n      }\n    }\n  }\n\n  point.set(key, offset, type);\n}\n\nfunction $moveSelectionPointToEnd(point, node) {\n  if ($isElementNode(node)) {\n    const lastNode = node.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      selectPointOnNode(point, lastNode);\n    } else {\n      selectPointOnNode(point, node);\n    }\n  } else {\n    selectPointOnNode(point, node);\n  }\n}\n\nfunction $transferStartingElementPointToTextPoint(start, end, format, style) {\n  const element = start.getNode();\n  const placementNode = element.getChildAtIndex(start.offset);\n  const textNode = $createTextNode();\n  const target = $isRootNode(element) ? $createParagraphNode().append(textNode) : textNode;\n  textNode.setFormat(format);\n  textNode.setStyle(style);\n\n  if (placementNode === null) {\n    element.append(target);\n  } else {\n    placementNode.insertBefore(target); // Fix the end point offset if it refers to the same element as start,\n    // as we've now inserted another element before it. Note that we only\n    // do it if selection is not collapsed as otherwise it'll transfer\n    // both focus and anchor to the text node below\n\n    if (end.type === 'element' && end.key === start.key && end.offset !== start.offset) {\n      end.set(end.key, end.offset + 1, 'element');\n    }\n  } // Transfer the element point to a text point.\n\n\n  if (start.is(end)) {\n    end.set(textNode.__key, 0, 'text');\n  }\n\n  start.set(textNode.__key, 0, 'text');\n}\n\nfunction $setPointValues(point, key, offset, type) {\n  point.key = key;\n  point.offset = offset;\n  point.type = type;\n}\n\nclass NodeSelection {\n  constructor(objects) {\n    this.dirty = false;\n    this._nodes = objects;\n    this._cachedNodes = null;\n  }\n\n  is(selection) {\n    if (!$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const a = this._nodes;\n    const b = selection._nodes;\n    return a.size === b.size && Array.from(a).every(key => b.has(key));\n  }\n\n  add(key) {\n    this.dirty = true;\n\n    this._nodes.add(key);\n\n    this._cachedNodes = null;\n  }\n\n  delete(key) {\n    this.dirty = true;\n\n    this._nodes.delete(key);\n\n    this._cachedNodes = null;\n  }\n\n  clear() {\n    this.dirty = true;\n\n    this._nodes.clear();\n\n    this._cachedNodes = null;\n  }\n\n  has(key) {\n    return this._nodes.has(key);\n  }\n\n  clone() {\n    return new NodeSelection(new Set(this._nodes));\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastSelectedNode = selectedNodes[selectedNodesLength - 1];\n    let selectionAtEnd; // Insert nodes\n\n    if ($isTextNode(lastSelectedNode)) {\n      selectionAtEnd = lastSelectedNode.select();\n    } else {\n      const index = lastSelectedNode.getIndexWithinParent() + 1;\n      selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);\n    }\n\n    selectionAtEnd.insertNodes(nodes, selectStart); // Remove selected nodes\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      selectedNodes[i].remove();\n    }\n\n    return true;\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const objects = this._nodes;\n    const nodes = [];\n\n    for (const object of objects) {\n      const node = $getNodeByKey(object);\n\n      if (node !== null) {\n        nodes.push(node);\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction $isRangeSelection(x) {\n  return x instanceof RangeSelection;\n}\nfunction DEPRECATED_$getGridCellNodeRect(GridCellNode) {\n  const [CellNode,, GridNode] = DEPRECATED_$getNodeTriplet(GridCellNode);\n  const rows = GridNode.getChildren();\n  const rowCount = rows.length;\n  const columnCount = rows[0].getChildren().length; // Create a matrix of the same size as the table to track the position of each cell\n\n  const cellMatrix = new Array(rowCount);\n\n  for (let i = 0; i < rowCount; i++) {\n    cellMatrix[i] = new Array(columnCount);\n  }\n\n  for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {\n    const row = rows[rowIndex];\n    const cells = row.getChildren();\n    let columnIndex = 0;\n\n    for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n      // Find the next available position in the matrix, skip the position of merged cells\n      while (cellMatrix[rowIndex][columnIndex]) {\n        columnIndex++;\n      }\n\n      const cell = cells[cellIndex];\n      const rowSpan = cell.__rowSpan || 1;\n      const colSpan = cell.__colSpan || 1; // Put the cell into the corresponding position in the matrix\n\n      for (let i = 0; i < rowSpan; i++) {\n        for (let j = 0; j < colSpan; j++) {\n          cellMatrix[rowIndex + i][columnIndex + j] = cell;\n        }\n      } // Return to the original index, row span and column span of the cell.\n\n\n      if (CellNode === cell) {\n        return {\n          colSpan,\n          columnIndex,\n          rowIndex,\n          rowSpan\n        };\n      }\n\n      columnIndex += colSpan;\n    }\n  }\n\n  return null;\n}\nclass GridSelection {\n  constructor(gridKey, anchor, focus) {\n    this.gridKey = gridKey;\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n\n  is(selection) {\n    if (!DEPRECATED_$isGridSelection(selection)) {\n      return false;\n    }\n\n    return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);\n  }\n\n  set(gridKey, anchorCellKey, focusCellKey) {\n    this.dirty = true;\n    this.gridKey = gridKey;\n    this.anchor.key = anchorCellKey;\n    this.focus.key = focusCellKey;\n    this._cachedNodes = null;\n  }\n\n  clone() {\n    return new GridSelection(this.gridKey, this.anchor, this.focus);\n  }\n\n  isCollapsed() {\n    return false;\n  }\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n\n  extract() {\n    return this.getNodes();\n  }\n\n  insertRawText(text) {// Do nothing?\n  }\n\n  insertText() {// Do nothing?\n  }\n\n  insertNodes(nodes, selectStart) {\n    const focusNode = this.focus.getNode();\n    const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));\n    return selection.insertNodes(nodes, selectStart);\n  } // TODO Deprecate this method. It's confusing when used with colspan|rowspan\n\n\n  getShape() {\n    const anchorCellNode = $getNodeByKey(this.anchor.key);\n\n    if (!DEPRECATED_$isGridCellNode(anchorCellNode)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n\n    const anchorCellNodeRect = DEPRECATED_$getGridCellNodeRect(anchorCellNode);\n\n    if (!(anchorCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find AnchorNode`);\n    }\n\n    const focusCellNode = $getNodeByKey(this.focus.key);\n\n    if (!DEPRECATED_$isGridCellNode(focusCellNode)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n\n    const focusCellNodeRect = DEPRECATED_$getGridCellNodeRect(focusCellNode);\n\n    if (!(focusCellNodeRect !== null)) {\n      throw Error(`getCellRect: expected to find focusCellNode`);\n    }\n\n    const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);\n    const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);\n    return {\n      fromX: Math.min(startX, stopX),\n      fromY: Math.min(startY, stopY),\n      toX: Math.max(startX, stopX),\n      toY: Math.max(startY, stopY)\n    };\n  }\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchorNode = this.anchor.getNode();\n    const focusNode = this.focus.getNode();\n    const anchorCell = $findMatchingParent(anchorNode, DEPRECATED_$isGridCellNode); // todo replace with triplet\n\n    const focusCell = $findMatchingParent(focusNode, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(anchorCell)) {\n      throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);\n    }\n\n    if (!DEPRECATED_$isGridCellNode(focusCell)) {\n      throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);\n    }\n\n    const anchorRow = anchorCell.getParent();\n\n    if (!DEPRECATED_$isGridRowNode(anchorRow)) {\n      throw Error(`Expected anchorCell to have a parent GridRowNode`);\n    }\n\n    const gridNode = anchorRow.getParent();\n\n    if (!DEPRECATED_$isGridNode(gridNode)) {\n      throw Error(`Expected tableNode to have a parent GridNode`);\n    } // TODO Mapping the whole Grid every time not efficient. We need to compute the entire state only\n    // once (on load) and iterate on it as updates occur. However, to do this we need to have the\n    // ability to store a state. Killing GridSelection and moving the logic to the plugin would make\n    // this possible.\n\n\n    const [map, cellAMap, cellBMap] = DEPRECATED_$computeGridMap(gridNode, anchorCell, focusCell);\n    let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);\n    let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);\n    let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);\n    let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);\n    let exploredMinColumn = minColumn;\n    let exploredMinRow = minRow;\n    let exploredMaxColumn = minColumn;\n    let exploredMaxRow = minRow;\n\n    function expandBoundary(mapValue) {\n      const {\n        cell,\n        startColumn: cellStartColumn,\n        startRow: cellStartRow\n      } = mapValue;\n      minColumn = Math.min(minColumn, cellStartColumn);\n      minRow = Math.min(minRow, cellStartRow);\n      maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);\n      maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);\n    }\n\n    while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {\n      if (minColumn < exploredMinColumn) {\n        // Expand on the left\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const previousColumn = exploredMinColumn - 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][previousColumn]);\n        }\n\n        exploredMinColumn = previousColumn;\n      }\n\n      if (minRow < exploredMinRow) {\n        // Expand on top\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const previousRow = exploredMinRow - 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[previousRow][exploredMinColumn + i]);\n        }\n\n        exploredMinRow = previousRow;\n      }\n\n      if (maxColumn > exploredMaxColumn) {\n        // Expand on the right\n        const rowDiff = exploredMaxRow - exploredMinRow;\n        const nextColumn = exploredMaxColumn + 1;\n\n        for (let i = 0; i <= rowDiff; i++) {\n          expandBoundary(map[exploredMinRow + i][nextColumn]);\n        }\n\n        exploredMaxColumn = nextColumn;\n      }\n\n      if (maxRow > exploredMaxRow) {\n        // Expand on the bottom\n        const columnDiff = exploredMaxColumn - exploredMinColumn;\n        const nextRow = exploredMaxRow + 1;\n\n        for (let i = 0; i <= columnDiff; i++) {\n          expandBoundary(map[nextRow][exploredMinColumn + i]);\n        }\n\n        exploredMaxRow = nextRow;\n      }\n    }\n\n    const nodes = [gridNode];\n    let lastRow = null;\n\n    for (let i = minRow; i <= maxRow; i++) {\n      for (let j = minColumn; j <= maxColumn; j++) {\n        const {\n          cell\n        } = map[i][j];\n        const currentRow = cell.getParent();\n\n        if (!DEPRECATED_$isGridRowNode(currentRow)) {\n          throw Error(`Expected GridCellNode parent to be a GridRowNode`);\n        }\n\n        if (currentRow !== lastRow) {\n          nodes.push(currentRow);\n        }\n\n        nodes.push(cell, ...$getChildrenRecursively(cell));\n        lastRow = currentRow;\n      }\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n\n  getTextContent() {\n    const nodes = this.getNodes();\n    let textContent = '';\n\n    for (let i = 0; i < nodes.length; i++) {\n      textContent += nodes[i].getTextContent();\n    }\n\n    return textContent;\n  }\n\n}\nfunction DEPRECATED_$isGridSelection(x) {\n  return x instanceof GridSelection;\n}\nclass RangeSelection {\n  constructor(anchor, focus, format, style) {\n    this.anchor = anchor;\n    this.focus = focus;\n    this.dirty = false;\n    this.format = format;\n    this.style = style;\n    this._cachedNodes = null;\n    anchor._selection = this;\n    focus._selection = this;\n  }\n  /**\n   * Used to check if the provided selections is equal to this one by value,\n   * inluding anchor, focus, format, and style properties.\n   * @param selection - the Selection to compare this one to.\n   * @returns true if the Selections are equal, false otherwise.\n   */\n\n\n  is(selection) {\n    if (!$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;\n  }\n  /**\n   * Returns whether the Selection is \"backwards\", meaning the focus\n   * logically precedes the anchor in the EditorState.\n   * @returns true if the Selection is backwards, false otherwise.\n   */\n\n\n  isBackward() {\n    return this.focus.isBefore(this.anchor);\n  }\n  /**\n   * Returns whether the Selection is \"collapsed\", meaning the anchor and focus are\n   * the same node and have the same offset.\n   *\n   * @returns true if the Selection is collapsed, false otherwise.\n   */\n\n\n  isCollapsed() {\n    return this.anchor.is(this.focus);\n  }\n  /**\n   * Gets all the nodes in the Selection. Uses caching to make it generally suitable\n   * for use in hot paths.\n   *\n   * @returns an Array containing all the nodes in the Selection\n   */\n\n\n  getNodes() {\n    const cachedNodes = this._cachedNodes;\n\n    if (cachedNodes !== null) {\n      return cachedNodes;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const firstPoint = isBefore ? anchor : focus;\n    const lastPoint = isBefore ? focus : anchor;\n    let firstNode = firstPoint.getNode();\n    let lastNode = lastPoint.getNode();\n    const startOffset = firstPoint.offset;\n    const endOffset = lastPoint.offset;\n\n    if ($isElementNode(firstNode)) {\n      const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);\n      firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;\n    }\n\n    if ($isElementNode(lastNode)) {\n      let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset); // We don't want to over-select, as node selection infers the child before\n      // the last descendant, not including that descendant.\n\n      if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {\n        lastNodeDescendant = lastNodeDescendant.getPreviousSibling();\n      }\n\n      lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;\n    }\n\n    let nodes;\n\n    if (firstNode.is(lastNode)) {\n      if ($isElementNode(firstNode) && firstNode.getChildrenSize() > 0) {\n        nodes = [];\n      } else {\n        nodes = [firstNode];\n      }\n    } else {\n      nodes = firstNode.getNodesBetween(lastNode);\n    }\n\n    if (!isCurrentlyReadOnlyMode()) {\n      this._cachedNodes = nodes;\n    }\n\n    return nodes;\n  }\n  /**\n   * Sets this Selection to be of type \"text\" at the provided anchor and focus values.\n   *\n   * @param anchorNode - the anchor node to set on the Selection\n   * @param anchorOffset - the offset to set on the Selection\n   * @param focusNode - the focus node to set on the Selection\n   * @param focusOffset - the focus offset to set on the Selection\n   */\n\n\n  setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {\n    $setPointValues(this.anchor, anchorNode.__key, anchorOffset, 'text');\n    $setPointValues(this.focus, focusNode.__key, focusOffset, 'text');\n    this._cachedNodes = null;\n    this.dirty = true;\n  }\n  /**\n   * Gets the (plain) text content of all the nodes in the selection.\n   *\n   * @returns a string representing the text content of all the nodes in the Selection\n   */\n\n\n  getTextContent() {\n    const nodes = this.getNodes();\n\n    if (nodes.length === 0) {\n      return '';\n    }\n\n    const firstNode = nodes[0];\n    const lastNode = nodes[nodes.length - 1];\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = anchor.isBefore(focus);\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n    let textContent = '';\n    let prevWasElement = true;\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if ($isElementNode(node) && !node.isInline()) {\n        if (!prevWasElement) {\n          textContent += '\\n';\n        }\n\n        if (node.isEmpty()) {\n          prevWasElement = false;\n        } else {\n          prevWasElement = true;\n        }\n      } else {\n        prevWasElement = false;\n\n        if ($isTextNode(node)) {\n          let text = node.getTextContent();\n\n          if (node === firstNode) {\n            if (node === lastNode) {\n              if (anchor.type !== 'element' || focus.type !== 'element' || focus.offset === anchor.offset) {\n                text = anchorOffset < focusOffset ? text.slice(anchorOffset, focusOffset) : text.slice(focusOffset, anchorOffset);\n              }\n            } else {\n              text = isBefore ? text.slice(anchorOffset) : text.slice(focusOffset);\n            }\n          } else if (node === lastNode) {\n            text = isBefore ? text.slice(0, focusOffset) : text.slice(0, anchorOffset);\n          }\n\n          textContent += text;\n        } else if (($isDecoratorNode(node) || $isLineBreakNode(node)) && (node !== lastNode || !this.isCollapsed())) {\n          textContent += node.getTextContent();\n        }\n      }\n    }\n\n    return textContent;\n  }\n  /**\n   * Attempts to map a DOM selection range onto this Lexical Selection,\n   * setting the anchor, focus, and type accordingly\n   *\n   * @param range a DOM Selection range conforming to the StaticRange interface.\n   */\n\n\n  applyDOMRange(range) {\n    const editor = getActiveEditor();\n    const currentEditorState = editor.getEditorState();\n    const lastSelection = currentEditorState._selection;\n    const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);\n\n    if (resolvedSelectionPoints === null) {\n      return;\n    }\n\n    const [anchorPoint, focusPoint] = resolvedSelectionPoints;\n    $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);\n    $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);\n    this._cachedNodes = null;\n  }\n  /**\n   * Creates a new RangeSelection, copying over all the property values from this one.\n   *\n   * @returns a new RangeSelection with the same property values as this one.\n   */\n\n\n  clone() {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const selection = new RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);\n    return selection;\n  }\n  /**\n   * Toggles the provided format on all the TextNodes in the Selection.\n   *\n   * @param format a string TextFormatType to toggle on the TextNodes in the selection\n   */\n\n\n  toggleFormat(format) {\n    this.format = toggleTextFormatType(this.format, format, null);\n    this.dirty = true;\n  }\n  /**\n   * Sets the value of the style property on the Selection\n   *\n   * @param style - the style to set at the value of the style property.\n   */\n\n\n  setStyle(style) {\n    this.style = style;\n    this.dirty = true;\n  }\n  /**\n   * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection\n   * has the specified format.\n   *\n   * @param type the TextFormatType to check for.\n   * @returns true if the provided format is currently toggled on on the Selection, false otherwise.\n   */\n\n\n  hasFormat(type) {\n    const formatFlag = TEXT_TYPE_TO_FORMAT[type];\n    return (this.format & formatFlag) !== 0;\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection.\n   * converts tabs, newlines, and carriage returns into LexicalNodes.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertRawText(text) {\n    const parts = text.split(/(\\r?\\n|\\t)/);\n    const nodes = [];\n    const length = parts.length;\n\n    for (let i = 0; i < length; i++) {\n      const part = parts[i];\n\n      if (part === '\\n' || part === '\\r\\n') {\n        nodes.push($createLineBreakNode());\n      } else if (part === '\\t') {\n        nodes.push($createTabNode());\n      } else {\n        nodes.push($createTextNode(part));\n      }\n    }\n\n    this.insertNodes(nodes);\n  }\n  /**\n   * Attempts to insert the provided text into the EditorState at the current Selection as a new\n   * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.\n   *\n   * @param text the text to insert into the Selection\n   */\n\n\n  insertText(text) {\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBefore = this.isCollapsed() || anchor.isBefore(focus);\n    const format = this.format;\n    const style = this.style;\n\n    if (isBefore && anchor.type === 'element') {\n      $transferStartingElementPointToTextPoint(anchor, focus, format, style);\n    } else if (!isBefore && focus.type === 'element') {\n      $transferStartingElementPointToTextPoint(focus, anchor, format, style);\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const firstPoint = isBefore ? anchor : focus;\n    const endPoint = isBefore ? focus : anchor;\n    const startOffset = firstPoint.offset;\n    const endOffset = endPoint.offset;\n    let firstNode = selectedNodes[0];\n\n    if (!$isTextNode(firstNode)) {\n      {\n        throw Error(`insertText: first node is not a text node`);\n      }\n    }\n\n    const firstNodeText = firstNode.getTextContent();\n    const firstNodeTextLength = firstNodeText.length;\n    const firstNodeParent = firstNode.getParentOrThrow();\n    const lastIndex = selectedNodesLength - 1;\n    let lastNode = selectedNodes[lastIndex];\n\n    if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {\n      let nextSibling = firstNode.getNextSibling();\n\n      if (!$isTextNode(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {\n        nextSibling = $createTextNode();\n        nextSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextAfter()) {\n          firstNodeParent.insertAfter(nextSibling);\n        } else {\n          firstNode.insertAfter(nextSibling);\n        }\n      }\n\n      nextSibling.select(0, 0);\n      firstNode = nextSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {\n      let prevSibling = firstNode.getPreviousSibling();\n\n      if (!$isTextNode(prevSibling) || $isTokenOrSegmented(prevSibling)) {\n        prevSibling = $createTextNode();\n        prevSibling.setFormat(format);\n\n        if (!firstNodeParent.canInsertTextBefore()) {\n          firstNodeParent.insertBefore(prevSibling);\n        } else {\n          firstNode.insertBefore(prevSibling);\n        }\n      }\n\n      prevSibling.select();\n      firstNode = prevSibling;\n\n      if (text !== '') {\n        this.insertText(text);\n        return;\n      }\n    } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {\n      const textNode = $createTextNode(firstNode.getTextContent());\n      textNode.setFormat(format);\n      firstNode.replace(textNode);\n      firstNode = textNode;\n    } else if (!this.isCollapsed() && text !== '') {\n      // When the firstNode or lastNode parents are elements that\n      // do not allow text to be inserted before or after, we first\n      // clear the content. Then we normalize selection, then insert\n      // the new content.\n      const lastNodeParent = lastNode.getParent();\n\n      if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {\n        this.insertText('');\n        normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);\n        this.insertText(text);\n        return;\n      }\n    }\n\n    if (selectedNodesLength === 1) {\n      if (firstNode.isToken()) {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n        return;\n      }\n\n      const firstNodeFormat = firstNode.getFormat();\n      const firstNodeStyle = firstNode.getStyle();\n\n      if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {\n        if (firstNode.getTextContent() === '') {\n          firstNode.setFormat(format);\n          firstNode.setStyle(style);\n        } else {\n          const textNode = $createTextNode(text);\n          textNode.setFormat(format);\n          textNode.setStyle(style);\n          textNode.select();\n\n          if (startOffset === 0) {\n            firstNode.insertBefore(textNode, false);\n          } else {\n            const [targetNode] = firstNode.splitText(startOffset);\n            targetNode.insertAfter(textNode, false);\n          } // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n\n\n          if (textNode.isComposing() && this.anchor.type === 'text') {\n            this.anchor.offset -= text.length;\n          }\n\n          return;\n        }\n      }\n\n      const delCount = endOffset - startOffset;\n      firstNode = firstNode.spliceText(startOffset, delCount, text, true);\n\n      if (firstNode.getTextContent() === '') {\n        firstNode.remove();\n      } else if (this.anchor.type === 'text') {\n        if (firstNode.isComposing()) {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        } else {\n          this.format = firstNodeFormat;\n          this.style = firstNodeStyle;\n        }\n      }\n    } else {\n      const markedNodeKeysForKeep = new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]); // We have to get the parent elements before the next section,\n      // as in that section we might mutate the lastNode.\n\n      const firstElement = $isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n      let lastElement = $isElementNode(lastNode) ? lastNode : lastNode.getParentOrThrow();\n      let lastElementChild = lastNode; // If the last element is inline, we should instead look at getting\n      // the nodes of its parent, rather than itself. This behavior will\n      // then better match how text node insertions work. We will need to\n      // also update the last element's child accordingly as we do this.\n\n      if (!firstElement.is(lastElement) && lastElement.isInline()) {\n        // Keep traversing till we have a non-inline element parent.\n        do {\n          lastElementChild = lastElement;\n          lastElement = lastElement.getParentOrThrow();\n        } while (lastElement.isInline());\n      } // Handle mutations to the last node.\n\n\n      if (endPoint.type === 'text' && (endOffset !== 0 || lastNode.getTextContent() === '') || endPoint.type === 'element' && lastNode.getIndexWithinParent() < endOffset) {\n        if ($isTextNode(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {\n          if (lastNode.isSegmented()) {\n            const textNode = $createTextNode(lastNode.getTextContent());\n            lastNode.replace(textNode);\n            lastNode = textNode;\n          } // root node selections only select whole nodes, so no text splice is necessary\n\n\n          if (!$isRootNode(endPoint.getNode())) {\n            lastNode = lastNode.spliceText(0, endOffset, '');\n          }\n\n          markedNodeKeysForKeep.add(lastNode.__key);\n        } else {\n          const lastNodeParent = lastNode.getParentOrThrow();\n\n          if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {\n            lastNodeParent.remove();\n          } else {\n            lastNode.remove();\n          }\n        }\n      } else {\n        markedNodeKeysForKeep.add(lastNode.__key);\n      } // Either move the remaining nodes of the last parent to after\n      // the first child, or remove them entirely. If the last parent\n      // is the same as the first parent, this logic also works.\n\n\n      const lastNodeChildren = lastElement.getChildren();\n      const selectedNodesSet = new Set(selectedNodes);\n      const firstAndLastElementsAreEqual = firstElement.is(lastElement); // We choose a target to insert all nodes after. In the case of having\n      // and inline starting parent element with a starting node that has no\n      // siblings, we should insert after the starting parent element, otherwise\n      // we will incorrectly merge into the starting parent element.\n      // TODO: should we keep on traversing parents if we're inside another\n      // nested inline element?\n\n      const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;\n\n      for (let i = lastNodeChildren.length - 1; i >= 0; i--) {\n        const lastNodeChild = lastNodeChildren[i];\n\n        if (lastNodeChild.is(firstNode) || $isElementNode(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {\n          break;\n        }\n\n        if (lastNodeChild.isAttached()) {\n          if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {\n            if (!firstAndLastElementsAreEqual) {\n              insertionTarget.insertAfter(lastNodeChild, false);\n            }\n          } else {\n            lastNodeChild.remove();\n          }\n        }\n      }\n\n      if (!firstAndLastElementsAreEqual) {\n        // Check if we have already moved out all the nodes of the\n        // last parent, and if so, traverse the parent tree and mark\n        // them all as being able to deleted too.\n        let parent = lastElement;\n        let lastRemovedParent = null;\n\n        while (parent !== null) {\n          const children = parent.getChildren();\n          const childrenLength = children.length;\n\n          if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {\n            markedNodeKeysForKeep.delete(parent.__key);\n            lastRemovedParent = parent;\n          }\n\n          parent = parent.getParent();\n        }\n      } // Ensure we do splicing after moving of nodes, as splicing\n      // can have side-effects (in the case of hashtags).\n\n\n      if (!firstNode.isToken()) {\n        firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text, true);\n\n        if (firstNode.getTextContent() === '') {\n          firstNode.remove();\n        } else if (firstNode.isComposing() && this.anchor.type === 'text') {\n          // When composing, we need to adjust the anchor offset so that\n          // we correctly replace that right range.\n          this.anchor.offset -= text.length;\n        }\n      } else if (startOffset === firstNodeTextLength) {\n        firstNode.select();\n      } else {\n        const textNode = $createTextNode(text);\n        textNode.select();\n        firstNode.replace(textNode);\n      } // Remove all selected nodes that haven't already been removed.\n\n\n      for (let i = 1; i < selectedNodesLength; i++) {\n        const selectedNode = selectedNodes[i];\n        const key = selectedNode.__key;\n\n        if (!markedNodeKeysForKeep.has(key)) {\n          selectedNode.remove();\n        }\n      }\n    }\n  }\n  /**\n   * Removes the text in the Selection, adjusting the EditorState accordingly.\n   */\n\n\n  removeText() {\n    this.insertText('');\n  }\n  /**\n   * Applies the provided format to the TextNodes in the Selection, splitting or\n   * merging nodes as necessary.\n   *\n   * @param formatType the format type to apply to the nodes in the Selection.\n   */\n\n\n  formatText(formatType) {\n    if (this.isCollapsed()) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const selectedNodes = this.getNodes();\n    const selectedTextNodes = [];\n\n    for (const selectedNode of selectedNodes) {\n      if ($isTextNode(selectedNode)) {\n        selectedTextNodes.push(selectedNode);\n      }\n    }\n\n    const selectedTextNodesLength = selectedTextNodes.length;\n\n    if (selectedTextNodesLength === 0) {\n      this.toggleFormat(formatType); // When changing format, we should stop composition\n\n      $setCompositionKey(null);\n      return;\n    }\n\n    const anchor = this.anchor;\n    const focus = this.focus;\n    const isBackward = this.isBackward();\n    const startPoint = isBackward ? focus : anchor;\n    const endPoint = isBackward ? anchor : focus;\n    let firstIndex = 0;\n    let firstNode = selectedTextNodes[0];\n    let startOffset = startPoint.type === 'element' ? 0 : startPoint.offset; // In case selection started at the end of text node use next text node\n\n    if (startPoint.type === 'text' && startOffset === firstNode.getTextContentSize()) {\n      firstIndex = 1;\n      firstNode = selectedTextNodes[1];\n      startOffset = 0;\n    }\n\n    if (firstNode == null) {\n      return;\n    }\n\n    const firstNextFormat = firstNode.getFormatFlags(formatType, null);\n    const lastIndex = selectedTextNodesLength - 1;\n    let lastNode = selectedTextNodes[lastIndex];\n    const endOffset = endPoint.type === 'text' ? endPoint.offset : lastNode.getTextContentSize(); // Single node selected\n\n    if (firstNode.is(lastNode)) {\n      // No actual text is selected, so do nothing.\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {\n        firstNode.setFormat(firstNextFormat);\n      } else {\n        // Node is partially selected, so split it into two nodes\n        // add style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        replacement.setFormat(firstNextFormat); // Update selection only if starts/ends on text node\n\n        if (startPoint.type === 'text') {\n          startPoint.set(replacement.__key, 0, 'text');\n        }\n\n        if (endPoint.type === 'text') {\n          endPoint.set(replacement.__key, endOffset - startOffset, 'text');\n        }\n      }\n\n      this.format = firstNextFormat;\n      return;\n    } // Multiple nodes selected\n    // The entire first node isn't selected, so split it\n\n\n    if (startOffset !== 0) {\n      [, firstNode] = firstNode.splitText(startOffset);\n      startOffset = 0;\n    }\n\n    firstNode.setFormat(firstNextFormat);\n    const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat); // If the offset is 0, it means no actual characters are selected,\n    // so we skip formatting the last node altogether.\n\n    if (endOffset > 0) {\n      if (endOffset !== lastNode.getTextContentSize()) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      lastNode.setFormat(lastNextFormat);\n    } // Process all text nodes in between\n\n\n    for (let i = firstIndex + 1; i < lastIndex; i++) {\n      const textNode = selectedTextNodes[i];\n\n      if (!textNode.isToken()) {\n        const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);\n        textNode.setFormat(nextFormat);\n      }\n    } // Update selection only if starts/ends on text node\n\n\n    if (startPoint.type === 'text') {\n      startPoint.set(firstNode.__key, startOffset, 'text');\n    }\n\n    if (endPoint.type === 'text') {\n      endPoint.set(lastNode.__key, endOffset, 'text');\n    }\n\n    this.format = firstNextFormat | lastNextFormat;\n  }\n  /**\n   * Attempts to \"intelligently\" insert an arbitrary list of Lexical nodes into the EditorState at the\n   * current Selection according to a set of heuristics that determine how surrounding nodes\n   * should be changed, replaced, or moved to accomodate the incoming ones.\n   *\n   * @param nodes - the nodes to insert\n   * @param selectStart - whether or not to select the start after the insertion.\n   * @returns true if the nodes were inserted successfully, false otherwise.\n   */\n\n\n  insertNodes(nodes, selectStart) {\n    // If there is a range selected remove the text in it\n    if (!this.isCollapsed()) {\n      const selectionEnd = this.isBackward() ? this.anchor : this.focus;\n      const nextSibling = selectionEnd.getNode().getNextSibling();\n      const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;\n      const prevSibling = selectionEnd.getNode().getPreviousSibling();\n      const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;\n      this.removeText(); // If the selection has been moved to an adjacent inline element, create\n      // a temporary text node that we can insert the nodes after.\n\n      if (this.isCollapsed() && this.focus.type === 'element') {\n        let textNode;\n\n        if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertBefore(textNode);\n        } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {\n          textNode = $createTextNode();\n          this.focus.getNode().insertAfter(textNode);\n        }\n\n        if (textNode) {\n          this.focus.set(textNode.__key, 0, 'text');\n          this.anchor.set(textNode.__key, 0, 'text');\n        }\n      }\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    const anchorNode = anchor.getNode();\n    let target = anchorNode;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n      const placementNode = element.getChildAtIndex(anchorOffset - 1);\n\n      if (placementNode === null) {\n        target = element;\n      } else {\n        target = placementNode;\n      }\n    }\n\n    const siblings = []; // Get all remaining text node siblings in this element so we can\n    // append them after the last node we're inserting.\n\n    const nextSiblings = anchorNode.getNextSiblings();\n    const topLevelElement = $isRootOrShadowRoot(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();\n\n    if ($isTextNode(anchorNode)) {\n      const textContent = anchorNode.getTextContent();\n      const textContentLength = textContent.length;\n\n      if (anchorOffset === 0 && textContentLength !== 0) {\n        const prevSibling = anchorNode.getPreviousSibling();\n\n        if (prevSibling !== null) {\n          target = prevSibling;\n        } else {\n          target = anchorNode.getParentOrThrow();\n        }\n\n        siblings.push(anchorNode);\n      } else if (anchorOffset === textContentLength) {\n        target = anchorNode;\n      } else if (anchorNode.isToken()) {\n        // Do nothing if we're inside a token node\n        return false;\n      } else {\n        // If we started with a range selected grab the danglingText after the\n        // end of the selection and put it on our siblings array so we can\n        // append it after the last node we're inserting\n        let danglingText;\n        [target, danglingText] = anchorNode.splitText(anchorOffset);\n        siblings.push(danglingText);\n      }\n    }\n\n    const startingNode = target;\n    siblings.push(...nextSiblings);\n    const firstNode = nodes[0];\n    let didReplaceOrMerge = false;\n    let lastNode = null; // Time to insert the nodes!\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (!$isRootOrShadowRoot(target) && !$isDecoratorNode(target) && $isElementNode(node) && !node.isInline()) {\n        // -----\n        // Heuristics for the replacement or merging of elements\n        // -----\n        // If we have an incoming element node as the first node, then we'll need\n        // see if we can merge any descendant leaf nodes into our existing target.\n        // We can do this by finding the first descendant in our node and then we can\n        // pluck it and its parent (siblings included) out and insert them directly\n        // into our target. We only do this for the first node, as we are only\n        // interested in merging with the anchor, which is our target.\n        //\n        // If we apply either the replacement or merging heuristics, we need to be\n        // careful that we're not trying to insert a non-element node into a root node,\n        // so we check if the target's parent after this logic is the root node and if\n        // so we trigger an invariant to ensure this problem is caught in development\n        // and fixed accordingly.\n        if (node.is(firstNode)) {\n          if ($isElementNode(target) && target.isEmpty() && target.canReplaceWith(node)) {\n            target.replace(node);\n            target = node;\n            didReplaceOrMerge = true;\n            continue;\n          } // We may have a node tree where there are many levels, for example with\n          // lists and tables. So let's find the first descendant to try and merge\n          // with. So if we have the target:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //\n          // and we are trying to insert:\n          //\n          // ListNode (3)\n          //   ListItemNode (4)\n          //     Text (5)\n          //   ListItemNode (6)\n          //\n          // The result would be:\n          //\n          // Paragraph (1)\n          //   Text (2)\n          //   Text (5)\n          //\n\n\n          const firstDescendant = node.getFirstDescendant();\n\n          if ($isLeafNode(firstDescendant)) {\n            let element = firstDescendant.getParentOrThrow();\n\n            while (element.isInline()) {\n              element = element.getParentOrThrow();\n            }\n\n            const children = element.getChildren();\n            const childrenLength = children.length;\n\n            if ($isElementNode(target)) {\n              let firstChild = target.getFirstChild();\n\n              for (let s = 0; s < childrenLength; s++) {\n                const child = children[s];\n\n                if (firstChild === null) {\n                  target.append(child);\n                } else {\n                  firstChild.insertAfter(child);\n                }\n\n                firstChild = child;\n              }\n            } else {\n              for (let s = childrenLength - 1; s >= 0; s--) {\n                target.insertAfter(children[s]);\n              }\n\n              target = target.getParentOrThrow();\n            }\n\n            lastNode = children[childrenLength - 1];\n            element.remove();\n            didReplaceOrMerge = true;\n\n            if (element.is(node)) {\n              continue;\n            }\n          }\n        }\n\n        if ($isTextNode(target)) {\n          if (topLevelElement === null) {\n            {\n              throw Error(`insertNode: topLevelElement is root node`);\n            }\n          }\n\n          target = topLevelElement;\n        }\n      } else if (didReplaceOrMerge && !$isElementNode(node) && !$isDecoratorNode(node) && $isRootOrShadowRoot(target.getParent())) {\n        {\n          throw Error(`insertNodes: cannot insert a non-element into a root node`);\n        }\n      }\n\n      didReplaceOrMerge = false;\n\n      if ($isElementNode(target) && !target.isInline()) {\n        lastNode = node;\n\n        if ($isDecoratorNode(node) && !node.isInline()) {\n          if (nodes.length === 1 && target.canBeEmpty() && target.isEmpty()) {\n            target = target.insertBefore(node, false);\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        } else if (!$isElementNode(node)) {\n          const firstChild = target.getFirstChild();\n\n          if (firstChild !== null) {\n            firstChild.insertBefore(node);\n          } else {\n            target.append(node);\n          }\n\n          target = node;\n        } else {\n          if (!node.canBeEmpty() && node.isEmpty()) {\n            continue;\n          }\n\n          if ($isRootNode(target)) {\n            const placementNode = target.getChildAtIndex(anchorOffset);\n\n            if (placementNode !== null) {\n              placementNode.insertBefore(node);\n            } else {\n              target.append(node);\n            }\n\n            target = node;\n          } else if (node.isInline()) {\n            target.append(node);\n            target = node;\n          } else {\n            target = target.insertAfter(node, false);\n          }\n        }\n      } else if (!$isElementNode(node) || $isElementNode(node) && node.isInline() || $isDecoratorNode(target) && !target.isInline()) {\n        lastNode = node; // when pasting top level node in the middle of paragraph\n        // we need to split paragraph instead of placing it inline\n\n        if ($isRangeSelection(this) && $isDecoratorNode(node) && ($isElementNode(target) || $isTextNode(target)) && !node.isInline()) {\n          let splitNode;\n          let splitOffset;\n\n          if ($isTextNode(target)) {\n            splitNode = target.getParentOrThrow();\n            const [textNode] = target.splitText(anchorOffset);\n            splitOffset = textNode.getIndexWithinParent() + 1;\n          } else {\n            splitNode = target;\n            splitOffset = anchorOffset;\n          }\n\n          const [, rightTree] = $splitNode(splitNode, splitOffset);\n          target = rightTree.insertBefore(node);\n        } else {\n          target = target.insertAfter(node, false);\n        }\n      } else {\n        const nextTarget = target.getParentOrThrow(); // if we're inserting an Element after a LineBreak, we want to move the target to the parent\n        // and remove the LineBreak so we don't have empty space.\n\n        if ($isLineBreakNode(target)) {\n          target.remove();\n        }\n\n        target = nextTarget; // Re-try again with the target being the parent\n\n        i--;\n        continue;\n      }\n    }\n\n    if (selectStart) {\n      // Handle moving selection to start for all nodes\n      if ($isTextNode(startingNode)) {\n        startingNode.select();\n      } else {\n        const prevSibling = target.getPreviousSibling();\n\n        if ($isTextNode(prevSibling)) {\n          prevSibling.select();\n        } else {\n          const index = target.getIndexWithinParent();\n          target.getParentOrThrow().select(index, index);\n        }\n      }\n    }\n\n    if ($isElementNode(target)) {\n      // If the last node to be inserted was a text node,\n      // then we should attempt to move selection to that.\n      const lastChild = $isTextNode(lastNode) ? lastNode : $isElementNode(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();\n\n      if (!selectStart) {\n        // Handle moving selection to end for elements\n        if (lastChild === null) {\n          target.select();\n        } else if ($isTextNode(lastChild)) {\n          if (lastChild.getTextContent() === '') {\n            lastChild.selectPrevious();\n          } else {\n            lastChild.select();\n          }\n        } else {\n          lastChild.selectNext();\n        }\n      }\n\n      if (siblings.length !== 0) {\n        const originalTarget = target;\n\n        for (let i = siblings.length - 1; i >= 0; i--) {\n          const sibling = siblings[i];\n          const prevParent = sibling.getParentOrThrow();\n\n          if ($isElementNode(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode(sibling) && ( // Note: We are only looking for decorators that are inline and not isolated.\n          !sibling.isInline() || sibling.isIsolated()))) {\n            if (originalTarget === target) {\n              target.append(sibling);\n            } else {\n              target.insertBefore(sibling);\n            }\n\n            target = sibling;\n          } else if (!$isElementNode(target) && !$isBlockElementNode(sibling)) {\n            target.insertBefore(sibling);\n            target = sibling;\n          } else {\n            if ($isElementNode(sibling) && !sibling.canInsertAfter(target)) {\n              // @ts-ignore The clone method does exist on the constructor.\n              const prevParentClone = prevParent.constructor.clone(prevParent);\n\n              if (!$isElementNode(prevParentClone)) {\n                {\n                  throw Error(`insertNodes: cloned parent clone is not an element`);\n                }\n              }\n\n              prevParentClone.append(sibling);\n              target.insertAfter(prevParentClone);\n            } else {\n              target.insertAfter(sibling);\n            }\n          } // Check if the prev parent is empty, as it might need\n          // removing.\n\n\n          if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {\n            prevParent.remove();\n          }\n        }\n      }\n    } else if (!selectStart) {\n      // Handle moving selection to end for other nodes\n      if ($isTextNode(target)) {\n        target.select();\n      } else {\n        const element = target.getParentOrThrow();\n        const index = target.getIndexWithinParent() + 1;\n        element.select(index, index);\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Inserts a new ParagraphNode into the EditorState at the current Selection\n   */\n\n\n  insertParagraph() {\n    if (!this.isCollapsed()) {\n      this.removeText();\n    }\n\n    const anchor = this.anchor;\n    const anchorOffset = anchor.offset;\n    let currentElement;\n    let nodesToMove = [];\n    let siblingsToMove = [];\n\n    if (anchor.type === 'text') {\n      const anchorNode = anchor.getNode();\n      nodesToMove = anchorNode.getNextSiblings().reverse();\n      currentElement = anchorNode.getParentOrThrow();\n      const isInline = currentElement.isInline();\n      const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();\n\n      if (anchorOffset === 0) {\n        nodesToMove.push(anchorNode);\n      } else {\n        if (isInline) {\n          // For inline nodes, we want to move all the siblings to the new paragraph\n          // if selection is at the end, we just move the siblings. Otherwise, we also\n          // split the text node and add that and it's siblings below.\n          siblingsToMove = currentElement.getNextSiblings();\n        }\n\n        if (anchorOffset !== textContentLength) {\n          if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {\n            const [, splitNode] = anchorNode.splitText(anchorOffset);\n            nodesToMove.push(splitNode);\n          }\n        }\n      }\n    } else {\n      currentElement = anchor.getNode();\n\n      if ($isRootOrShadowRoot(currentElement)) {\n        const paragraph = $createParagraphNode();\n        const child = currentElement.getChildAtIndex(anchorOffset);\n        paragraph.select();\n\n        if (child !== null) {\n          child.insertBefore(paragraph, false);\n        } else {\n          currentElement.append(paragraph);\n        }\n\n        return;\n      }\n\n      nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();\n    }\n\n    const nodesToMoveLength = nodesToMove.length;\n\n    if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {\n      const parent = currentElement.getParentOrThrow();\n      const newElement = parent.insertNewAfter(this, false);\n\n      if ($isElementNode(newElement)) {\n        const children = parent.getChildren();\n\n        for (let i = 0; i < children.length; i++) {\n          newElement.append(children[i]);\n        }\n      }\n\n      return;\n    }\n\n    const newElement = currentElement.insertNewAfter(this, false);\n\n    if (newElement === null) {\n      // Handle as a line break insertion\n      this.insertLineBreak();\n    } else if ($isElementNode(newElement)) {\n      // If we're at the beginning of the current element, move the new element to be before the current element\n      const currentElementFirstChild = currentElement.getFirstChild();\n      const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));\n\n      if (isBeginning && nodesToMoveLength > 0) {\n        currentElement.insertBefore(newElement);\n        return;\n      }\n\n      let firstChild = null;\n      const siblingsToMoveLength = siblingsToMove.length;\n      const parent = newElement.getParentOrThrow(); // For inline elements, we append the siblings to the parent.\n\n      if (siblingsToMoveLength > 0) {\n        for (let i = 0; i < siblingsToMoveLength; i++) {\n          const siblingToMove = siblingsToMove[i];\n          parent.append(siblingToMove);\n        }\n      }\n\n      if (nodesToMoveLength !== 0) {\n        for (let i = 0; i < nodesToMoveLength; i++) {\n          const nodeToMove = nodesToMove[i];\n\n          if (firstChild === null) {\n            newElement.append(nodeToMove);\n          } else {\n            firstChild.insertBefore(nodeToMove);\n          }\n\n          firstChild = nodeToMove;\n        }\n      }\n\n      if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {\n        newElement.selectPrevious();\n        newElement.remove();\n      } else {\n        newElement.selectStart();\n      }\n    }\n  }\n  /**\n   * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the\n   * current Selection.\n   *\n   * @param selectStart whether or not to select the start of the insertion range after the operation completes.\n   */\n\n\n  insertLineBreak(selectStart) {\n    const lineBreakNode = $createLineBreakNode();\n    const anchor = this.anchor;\n\n    if (anchor.type === 'element') {\n      const element = anchor.getNode();\n\n      if ($isRootNode(element)) {\n        this.insertParagraph();\n      }\n    }\n\n    if (selectStart) {\n      this.insertNodes([lineBreakNode], true);\n    } else {\n      if (this.insertNodes([lineBreakNode])) {\n        lineBreakNode.selectNext(0, 0);\n      }\n    }\n  }\n  /**\n   * Returns the character-based offsets of the Selection, accounting for non-text Points\n   * by using the children size or text content.\n   *\n   * @returns the character offsets for the Selection\n   */\n\n\n  getCharacterOffsets() {\n    return getCharacterOffsets(this);\n  }\n  /**\n   * Extracts the nodes in the Selection, splitting nodes where necessary\n   * to get offset-level precision.\n   *\n   * @returns The nodes in the Selection\n   */\n\n\n  extract() {\n    const selectedNodes = this.getNodes();\n    const selectedNodesLength = selectedNodes.length;\n    const lastIndex = selectedNodesLength - 1;\n    const anchor = this.anchor;\n    const focus = this.focus;\n    let firstNode = selectedNodes[0];\n    let lastNode = selectedNodes[lastIndex];\n    const [anchorOffset, focusOffset] = getCharacterOffsets(this);\n\n    if (selectedNodesLength === 0) {\n      return [];\n    } else if (selectedNodesLength === 1) {\n      if ($isTextNode(firstNode) && !this.isCollapsed()) {\n        const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        return node != null ? [node] : [];\n      }\n\n      return [firstNode];\n    }\n\n    const isBefore = anchor.isBefore(focus);\n\n    if ($isTextNode(firstNode)) {\n      const startOffset = isBefore ? anchorOffset : focusOffset;\n\n      if (startOffset === firstNode.getTextContentSize()) {\n        selectedNodes.shift();\n      } else if (startOffset !== 0) {\n        [, firstNode] = firstNode.splitText(startOffset);\n        selectedNodes[0] = firstNode;\n      }\n    }\n\n    if ($isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length;\n      const endOffset = isBefore ? focusOffset : anchorOffset;\n\n      if (endOffset === 0) {\n        selectedNodes.pop();\n      } else if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n        selectedNodes[lastIndex] = lastNode;\n      }\n    }\n\n    return selectedNodes;\n  }\n  /**\n   * Modifies the Selection according to the parameters and a set of heuristics that account for\n   * various node types. Can be used to safely move or extend selection by one logical \"unit\" without\n   * dealing explicitly with all the possible node types.\n   *\n   * @param alter the type of modification to perform\n   * @param isBackward whether or not selection is backwards\n   * @param granularity the granularity at which to apply the modification\n   */\n\n\n  modify(alter, isBackward, granularity) {\n    const focus = this.focus;\n    const anchor = this.anchor;\n    const collapse = alter === 'move'; // Handle the selection movement around decorators.\n\n    const possibleNode = $getAdjacentNode(focus, isBackward);\n\n    if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n      // Make it possible to move selection from range selection to\n      // node selection on the node.\n      if (collapse && possibleNode.isKeyboardSelectable()) {\n        const nodeSelection = $createNodeSelection();\n        nodeSelection.add(possibleNode.__key);\n        $setSelection(nodeSelection);\n        return;\n      }\n\n      const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();\n\n      if (!$isTextNode(sibling)) {\n        const parent = possibleNode.getParentOrThrow();\n        let offset;\n        let elementKey;\n\n        if ($isElementNode(sibling)) {\n          elementKey = sibling.__key;\n          offset = isBackward ? sibling.getChildrenSize() : 0;\n        } else {\n          offset = possibleNode.getIndexWithinParent();\n          elementKey = parent.__key;\n\n          if (!isBackward) {\n            offset++;\n          }\n        }\n\n        focus.set(elementKey, offset, 'element');\n\n        if (collapse) {\n          anchor.set(elementKey, offset, 'element');\n        }\n\n        return;\n      } else {\n        const siblingKey = sibling.__key;\n        const offset = isBackward ? sibling.getTextContent().length : 0;\n        focus.set(siblingKey, offset, 'text');\n\n        if (collapse) {\n          anchor.set(siblingKey, offset, 'text');\n        }\n\n        return;\n      }\n    }\n\n    const editor = getActiveEditor();\n    const domSelection = getDOMSelection(editor._window);\n\n    if (!domSelection) {\n      return;\n    }\n\n    const blockCursorElement = editor._blockCursorElement;\n    const rootElement = editor._rootElement; // Remove the block cursor element if it exists. This will ensure selection\n    // works as intended. If we leave it in the DOM all sorts of strange bugs\n    // occur. :/\n\n    if (rootElement !== null && blockCursorElement !== null && $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {\n      removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n    } // We use the DOM selection.modify API here to \"tell\" us what the selection\n    // will be. We then use it to update the Lexical selection accordingly. This\n    // is much more reliable than waiting for a beforeinput and using the ranges\n    // from getTargetRanges(), and is also better than trying to do it ourselves\n    // using Intl.Segmenter or other workarounds that struggle with word segments\n    // and line segments (especially with word wrapping and non-Roman languages).\n\n\n    moveNativeSelection(domSelection, alter, isBackward ? 'backward' : 'forward', granularity); // Guard against no ranges\n\n    if (domSelection.rangeCount > 0) {\n      const range = domSelection.getRangeAt(0); // Apply the DOM selection to our Lexical selection.\n\n      const anchorNode = this.anchor.getNode();\n      const root = $isRootNode(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);\n      this.applyDOMRange(range);\n      this.dirty = true;\n\n      if (!collapse) {\n        // Validate selection; make sure that the new extended selection respects shadow roots\n        const nodes = this.getNodes();\n        const validNodes = [];\n        let shrinkSelection = false;\n\n        for (let i = 0; i < nodes.length; i++) {\n          const nextNode = nodes[i];\n\n          if ($hasAncestor(nextNode, root)) {\n            validNodes.push(nextNode);\n          } else {\n            shrinkSelection = true;\n          }\n        }\n\n        if (shrinkSelection && validNodes.length > 0) {\n          // validNodes length check is a safeguard against an invalid selection; as getNodes()\n          // will return an empty array in this case\n          if (isBackward) {\n            const firstValidNode = validNodes[0];\n\n            if ($isElementNode(firstValidNode)) {\n              firstValidNode.selectStart();\n            } else {\n              firstValidNode.getParentOrThrow().selectStart();\n            }\n          } else {\n            const lastValidNode = validNodes[validNodes.length - 1];\n\n            if ($isElementNode(lastValidNode)) {\n              lastValidNode.selectEnd();\n            } else {\n              lastValidNode.getParentOrThrow().selectEnd();\n            }\n          }\n        } // Because a range works on start and end, we might need to flip\n        // the anchor and focus points to match what the DOM has, not what\n        // the range has specifically.\n\n\n        if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {\n          $swapPoints(this);\n        }\n      }\n    }\n  }\n  /**\n   * Performs one logical character deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteCharacter(isBackward) {\n    const wasCollapsed = this.isCollapsed();\n\n    if (this.isCollapsed()) {\n      const anchor = this.anchor;\n      const focus = this.focus;\n      let anchorNode = anchor.getNode();\n\n      if (!isBackward && ( // Delete forward handle case\n      anchor.type === 'element' && $isElementNode(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === 'text' && anchor.offset === anchorNode.getTextContentSize())) {\n        const parent = anchorNode.getParent();\n        const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());\n\n        if ($isElementNode(nextSibling) && nextSibling.isShadowRoot()) {\n          return;\n        }\n      } // Handle the deletion around decorators.\n\n\n      const possibleNode = $getAdjacentNode(focus, isBackward);\n\n      if ($isDecoratorNode(possibleNode) && !possibleNode.isIsolated()) {\n        // Make it possible to move selection from range selection to\n        // node selection on the node.\n        if (possibleNode.isKeyboardSelectable() && $isElementNode(anchorNode) && anchorNode.getChildrenSize() === 0) {\n          anchorNode.remove();\n          const nodeSelection = $createNodeSelection();\n          nodeSelection.add(possibleNode.__key);\n          $setSelection(nodeSelection);\n        } else {\n          possibleNode.remove();\n          const editor = getActiveEditor();\n          editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n        }\n\n        return;\n      } else if (!isBackward && $isElementNode(possibleNode) && $isElementNode(anchorNode) && anchorNode.isEmpty()) {\n        anchorNode.remove();\n        possibleNode.selectStart();\n        return;\n      }\n\n      this.modify('extend', isBackward, 'character');\n\n      if (!this.isCollapsed()) {\n        const focusNode = focus.type === 'text' ? focus.getNode() : null;\n        anchorNode = anchor.type === 'text' ? anchor.getNode() : null;\n\n        if (focusNode !== null && focusNode.isSegmented()) {\n          const offset = focus.offset;\n          const textContentSize = focusNode.getTextContentSize();\n\n          if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {\n            $removeSegment(focusNode, isBackward, offset);\n            return;\n          }\n        } else if (anchorNode !== null && anchorNode.isSegmented()) {\n          const offset = anchor.offset;\n          const textContentSize = anchorNode.getTextContentSize();\n\n          if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {\n            $removeSegment(anchorNode, isBackward, offset);\n            return;\n          }\n        }\n\n        $updateCaretSelectionForUnicodeCharacter(this, isBackward);\n      } else if (isBackward && anchor.offset === 0) {\n        // Special handling around rich text nodes\n        const element = anchor.type === 'element' ? anchor.getNode() : anchor.getNode().getParentOrThrow();\n\n        if (element.collapseAtStart(this)) {\n          return;\n        }\n      }\n    }\n\n    this.removeText();\n\n    if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === 'element' && this.anchor.offset === 0) {\n      const anchorNode = this.anchor.getNode();\n\n      if (anchorNode.isEmpty() && $isRootNode(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {\n        anchorNode.collapseAtStart(this);\n      }\n    }\n  }\n  /**\n   * Performs one logical line deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteLine(isBackward) {\n    if (this.isCollapsed()) {\n      if (this.anchor.type === 'text') {\n        this.modify('extend', isBackward, 'lineboundary');\n      } // If selection is extended to cover text edge then extend it one character more\n      // to delete its parent element. Otherwise text content will be deleted but empty\n      // parent node will remain\n\n\n      const endPoint = isBackward ? this.focus : this.anchor;\n\n      if (endPoint.offset === 0) {\n        this.modify('extend', isBackward, 'character');\n      }\n    }\n\n    this.removeText();\n  }\n  /**\n   * Performs one logical word deletion operation on the EditorState based on the current Selection.\n   * Handles different node types.\n   *\n   * @param isBackward whether or not the selection is backwards.\n   */\n\n\n  deleteWord(isBackward) {\n    if (this.isCollapsed()) {\n      this.modify('extend', isBackward, 'word');\n    }\n\n    this.removeText();\n  }\n\n}\nfunction $isNodeSelection(x) {\n  return x instanceof NodeSelection;\n}\n\nfunction getCharacterOffset(point) {\n  const offset = point.offset;\n\n  if (point.type === 'text') {\n    return offset;\n  }\n\n  const parent = point.getNode();\n  return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;\n}\n\nfunction getCharacterOffsets(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n\n  if (anchor.type === 'element' && focus.type === 'element' && anchor.key === focus.key && anchor.offset === focus.offset) {\n    return [0, 0];\n  }\n\n  return [getCharacterOffset(anchor), getCharacterOffset(focus)];\n}\n\nfunction $swapPoints(selection) {\n  const focus = selection.focus;\n  const anchor = selection.anchor;\n  const anchorKey = anchor.key;\n  const anchorOffset = anchor.offset;\n  const anchorType = anchor.type;\n  $setPointValues(anchor, focus.key, focus.offset, focus.type);\n  $setPointValues(focus, anchorKey, anchorOffset, anchorType);\n  selection._cachedNodes = null;\n}\n\nfunction moveNativeSelection(domSelection, alter, direction, granularity) {\n  // Selection.modify() method applies a change to the current selection or cursor position,\n  // but is still non-standard in some browsers.\n  domSelection.modify(alter, direction, granularity);\n}\n\nfunction $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (anchorNode === focusNode && anchor.type === 'text' && focus.type === 'text') {\n    // Handling of multibyte characters\n    const anchorOffset = anchor.offset;\n    const focusOffset = focus.offset;\n    const isBefore = anchorOffset < focusOffset;\n    const startOffset = isBefore ? anchorOffset : focusOffset;\n    const endOffset = isBefore ? focusOffset : anchorOffset;\n    const characterOffset = endOffset - 1;\n\n    if (startOffset !== characterOffset) {\n      const text = anchorNode.getTextContent().slice(startOffset, endOffset);\n\n      if (!doesContainGrapheme(text)) {\n        if (isBackward) {\n          focus.offset = characterOffset;\n        } else {\n          anchor.offset = characterOffset;\n        }\n      }\n    }\n  }\n}\n\nfunction $removeSegment(node, isBackward, offset) {\n  const textNode = node;\n  const textContent = textNode.getTextContent();\n  const split = textContent.split(/(?=\\s)/g);\n  const splitLength = split.length;\n  let segmentOffset = 0;\n  let restoreOffset = 0;\n\n  for (let i = 0; i < splitLength; i++) {\n    const text = split[i];\n    const isLast = i === splitLength - 1;\n    restoreOffset = segmentOffset;\n    segmentOffset += text.length;\n\n    if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {\n      split.splice(i, 1);\n\n      if (isLast) {\n        restoreOffset = undefined;\n      }\n\n      break;\n    }\n  }\n\n  const nextTextContent = split.join('').trim();\n\n  if (nextTextContent === '') {\n    textNode.remove();\n  } else {\n    textNode.setTextContent(nextTextContent);\n    textNode.select(restoreOffset, restoreOffset);\n  }\n}\n\nfunction shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {\n  const parent = resolvedElement.getParent();\n  return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();\n}\n\nfunction internalResolveSelectionPoint(dom, offset, lastPoint, editor) {\n  let resolvedOffset = offset;\n  let resolvedNode; // If we have selection on an element, we will\n  // need to figure out (using the offset) what text\n  // node should be selected.\n\n  if (dom.nodeType === DOM_ELEMENT_TYPE) {\n    // Resolve element to a ElementNode, or TextNode, or null\n    let moveSelectionToEnd = false; // Given we're moving selection to another node, selection is\n    // definitely dirty.\n    // We use the anchor to find which child node to select\n\n    const childNodes = dom.childNodes;\n    const childNodesLength = childNodes.length; // If the anchor is the same as length, then this means we\n    // need to select the very last text node.\n\n    if (resolvedOffset === childNodesLength) {\n      moveSelectionToEnd = true;\n      resolvedOffset = childNodesLength - 1;\n    }\n\n    let childDOM = childNodes[resolvedOffset];\n    let hasBlockCursor = false;\n\n    if (childDOM === editor._blockCursorElement) {\n      childDOM = childNodes[resolvedOffset + 1];\n      hasBlockCursor = true;\n    } else if (editor._blockCursorElement !== null) {\n      resolvedOffset--;\n    }\n\n    resolvedNode = getNodeFromDOM(childDOM);\n\n    if ($isTextNode(resolvedNode)) {\n      resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);\n    } else {\n      let resolvedElement = getNodeFromDOM(dom); // Ensure resolvedElement is actually a element.\n\n      if (resolvedElement === null) {\n        return null;\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        let child = resolvedElement.getChildAtIndex(resolvedOffset);\n\n        if ($isElementNode(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {\n          const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();\n\n          if (descendant === null) {\n            resolvedElement = child;\n            resolvedOffset = 0;\n          } else {\n            child = descendant;\n            resolvedElement = $isElementNode(child) ? child : child.getParentOrThrow();\n          }\n        }\n\n        if ($isTextNode(child)) {\n          resolvedNode = child;\n          resolvedElement = null;\n          resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);\n        } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {\n          resolvedOffset++;\n        }\n      } else {\n        const index = resolvedElement.getIndexWithinParent(); // When selecting decorators, there can be some selection issues when using resolvedOffset,\n        // and instead we should be checking if we're using the offset\n\n        if (offset === 0 && $isDecoratorNode(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {\n          resolvedOffset = index;\n        } else {\n          resolvedOffset = index + 1;\n        }\n\n        resolvedElement = resolvedElement.getParentOrThrow();\n      }\n\n      if ($isElementNode(resolvedElement)) {\n        return $createPoint(resolvedElement.__key, resolvedOffset, 'element');\n      }\n    }\n  } else {\n    // TextNode or null\n    resolvedNode = getNodeFromDOM(dom);\n  }\n\n  if (!$isTextNode(resolvedNode)) {\n    return null;\n  }\n\n  return $createPoint(resolvedNode.__key, resolvedOffset, 'text');\n}\n\nfunction resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {\n  const offset = point.offset;\n  const node = point.getNode();\n\n  if (offset === 0) {\n    const prevSibling = node.getPreviousSibling();\n    const parent = node.getParent();\n\n    if (!isBackward) {\n      if ($isElementNode(prevSibling) && !isCollapsed && prevSibling.isInline()) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getChildrenSize(); // @ts-expect-error: intentional\n\n        point.type = 'element';\n      } else if ($isTextNode(prevSibling)) {\n        point.key = prevSibling.__key;\n        point.offset = prevSibling.getTextContent().length;\n      }\n    } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode(parent) && parent.isInline()) {\n      const parentSibling = parent.getPreviousSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = parentSibling.getTextContent().length;\n      }\n    }\n  } else if (offset === node.getTextContent().length) {\n    const nextSibling = node.getNextSibling();\n    const parent = node.getParent();\n\n    if (isBackward && $isElementNode(nextSibling) && nextSibling.isInline()) {\n      point.key = nextSibling.__key;\n      point.offset = 0; // @ts-expect-error: intentional\n\n      point.type = 'element';\n    } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode(parent) && parent.isInline() && !parent.canInsertTextAfter()) {\n      const parentSibling = parent.getNextSibling();\n\n      if ($isTextNode(parentSibling)) {\n        point.key = parentSibling.__key;\n        point.offset = 0;\n      }\n    }\n  }\n}\n\nfunction normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {\n  if (anchor.type === 'text' && focus.type === 'text') {\n    const isBackward = anchor.isBefore(focus);\n    const isCollapsed = anchor.is(focus); // Attempt to normalize the offset to the previous sibling if we're at the\n    // start of a text node and the sibling is a text node or inline element.\n\n    resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);\n    resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);\n\n    if (isCollapsed) {\n      focus.key = anchor.key;\n      focus.offset = anchor.offset;\n      focus.type = anchor.type;\n    }\n\n    const editor = getActiveEditor();\n\n    if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection(lastSelection)) {\n      const lastAnchor = lastSelection.anchor;\n      const lastFocus = lastSelection.focus;\n      $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);\n      $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);\n    }\n  }\n}\n\nfunction internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {\n  if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return null;\n  }\n\n  const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection(lastSelection) ? lastSelection.anchor : null, editor);\n\n  if (resolvedAnchorPoint === null) {\n    return null;\n  }\n\n  const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection(lastSelection) ? lastSelection.focus : null, editor);\n\n  if (resolvedFocusPoint === null) {\n    return null;\n  }\n\n  if (resolvedAnchorPoint.type === 'element' && resolvedFocusPoint.type === 'element') {\n    const anchorNode = getNodeFromDOM(anchorDOM);\n    const focusNode = getNodeFromDOM(focusDOM); // Ensure if we're selecting the content of a decorator that we\n    // return null for this point, as it's not in the controlled scope\n    // of Lexical.\n\n    if ($isDecoratorNode(anchorNode) && $isDecoratorNode(focusNode)) {\n      return null;\n    }\n  } // Handle normalization of selection when it is at the boundaries.\n\n\n  normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);\n  return [resolvedAnchorPoint, resolvedFocusPoint];\n}\n\nfunction $isBlockElementNode(node) {\n  return $isElementNode(node) && !node.isInline();\n} // This is used to make a selection when the existing\n// selection is null, i.e. forcing selection on the editor\n// when it current exists outside the editor.\n\nfunction internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {\n  const editorState = getActiveEditorState();\n  const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, '');\n  selection.dirty = true;\n  editorState._selection = selection;\n  return selection;\n}\nfunction $createRangeSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new RangeSelection(anchor, focus, 0, '');\n}\nfunction $createNodeSelection() {\n  return new NodeSelection(new Set());\n}\nfunction DEPRECATED_$createGridSelection() {\n  const anchor = $createPoint('root', 0, 'element');\n  const focus = $createPoint('root', 0, 'element');\n  return new GridSelection('root', anchor, focus);\n}\nfunction internalCreateSelection(editor) {\n  const currentEditorState = editor.getEditorState();\n  const lastSelection = currentEditorState._selection;\n  const domSelection = getDOMSelection(editor._window);\n\n  if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {\n    return lastSelection.clone();\n  }\n\n  return internalCreateRangeSelection(lastSelection, domSelection, editor);\n}\nfunction internalCreateRangeSelection(lastSelection, domSelection, editor) {\n  const windowObj = editor._window;\n\n  if (windowObj === null) {\n    return null;\n  } // When we create a selection, we try to use the previous\n  // selection where possible, unless an actual user selection\n  // change has occurred. When we do need to create a new selection\n  // we validate we can have text nodes for both anchor and focus\n  // nodes. If that holds true, we then return that selection\n  // as a mutable object that we use for the editor state for this\n  // update cycle. If a selection gets changed, and requires a\n  // update to native DOM selection, it gets marked as \"dirty\".\n  // If the selection changes, but matches with the existing\n  // DOM selection, then we only need to sync it. Otherwise,\n  // we generally bail out of doing an update to selection during\n  // reconciliation unless there are dirty nodes that need\n  // reconciling.\n\n\n  const windowEvent = windowObj.event;\n  const eventType = windowEvent ? windowEvent.type : undefined;\n  const isSelectionChange = eventType === 'selectionchange';\n  const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === 'beforeinput' || eventType === 'compositionstart' || eventType === 'compositionend' || eventType === 'click' && windowEvent && windowEvent.detail === 3 || eventType === 'drop' || eventType === undefined);\n  let anchorDOM, focusDOM, anchorOffset, focusOffset;\n\n  if (!$isRangeSelection(lastSelection) || useDOMSelection) {\n    if (domSelection === null) {\n      return null;\n    }\n\n    anchorDOM = domSelection.anchorNode;\n    focusDOM = domSelection.focusNode;\n    anchorOffset = domSelection.anchorOffset;\n    focusOffset = domSelection.focusOffset;\n\n    if (isSelectionChange && $isRangeSelection(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n      return lastSelection.clone();\n    }\n  } else {\n    return lastSelection.clone();\n  } // Let's resolve the text nodes from the offsets and DOM nodes we have from\n  // native selection.\n\n\n  const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);\n\n  if (resolvedSelectionPoints === null) {\n    return null;\n  }\n\n  const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;\n  return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection(lastSelection) ? '' : lastSelection.style);\n}\nfunction $getSelection() {\n  const editorState = getActiveEditorState();\n  return editorState._selection;\n}\nfunction $getPreviousSelection() {\n  const editor = getActiveEditor();\n  return editor._editorState._selection;\n}\nfunction $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {\n    return;\n  }\n\n  const parentKey = parentNode.__key; // Single node. We shift selection but never redimension it\n\n  if (selection.isCollapsed()) {\n    const selectionOffset = anchor.offset;\n\n    if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {\n      const newSelectionOffset = Math.max(0, selectionOffset + times);\n      anchor.set(parentKey, newSelectionOffset, 'element');\n      focus.set(parentKey, newSelectionOffset, 'element'); // The new selection might point to text nodes, try to resolve them\n\n      $updateSelectionResolveTextNodes(selection);\n    }\n  } else {\n    // Multiple nodes selected. We shift or redimension selection\n    const isBackward = selection.isBackward();\n    const firstPoint = isBackward ? focus : anchor;\n    const firstPointNode = firstPoint.getNode();\n    const lastPoint = isBackward ? anchor : focus;\n    const lastPointNode = lastPoint.getNode();\n\n    if (parentNode.is(firstPointNode)) {\n      const firstPointOffset = firstPoint.offset;\n\n      if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {\n        firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), 'element');\n      }\n    }\n\n    if (parentNode.is(lastPointNode)) {\n      const lastPointOffset = lastPoint.offset;\n\n      if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {\n        lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), 'element');\n      }\n    }\n  } // The new selection might point to text nodes, try to resolve them\n\n\n  $updateSelectionResolveTextNodes(selection);\n}\n\nfunction $updateSelectionResolveTextNodes(selection) {\n  const anchor = selection.anchor;\n  const anchorOffset = anchor.offset;\n  const focus = selection.focus;\n  const focusOffset = focus.offset;\n  const anchorNode = anchor.getNode();\n  const focusNode = focus.getNode();\n\n  if (selection.isCollapsed()) {\n    if (!$isElementNode(anchorNode)) {\n      return;\n    }\n\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n      focus.set(child.__key, newOffset, 'text');\n    }\n\n    return;\n  }\n\n  if ($isElementNode(anchorNode)) {\n    const childSize = anchorNode.getChildrenSize();\n    const anchorOffsetAtEnd = anchorOffset >= childSize;\n    const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (anchorOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      anchor.set(child.__key, newOffset, 'text');\n    }\n  }\n\n  if ($isElementNode(focusNode)) {\n    const childSize = focusNode.getChildrenSize();\n    const focusOffsetAtEnd = focusOffset >= childSize;\n    const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);\n\n    if ($isTextNode(child)) {\n      let newOffset = 0;\n\n      if (focusOffsetAtEnd) {\n        newOffset = child.getTextContentSize();\n      }\n\n      focus.set(child.__key, newOffset, 'text');\n    }\n  }\n}\n\nfunction applySelectionTransforms(nextEditorState, editor) {\n  const prevEditorState = editor.getEditorState();\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n\n  if ($isRangeSelection(nextSelection)) {\n    const anchor = nextSelection.anchor;\n    const focus = nextSelection.focus;\n    let anchorNode;\n\n    if (anchor.type === 'text') {\n      anchorNode = anchor.getNode();\n      anchorNode.selectionTransform(prevSelection, nextSelection);\n    }\n\n    if (focus.type === 'text') {\n      const focusNode = focus.getNode();\n\n      if (anchorNode !== focusNode) {\n        focusNode.selectionTransform(prevSelection, nextSelection);\n      }\n    }\n  }\n}\nfunction moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {\n  let siblingKey = null;\n  let offset = 0;\n  let type = null;\n\n  if (prevSibling !== null) {\n    siblingKey = prevSibling.__key;\n\n    if ($isTextNode(prevSibling)) {\n      offset = prevSibling.getTextContentSize();\n      type = 'text';\n    } else if ($isElementNode(prevSibling)) {\n      offset = prevSibling.getChildrenSize();\n      type = 'element';\n    }\n  } else {\n    if (nextSibling !== null) {\n      siblingKey = nextSibling.__key;\n\n      if ($isTextNode(nextSibling)) {\n        type = 'text';\n      } else if ($isElementNode(nextSibling)) {\n        type = 'element';\n      }\n    }\n  }\n\n  if (siblingKey !== null && type !== null) {\n    point.set(siblingKey, offset, type);\n  } else {\n    offset = node.getIndexWithinParent();\n\n    if (offset === -1) {\n      // Move selection to end of parent\n      offset = parent.getChildrenSize();\n    }\n\n    point.set(parent.__key, offset, 'element');\n  }\n}\nfunction adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {\n  if (point.type === 'text') {\n    point.key = key;\n\n    if (!isBefore) {\n      point.offset += textLength;\n    }\n  } else if (point.offset > target.getIndexWithinParent()) {\n    point.offset -= 1;\n  }\n}\nfunction updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {\n  const anchorDOMNode = domSelection.anchorNode;\n  const focusDOMNode = domSelection.focusNode;\n  const anchorOffset = domSelection.anchorOffset;\n  const focusOffset = domSelection.focusOffset;\n  const activeElement = document.activeElement; // TODO: make this not hard-coded, and add another config option\n  // that makes this configurable.\n\n  if (tags.has('collaboration') && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {\n    return;\n  }\n\n  if (!$isRangeSelection(nextSelection)) {\n    // We don't remove selection if the prevSelection is null because\n    // of editor.setRootElement(). If this occurs on init when the\n    // editor is already focused, then this can cause the editor to\n    // lose focus.\n    if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {\n      domSelection.removeAllRanges();\n    }\n\n    return;\n  }\n\n  const anchor = nextSelection.anchor;\n  const focus = nextSelection.focus;\n  const anchorKey = anchor.key;\n  const focusKey = focus.key;\n  const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);\n  const focusDOM = getElementByKeyOrThrow(editor, focusKey);\n  const nextAnchorOffset = anchor.offset;\n  const nextFocusOffset = focus.offset;\n  const nextFormat = nextSelection.format;\n  const nextStyle = nextSelection.style;\n  const isCollapsed = nextSelection.isCollapsed();\n  let nextAnchorNode = anchorDOM;\n  let nextFocusNode = focusDOM;\n  let anchorFormatOrStyleChanged = false;\n\n  if (anchor.type === 'text') {\n    nextAnchorNode = getDOMTextNode(anchorDOM);\n    const anchorNode = anchor.getNode();\n    anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;\n  } else if ($isRangeSelection(prevSelection) && prevSelection.anchor.type === 'text') {\n    anchorFormatOrStyleChanged = true;\n  }\n\n  if (focus.type === 'text') {\n    nextFocusNode = getDOMTextNode(focusDOM);\n  } // If we can't get an underlying text node for selection, then\n  // we should avoid setting selection to something incorrect.\n\n\n  if (nextAnchorNode === null || nextFocusNode === null) {\n    return;\n  }\n\n  if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {\n    markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());\n  } // Diff against the native DOM selection to ensure we don't do\n  // an unnecessary selection update. We also skip this check if\n  // we're moving selection to within an element, as this can\n  // sometimes be problematic around scrolling.\n\n\n  if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482\n  !(domSelection.type === 'Range' && isCollapsed)) {\n    // If the root element does not have focus, ensure it has focus\n    if (activeElement === null || !rootElement.contains(activeElement)) {\n      rootElement.focus({\n        preventScroll: true\n      });\n    }\n\n    if (anchor.type !== 'element') {\n      return;\n    }\n  } // Apply the updated selection to the DOM. Note: this will trigger\n  // a \"selectionchange\" event, although it will be asynchronous.\n\n\n  try {\n    domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);\n  } catch (error) {// If we encounter an error, continue. This can sometimes\n    // occur with FF and there's no good reason as to why it\n    // should happen.\n  }\n\n  if (!tags.has('skip-scroll-into-view') && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {\n    const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === 'element' ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;\n\n    if (selectionTarget !== null) {\n      let selectionRect;\n\n      if (selectionTarget instanceof Text) {\n        const range = document.createRange();\n        range.selectNode(selectionTarget);\n        selectionRect = range.getBoundingClientRect();\n      } else {\n        selectionRect = selectionTarget.getBoundingClientRect();\n      }\n\n      scrollIntoViewIfNeeded(editor, selectionRect, rootElement);\n    }\n  }\n\n  markSelectionChangeFromDOMUpdate();\n}\nfunction $insertNodes(nodes, selectStart) {\n  let selection = $getSelection() || $getPreviousSelection();\n\n  if (selection === null) {\n    selection = $getRoot().selectEnd();\n  }\n\n  return selection.insertNodes(nodes, selectStart);\n}\nfunction $getTextContent() {\n  const selection = $getSelection();\n\n  if (selection === null) {\n    return '';\n  }\n\n  return selection.getTextContent();\n}\nfunction DEPRECATED_$computeGridMap(grid, cellA, cellB) {\n  const tableMap = [];\n  let cellAValue = null;\n  let cellBValue = null;\n\n  function write(startRow, startColumn, cell) {\n    const value = {\n      cell,\n      startColumn,\n      startRow\n    };\n    const rowSpan = cell.__rowSpan;\n    const colSpan = cell.__colSpan;\n\n    for (let i = 0; i < rowSpan; i++) {\n      if (tableMap[startRow + i] === undefined) {\n        tableMap[startRow + i] = [];\n      }\n\n      for (let j = 0; j < colSpan; j++) {\n        tableMap[startRow + i][startColumn + j] = value;\n      }\n    }\n\n    if (cellA.is(cell)) {\n      cellAValue = value;\n    }\n\n    if (cellB.is(cell)) {\n      cellBValue = value;\n    }\n  }\n\n  function isEmpty(row, column) {\n    return tableMap[row] === undefined || tableMap[row][column] === undefined;\n  }\n\n  const gridChildren = grid.getChildren();\n\n  for (let i = 0; i < gridChildren.length; i++) {\n    const row = gridChildren[i];\n\n    if (!DEPRECATED_$isGridRowNode(row)) {\n      throw Error(`Expected GridNode children to be GridRowNode`);\n    }\n\n    const rowChildren = row.getChildren();\n    let j = 0;\n\n    for (const cell of rowChildren) {\n      if (!DEPRECATED_$isGridCellNode(cell)) {\n        throw Error(`Expected GridRowNode children to be GridCellNode`);\n      }\n\n      while (!isEmpty(i, j)) {\n        j++;\n      }\n\n      write(i, j, cell);\n      j += cell.__colSpan;\n    }\n  }\n\n  if (!(cellAValue !== null)) {\n    throw Error(`Anchor not found in Grid`);\n  }\n\n  if (!(cellBValue !== null)) {\n    throw Error(`Focus not found in Grid`);\n  }\n\n  return [tableMap, cellAValue, cellBValue];\n}\nfunction DEPRECATED_$getNodeTriplet(source) {\n  let cell;\n\n  if (source instanceof DEPRECATED_GridCellNode) {\n    cell = source;\n  } else if (source instanceof LexicalNode) {\n    const cell_ = $findMatchingParent(source, DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  } else {\n    const cell_ = $findMatchingParent(source.getNode(), DEPRECATED_$isGridCellNode);\n\n    if (!DEPRECATED_$isGridCellNode(cell_)) {\n      throw Error(`Expected to find a parent GridCellNode`);\n    }\n\n    cell = cell_;\n  }\n\n  const row = cell.getParent();\n\n  if (!DEPRECATED_$isGridRowNode(row)) {\n    throw Error(`Expected GridCellNode to have a parent GridRowNode`);\n  }\n\n  const grid = row.getParent();\n\n  if (!DEPRECATED_$isGridNode(grid)) {\n    throw Error(`Expected GridRowNode to have a parent GridNode`);\n  }\n\n  return [cell, row, grid];\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nlet activeEditorState = null;\nlet activeEditor = null;\nlet isReadOnlyMode = false;\nlet isAttemptingToRecoverFromReconcilerError = false;\nlet infiniteTransformCount = 0;\nconst observerOptions = {\n  characterData: true,\n  childList: true,\n  subtree: true\n};\nfunction isCurrentlyReadOnlyMode() {\n  return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;\n}\nfunction errorOnReadOnly() {\n  if (isReadOnlyMode) {\n    {\n      throw Error(`Cannot use method in read-only mode.`);\n    }\n  }\n}\nfunction errorOnInfiniteTransforms() {\n  if (infiniteTransformCount > 99) {\n    {\n      throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);\n    }\n  }\n}\nfunction getActiveEditorState() {\n  if (activeEditorState === null) {\n    {\n      throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);\n    }\n  }\n\n  return activeEditorState;\n}\nfunction getActiveEditor() {\n  if (activeEditor === null) {\n    {\n      throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);\n    }\n  }\n\n  return activeEditor;\n}\nfunction internalGetActiveEditor() {\n  return activeEditor;\n}\nfunction $applyTransforms(editor, node, transformsCache) {\n  const type = node.__type;\n  const registeredNode = getRegisteredNodeOrThrow(editor, type);\n  let transformsArr = transformsCache.get(type);\n\n  if (transformsArr === undefined) {\n    transformsArr = Array.from(registeredNode.transforms);\n    transformsCache.set(type, transformsArr);\n  }\n\n  const transformsArrLength = transformsArr.length;\n\n  for (let i = 0; i < transformsArrLength; i++) {\n    transformsArr[i](node);\n\n    if (!node.isAttached()) {\n      break;\n    }\n  }\n}\n\nfunction $isNodeValidForTransform(node, compositionKey) {\n  return node !== undefined && // We don't want to transform nodes being composed\n  node.__key !== compositionKey && node.isAttached();\n}\n\nfunction $normalizeAllDirtyTextNodes(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const nodeMap = editorState._nodeMap;\n\n  for (const nodeKey of dirtyLeaves) {\n    const node = nodeMap.get(nodeKey);\n\n    if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n      $normalizeTextNode(node);\n    }\n  }\n}\n/**\n * Transform heuristic:\n * 1. We transform leaves first. If transforms generate additional dirty nodes we repeat step 1.\n * The reasoning behind this is that marking a leaf as dirty marks all its parent elements as dirty too.\n * 2. We transform elements. If element transforms generate additional dirty nodes we repeat step 1.\n * If element transforms only generate additional dirty elements we only repeat step 2.\n *\n * Note that to keep track of newly dirty nodes and subtrees we leverage the editor._dirtyNodes and\n * editor._subtrees which we reset in every loop.\n */\n\n\nfunction $applyAllTransforms(editorState, editor) {\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const nodeMap = editorState._nodeMap;\n  const compositionKey = $getCompositionKey();\n  const transformsCache = new Map();\n  let untransformedDirtyLeaves = dirtyLeaves;\n  let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n  let untransformedDirtyElements = dirtyElements;\n  let untransformedDirtyElementsLength = untransformedDirtyElements.size;\n\n  while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {\n    if (untransformedDirtyLeavesLength > 0) {\n      // We leverage editor._dirtyLeaves to track the new dirty leaves after the transforms\n      editor._dirtyLeaves = new Set();\n\n      for (const nodeKey of untransformedDirtyLeaves) {\n        const node = nodeMap.get(nodeKey);\n\n        if ($isTextNode(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {\n          $normalizeTextNode(node);\n        }\n\n        if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n          $applyTransforms(editor, node, transformsCache);\n        }\n\n        dirtyLeaves.add(nodeKey);\n      }\n\n      untransformedDirtyLeaves = editor._dirtyLeaves;\n      untransformedDirtyLeavesLength = untransformedDirtyLeaves.size; // We want to prioritize node transforms over element transforms\n\n      if (untransformedDirtyLeavesLength > 0) {\n        infiniteTransformCount++;\n        continue;\n      }\n    } // All dirty leaves have been processed. Let's do elements!\n    // We have previously processed dirty leaves, so let's restart the editor leaves Set to track\n    // new ones caused by element transforms\n\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n\n    for (const currentUntransformedDirtyElement of untransformedDirtyElements) {\n      const nodeKey = currentUntransformedDirtyElement[0];\n      const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];\n\n      if (nodeKey !== 'root' && !intentionallyMarkedAsDirty) {\n        continue;\n      }\n\n      const node = nodeMap.get(nodeKey);\n\n      if (node !== undefined && $isNodeValidForTransform(node, compositionKey)) {\n        $applyTransforms(editor, node, transformsCache);\n      }\n\n      dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);\n    }\n\n    untransformedDirtyLeaves = editor._dirtyLeaves;\n    untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;\n    untransformedDirtyElements = editor._dirtyElements;\n    untransformedDirtyElementsLength = untransformedDirtyElements.size;\n    infiniteTransformCount++;\n  }\n\n  editor._dirtyLeaves = dirtyLeaves;\n  editor._dirtyElements = dirtyElements;\n}\n\nfunction $parseSerializedNode(serializedNode) {\n  const internalSerializedNode = serializedNode;\n  return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);\n}\n\nfunction $parseSerializedNodeImpl(serializedNode, registeredNodes) {\n  const type = serializedNode.type;\n  const registeredNode = registeredNodes.get(type);\n\n  if (registeredNode === undefined) {\n    {\n      throw Error(`parseEditorState: type \"${type}\" + not found`);\n    }\n  }\n\n  const nodeClass = registeredNode.klass;\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);\n    }\n  }\n\n  const node = nodeClass.importJSON(serializedNode);\n  const children = serializedNode.children;\n\n  if ($isElementNode(node) && Array.isArray(children)) {\n    for (let i = 0; i < children.length; i++) {\n      const serializedJSONChildNode = children[i];\n      const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);\n      node.append(childNode);\n    }\n  }\n\n  return node;\n}\n\nfunction parseEditorState(serializedEditorState, editor, updateFn) {\n  const editorState = createEmptyEditorState();\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previousDirtyElements = editor._dirtyElements;\n  const previousDirtyLeaves = editor._dirtyLeaves;\n  const previousCloneNotNeeded = editor._cloneNotNeeded;\n  const previousDirtyType = editor._dirtyType;\n  editor._dirtyElements = new Map();\n  editor._dirtyLeaves = new Set();\n  editor._cloneNotNeeded = new Set();\n  editor._dirtyType = 0;\n  activeEditorState = editorState;\n  isReadOnlyMode = false;\n  activeEditor = editor;\n\n  try {\n    const registeredNodes = editor._nodes;\n    const serializedNode = serializedEditorState.root;\n    $parseSerializedNodeImpl(serializedNode, registeredNodes);\n\n    if (updateFn) {\n      updateFn();\n    } // Make the editorState immutable\n\n\n    editorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(editorState);\n    }\n  } catch (error) {\n    if (error instanceof Error) {\n      editor._onError(error);\n    }\n  } finally {\n    editor._dirtyElements = previousDirtyElements;\n    editor._dirtyLeaves = previousDirtyLeaves;\n    editor._cloneNotNeeded = previousCloneNotNeeded;\n    editor._dirtyType = previousDirtyType;\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n\n  return editorState;\n} // This technically isn't an update but given we need\n// exposure to the module's active bindings, we have this\n// function here\n\nfunction readEditorState(editorState, callbackFn) {\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  activeEditorState = editorState;\n  isReadOnlyMode = true;\n  activeEditor = null;\n\n  try {\n    return callbackFn();\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n  }\n}\n\nfunction handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {\n  // Given we can't Object.freeze the nodeMap as it's a Map,\n  // we instead replace its set, clear and delete methods.\n  const nodeMap = pendingEditorState._nodeMap;\n\n  nodeMap.set = () => {\n    throw new Error('Cannot call set() on a frozen Lexical node map');\n  };\n\n  nodeMap.clear = () => {\n    throw new Error('Cannot call clear() on a frozen Lexical node map');\n  };\n\n  nodeMap.delete = () => {\n    throw new Error('Cannot call delete() on a frozen Lexical node map');\n  };\n}\n\nfunction commitPendingUpdates(editor, recoveryEditorState) {\n  const pendingEditorState = editor._pendingEditorState;\n  const rootElement = editor._rootElement;\n  const shouldSkipDOM = editor._headless || rootElement === null;\n\n  if (pendingEditorState === null) {\n    return;\n  } // ======\n  // Reconciliation has started.\n  // ======\n\n\n  const currentEditorState = editor._editorState;\n  const currentSelection = currentEditorState._selection;\n  const pendingSelection = pendingEditorState._selection;\n  const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  const observer = editor._observer;\n  let mutatedNodes = null;\n  editor._pendingEditorState = null;\n  editor._editorState = pendingEditorState;\n\n  if (!shouldSkipDOM && needsUpdate && observer !== null) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n    isReadOnlyMode = false; // We don't want updates to sync block the reconciliation.\n\n    editor._updating = true;\n\n    try {\n      const dirtyType = editor._dirtyType;\n      const dirtyElements = editor._dirtyElements;\n      const dirtyLeaves = editor._dirtyLeaves;\n      observer.disconnect();\n      mutatedNodes = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements, dirtyLeaves);\n    } catch (error) {\n      // Report errors\n      if (error instanceof Error) {\n        editor._onError(error);\n      } // Reset editor and restore incoming editor state to the DOM\n\n\n      if (!isAttemptingToRecoverFromReconcilerError) {\n        resetEditor(editor, null, rootElement, pendingEditorState);\n        initMutationObserver(editor);\n        editor._dirtyType = FULL_RECONCILE;\n        isAttemptingToRecoverFromReconcilerError = true;\n        commitPendingUpdates(editor, currentEditorState);\n        isAttemptingToRecoverFromReconcilerError = false;\n      } else {\n        // To avoid a possible situation of infinite loops, lets throw\n        throw error;\n      }\n\n      return;\n    } finally {\n      observer.observe(rootElement, observerOptions);\n      editor._updating = previouslyUpdating;\n      activeEditorState = previousActiveEditorState;\n      isReadOnlyMode = previousReadOnlyMode;\n      activeEditor = previousActiveEditor;\n    }\n  }\n\n  if (!pendingEditorState._readOnly) {\n    pendingEditorState._readOnly = true;\n\n    {\n      handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);\n\n      if ($isRangeSelection(pendingSelection)) {\n        Object.freeze(pendingSelection.anchor);\n        Object.freeze(pendingSelection.focus);\n      }\n\n      Object.freeze(pendingSelection);\n    }\n  }\n\n  const dirtyLeaves = editor._dirtyLeaves;\n  const dirtyElements = editor._dirtyElements;\n  const normalizedNodes = editor._normalizedNodes;\n  const tags = editor._updateTags;\n  const deferred = editor._deferred;\n\n  if (needsUpdate) {\n    editor._dirtyType = NO_DIRTY_NODES;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n    editor._dirtyElements = new Map();\n    editor._normalizedNodes = new Set();\n    editor._updateTags = new Set();\n  }\n\n  $garbageCollectDetachedDecorators(editor, pendingEditorState); // ======\n  // Reconciliation has finished. Now update selection and trigger listeners.\n  // ======\n\n  const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window); // Attempt to update the DOM selection, including focusing of the root element,\n  // and scroll into view if needed.\n\n  if (editor._editable && // domSelection will be null in headless\n  domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {\n    activeEditor = editor;\n    activeEditorState = pendingEditorState;\n\n    try {\n      if (observer !== null) {\n        observer.disconnect();\n      }\n\n      if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {\n        const blockCursorElement = editor._blockCursorElement;\n\n        if (blockCursorElement !== null) {\n          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);\n        }\n\n        updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);\n      }\n\n      updateDOMBlockCursorElement(editor, rootElement, pendingSelection);\n\n      if (observer !== null) {\n        observer.observe(rootElement, observerOptions);\n      }\n    } finally {\n      activeEditor = previousActiveEditor;\n      activeEditorState = previousActiveEditorState;\n    }\n  }\n\n  if (mutatedNodes !== null) {\n    triggerMutationListeners(editor, mutatedNodes, tags, dirtyLeaves, currentEditorState);\n  }\n\n  if (!$isRangeSelection(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {\n    editor.dispatchCommand(SELECTION_CHANGE_COMMAND, undefined);\n  }\n  /**\n   * Capture pendingDecorators after garbage collecting detached decorators\n   */\n\n\n  const pendingDecorators = editor._pendingDecorators;\n\n  if (pendingDecorators !== null) {\n    editor._decorators = pendingDecorators;\n    editor._pendingDecorators = null;\n    triggerListeners('decorator', editor, true, pendingDecorators);\n  } // If reconciler fails, we reset whole editor (so current editor state becomes empty)\n  // and attempt to re-render pendingEditorState. If that goes through we trigger\n  // listeners, but instead use recoverEditorState which is current editor state before reset\n  // This specifically important for collab that relies on prevEditorState from update\n  // listener to calculate delta of changed nodes/properties\n\n\n  triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);\n  triggerListeners('update', editor, true, {\n    dirtyElements,\n    dirtyLeaves,\n    editorState: pendingEditorState,\n    normalizedNodes,\n    prevEditorState: recoveryEditorState || currentEditorState,\n    tags\n  });\n  triggerDeferredUpdateCallbacks(editor, deferred);\n  triggerEnqueuedUpdates(editor);\n}\n\nfunction triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {\n  const currentTextContent = getEditorStateTextContent(currentEditorState);\n  const latestTextContent = getEditorStateTextContent(pendingEditorState);\n\n  if (currentTextContent !== latestTextContent) {\n    triggerListeners('textcontent', editor, true, latestTextContent);\n  }\n}\n\nfunction triggerMutationListeners(editor, mutatedNodes, updateTags, dirtyLeaves, prevEditorState) {\n  const listeners = Array.from(editor._listeners.mutation);\n  const listenersLength = listeners.length;\n\n  for (let i = 0; i < listenersLength; i++) {\n    const [listener, klass] = listeners[i];\n    const mutatedNodesByType = mutatedNodes.get(klass);\n\n    if (mutatedNodesByType !== undefined) {\n      listener(mutatedNodesByType, {\n        dirtyLeaves,\n        prevEditorState,\n        updateTags\n      });\n    }\n  }\n}\n\nfunction triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {\n  const previouslyUpdating = editor._updating;\n  editor._updating = isCurrentlyEnqueuingUpdates;\n\n  try {\n    const listeners = Array.from(editor._listeners[type]);\n\n    for (let i = 0; i < listeners.length; i++) {\n      // @ts-ignore\n      listeners[i].apply(null, payload);\n    }\n  } finally {\n    editor._updating = previouslyUpdating;\n  }\n}\nfunction triggerCommandListeners(editor, type, payload) {\n  if (editor._updating === false || activeEditor !== editor) {\n    let returnVal = false;\n    editor.update(() => {\n      returnVal = triggerCommandListeners(editor, type, payload);\n    });\n    return returnVal;\n  }\n\n  const editors = getEditorsToPropagate(editor);\n\n  for (let i = 4; i >= 0; i--) {\n    for (let e = 0; e < editors.length; e++) {\n      const currentEditor = editors[e];\n      const commandListeners = currentEditor._commands;\n      const listenerInPriorityOrder = commandListeners.get(type);\n\n      if (listenerInPriorityOrder !== undefined) {\n        const listenersSet = listenerInPriorityOrder[i];\n\n        if (listenersSet !== undefined) {\n          const listeners = Array.from(listenersSet);\n          const listenersLength = listeners.length;\n\n          for (let j = 0; j < listenersLength; j++) {\n            if (listeners[j](payload, editor) === true) {\n              return true;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction triggerEnqueuedUpdates(editor) {\n  const queuedUpdates = editor._updates;\n\n  if (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [updateFn, options] = queuedUpdate;\n      beginUpdate(editor, updateFn, options);\n    }\n  }\n}\n\nfunction triggerDeferredUpdateCallbacks(editor, deferred) {\n  editor._deferred = [];\n\n  if (deferred.length !== 0) {\n    const previouslyUpdating = editor._updating;\n    editor._updating = true;\n\n    try {\n      for (let i = 0; i < deferred.length; i++) {\n        deferred[i]();\n      }\n    } finally {\n      editor._updating = previouslyUpdating;\n    }\n  }\n}\n\nfunction processNestedUpdates(editor, initialSkipTransforms) {\n  const queuedUpdates = editor._updates;\n  let skipTransforms = initialSkipTransforms || false; // Updates might grow as we process them, we so we'll need\n  // to handle each update as we go until the updates array is\n  // empty.\n\n  while (queuedUpdates.length !== 0) {\n    const queuedUpdate = queuedUpdates.shift();\n\n    if (queuedUpdate) {\n      const [nextUpdateFn, options] = queuedUpdate;\n      let onUpdate;\n      let tag;\n\n      if (options !== undefined) {\n        onUpdate = options.onUpdate;\n        tag = options.tag;\n\n        if (options.skipTransforms) {\n          skipTransforms = true;\n        }\n\n        if (onUpdate) {\n          editor._deferred.push(onUpdate);\n        }\n\n        if (tag) {\n          editor._updateTags.add(tag);\n        }\n      }\n\n      nextUpdateFn();\n    }\n  }\n\n  return skipTransforms;\n}\n\nfunction beginUpdate(editor, updateFn, options) {\n  const updateTags = editor._updateTags;\n  let onUpdate;\n  let tag;\n  let skipTransforms = false;\n  let discrete = false;\n\n  if (options !== undefined) {\n    onUpdate = options.onUpdate;\n    tag = options.tag;\n\n    if (tag != null) {\n      updateTags.add(tag);\n    }\n\n    skipTransforms = options.skipTransforms || false;\n    discrete = options.discrete || false;\n  }\n\n  if (onUpdate) {\n    editor._deferred.push(onUpdate);\n  }\n\n  const currentEditorState = editor._editorState;\n  let pendingEditorState = editor._pendingEditorState;\n  let editorStateWasCloned = false;\n\n  if (pendingEditorState === null || pendingEditorState._readOnly) {\n    pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);\n    editorStateWasCloned = true;\n  }\n\n  pendingEditorState._flushSync = discrete;\n  const previousActiveEditorState = activeEditorState;\n  const previousReadOnlyMode = isReadOnlyMode;\n  const previousActiveEditor = activeEditor;\n  const previouslyUpdating = editor._updating;\n  activeEditorState = pendingEditorState;\n  isReadOnlyMode = false;\n  editor._updating = true;\n  activeEditor = editor;\n\n  try {\n    if (editorStateWasCloned) {\n      if (editor._headless) {\n        if (currentEditorState._selection != null) {\n          pendingEditorState._selection = currentEditorState._selection.clone();\n        }\n      } else {\n        pendingEditorState._selection = internalCreateSelection(editor);\n      }\n    }\n\n    const startingCompositionKey = editor._compositionKey;\n    updateFn();\n    skipTransforms = processNestedUpdates(editor, skipTransforms);\n    applySelectionTransforms(pendingEditorState, editor);\n\n    if (editor._dirtyType !== NO_DIRTY_NODES) {\n      if (skipTransforms) {\n        $normalizeAllDirtyTextNodes(pendingEditorState, editor);\n      } else {\n        $applyAllTransforms(pendingEditorState, editor);\n      }\n\n      processNestedUpdates(editor);\n      $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);\n    }\n\n    const endingCompositionKey = editor._compositionKey;\n\n    if (startingCompositionKey !== endingCompositionKey) {\n      pendingEditorState._flushSync = true;\n    }\n\n    const pendingSelection = pendingEditorState._selection;\n\n    if ($isRangeSelection(pendingSelection)) {\n      const pendingNodeMap = pendingEditorState._nodeMap;\n      const anchorKey = pendingSelection.anchor.key;\n      const focusKey = pendingSelection.focus.key;\n\n      if (pendingNodeMap.get(anchorKey) === undefined || pendingNodeMap.get(focusKey) === undefined) {\n        {\n          throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);\n        }\n      }\n    } else if ($isNodeSelection(pendingSelection)) {\n      // TODO: we should also validate node selection?\n      if (pendingSelection._nodes.size === 0) {\n        pendingEditorState._selection = null;\n      }\n    }\n  } catch (error) {\n    // Report errors\n    if (error instanceof Error) {\n      editor._onError(error);\n    } // Restore existing editor state to the DOM\n\n\n    editor._pendingEditorState = currentEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n\n    editor._cloneNotNeeded.clear();\n\n    editor._dirtyLeaves = new Set();\n\n    editor._dirtyElements.clear();\n\n    commitPendingUpdates(editor);\n    return;\n  } finally {\n    activeEditorState = previousActiveEditorState;\n    isReadOnlyMode = previousReadOnlyMode;\n    activeEditor = previousActiveEditor;\n    editor._updating = previouslyUpdating;\n    infiniteTransformCount = 0;\n  }\n\n  const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);\n\n  if (shouldUpdate) {\n    if (pendingEditorState._flushSync) {\n      pendingEditorState._flushSync = false;\n      commitPendingUpdates(editor);\n    } else if (editorStateWasCloned) {\n      scheduleMicroTask(() => {\n        commitPendingUpdates(editor);\n      });\n    }\n  } else {\n    pendingEditorState._flushSync = false;\n\n    if (editorStateWasCloned) {\n      updateTags.clear();\n      editor._deferred = [];\n      editor._pendingEditorState = null;\n    }\n  }\n}\n\nfunction updateEditor(editor, updateFn, options) {\n  if (editor._updating) {\n    editor._updates.push([updateFn, options]);\n  } else {\n    beginUpdate(editor, updateFn, options);\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/** @noInheritDoc */\n\nclass DecoratorNode extends LexicalNode {\n  constructor(key) {\n    super(key);\n  }\n\n  decorate(editor, config) {\n    {\n      throw Error(`decorate: base method not extended`);\n    }\n  }\n\n  isIsolated() {\n    return false;\n  }\n\n  isInline() {\n    return true;\n  }\n\n  isKeyboardSelectable() {\n    return true;\n  }\n\n}\nfunction $isDecoratorNode(node) {\n  return node instanceof DecoratorNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ElementNode extends LexicalNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(key) {\n    super(key);\n    this.__first = null;\n    this.__last = null;\n    this.__size = 0;\n    this.__format = 0;\n    this.__indent = 0;\n    this.__dir = null;\n  }\n\n  getFormat() {\n    const self = this.getLatest();\n    return self.__format;\n  }\n\n  getFormatType() {\n    const format = this.getFormat();\n    return ELEMENT_FORMAT_TO_TYPE[format] || '';\n  }\n\n  getIndent() {\n    const self = this.getLatest();\n    return self.__indent;\n  }\n\n  getChildren() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenKeys() {\n    const children = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      children.push(child.__key);\n      child = child.getNextSibling();\n    }\n\n    return children;\n  }\n\n  getChildrenSize() {\n    const self = this.getLatest();\n    return self.__size;\n  }\n\n  isEmpty() {\n    return this.getChildrenSize() === 0;\n  }\n\n  isDirty() {\n    const editor = getActiveEditor();\n    const dirtyElements = editor._dirtyElements;\n    return dirtyElements !== null && dirtyElements.has(this.__key);\n  }\n\n  isLastChild() {\n    const self = this.getLatest();\n    const parentLastChild = this.getParentOrThrow().getLastChild();\n    return parentLastChild !== null && parentLastChild.is(self);\n  }\n\n  getAllTextNodes() {\n    const textNodes = [];\n    let child = this.getFirstChild();\n\n    while (child !== null) {\n      if ($isTextNode(child)) {\n        textNodes.push(child);\n      }\n\n      if ($isElementNode(child)) {\n        const subChildrenNodes = child.getAllTextNodes();\n        textNodes.push(...subChildrenNodes);\n      }\n\n      child = child.getNextSibling();\n    }\n\n    return textNodes;\n  }\n\n  getFirstDescendant() {\n    let node = this.getFirstChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getFirstChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getLastDescendant() {\n    let node = this.getLastChild();\n\n    while (node !== null) {\n      if ($isElementNode(node)) {\n        const child = node.getLastChild();\n\n        if (child !== null) {\n          node = child;\n          continue;\n        }\n      }\n\n      break;\n    }\n\n    return node;\n  }\n\n  getDescendantByIndex(index) {\n    const children = this.getChildren();\n    const childrenLength = children.length; // For non-empty element nodes, we resolve its descendant\n    // (either a leaf node or the bottom-most element)\n\n    if (index >= childrenLength) {\n      const resolvedNode = children[childrenLength - 1];\n      return $isElementNode(resolvedNode) && resolvedNode.getLastDescendant() || resolvedNode || null;\n    }\n\n    const resolvedNode = children[index];\n    return $isElementNode(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;\n  }\n\n  getFirstChild() {\n    const self = this.getLatest();\n    const firstKey = self.__first;\n    return firstKey === null ? null : $getNodeByKey(firstKey);\n  }\n\n  getFirstChildOrThrow() {\n    const firstChild = this.getFirstChild();\n\n    if (firstChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a first child.`);\n      }\n    }\n\n    return firstChild;\n  }\n\n  getLastChild() {\n    const self = this.getLatest();\n    const lastKey = self.__last;\n    return lastKey === null ? null : $getNodeByKey(lastKey);\n  }\n\n  getLastChildOrThrow() {\n    const lastChild = this.getLastChild();\n\n    if (lastChild === null) {\n      {\n        throw Error(`Expected node ${this.__key} to have a last child.`);\n      }\n    }\n\n    return lastChild;\n  }\n\n  getChildAtIndex(index) {\n    const size = this.getChildrenSize();\n    let node;\n    let i;\n\n    if (index < size / 2) {\n      node = this.getFirstChild();\n      i = 0;\n\n      while (node !== null && i <= index) {\n        if (i === index) {\n          return node;\n        }\n\n        node = node.getNextSibling();\n        i++;\n      }\n\n      return null;\n    }\n\n    node = this.getLastChild();\n    i = size - 1;\n\n    while (node !== null && i >= index) {\n      if (i === index) {\n        return node;\n      }\n\n      node = node.getPreviousSibling();\n      i--;\n    }\n\n    return null;\n  }\n\n  getTextContent() {\n    let textContent = '';\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContent += child.getTextContent();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContent += DOUBLE_LINE_BREAK;\n      }\n    }\n\n    return textContent;\n  }\n\n  getTextContentSize() {\n    let textContentSize = 0;\n    const children = this.getChildren();\n    const childrenLength = children.length;\n\n    for (let i = 0; i < childrenLength; i++) {\n      const child = children[i];\n      textContentSize += child.getTextContentSize();\n\n      if ($isElementNode(child) && i !== childrenLength - 1 && !child.isInline()) {\n        textContentSize += DOUBLE_LINE_BREAK.length;\n      }\n    }\n\n    return textContentSize;\n  }\n\n  getDirection() {\n    const self = this.getLatest();\n    return self.__dir;\n  }\n\n  hasFormat(type) {\n    if (type !== '') {\n      const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];\n      return (this.getFormat() & formatFlag) !== 0;\n    }\n\n    return false;\n  } // Mutators\n\n\n  select(_anchorOffset, _focusOffset) {\n    errorOnReadOnly();\n    const selection = $getSelection();\n    let anchorOffset = _anchorOffset;\n    let focusOffset = _focusOffset;\n    const childrenCount = this.getChildrenSize();\n\n    if (!this.canBeEmpty()) {\n      if (_anchorOffset === 0 && _focusOffset === 0) {\n        const firstChild = this.getFirstChild();\n\n        if ($isTextNode(firstChild) || $isElementNode(firstChild)) {\n          return firstChild.select(0, 0);\n        }\n      } else if ((_anchorOffset === undefined || _anchorOffset === childrenCount) && (_focusOffset === undefined || _focusOffset === childrenCount)) {\n        const lastChild = this.getLastChild();\n\n        if ($isTextNode(lastChild) || $isElementNode(lastChild)) {\n          return lastChild.select();\n        }\n      }\n    }\n\n    if (anchorOffset === undefined) {\n      anchorOffset = childrenCount;\n    }\n\n    if (focusOffset === undefined) {\n      focusOffset = childrenCount;\n    }\n\n    const key = this.__key;\n\n    if (!$isRangeSelection(selection)) {\n      return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, 'element', 'element');\n    } else {\n      selection.anchor.set(key, anchorOffset, 'element');\n      selection.focus.set(key, focusOffset, 'element');\n      selection.dirty = true;\n    }\n\n    return selection;\n  }\n\n  selectStart() {\n    const firstNode = this.getFirstDescendant();\n\n    if ($isElementNode(firstNode) || $isTextNode(firstNode)) {\n      return firstNode.select(0, 0);\n    } // Decorator or LineBreak\n\n\n    if (firstNode !== null) {\n      return firstNode.selectPrevious();\n    }\n\n    return this.select(0, 0);\n  }\n\n  selectEnd() {\n    const lastNode = this.getLastDescendant();\n\n    if ($isElementNode(lastNode) || $isTextNode(lastNode)) {\n      return lastNode.select();\n    } // Decorator or LineBreak\n\n\n    if (lastNode !== null) {\n      return lastNode.selectNext();\n    }\n\n    return this.select();\n  }\n\n  clear() {\n    const writableSelf = this.getWritable();\n    const children = this.getChildren();\n    children.forEach(child => child.remove());\n    return writableSelf;\n  }\n\n  append(...nodesToAppend) {\n    return this.splice(this.getChildrenSize(), 0, nodesToAppend);\n  }\n\n  setDirection(direction) {\n    const self = this.getWritable();\n    self.__dir = direction;\n    return self;\n  }\n\n  setFormat(type) {\n    const self = this.getWritable();\n    self.__format = type !== '' ? ELEMENT_TYPE_TO_FORMAT[type] : 0;\n    return this;\n  }\n\n  setIndent(indentLevel) {\n    const self = this.getWritable();\n    self.__indent = indentLevel;\n    return this;\n  }\n\n  splice(start, deleteCount, nodesToInsert) {\n    const nodesToInsertLength = nodesToInsert.length;\n    const oldSize = this.getChildrenSize();\n    const writableSelf = this.getWritable();\n    const writableSelfKey = writableSelf.__key;\n    const nodesToInsertKeys = [];\n    const nodesToRemoveKeys = [];\n    const nodeAfterRange = this.getChildAtIndex(start + deleteCount);\n    let nodeBeforeRange = null;\n    let newSize = oldSize - deleteCount + nodesToInsertLength;\n\n    if (start !== 0) {\n      if (start === oldSize) {\n        nodeBeforeRange = this.getLastChild();\n      } else {\n        const node = this.getChildAtIndex(start);\n\n        if (node !== null) {\n          nodeBeforeRange = node.getPreviousSibling();\n        }\n      }\n    }\n\n    if (deleteCount > 0) {\n      let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();\n\n      for (let i = 0; i < deleteCount; i++) {\n        if (nodeToDelete === null) {\n          {\n            throw Error(`splice: sibling not found`);\n          }\n        }\n\n        const nextSibling = nodeToDelete.getNextSibling();\n        const nodeKeyToDelete = nodeToDelete.__key;\n        const writableNodeToDelete = nodeToDelete.getWritable();\n        removeFromParent(writableNodeToDelete);\n        nodesToRemoveKeys.push(nodeKeyToDelete);\n        nodeToDelete = nextSibling;\n      }\n    }\n\n    let prevNode = nodeBeforeRange;\n\n    for (let i = 0; i < nodesToInsertLength; i++) {\n      const nodeToInsert = nodesToInsert[i];\n\n      if (prevNode !== null && nodeToInsert.is(prevNode)) {\n        nodeBeforeRange = prevNode = prevNode.getPreviousSibling();\n      }\n\n      const writableNodeToInsert = nodeToInsert.getWritable();\n\n      if (writableNodeToInsert.__parent === writableSelfKey) {\n        newSize--;\n      }\n\n      removeFromParent(writableNodeToInsert);\n      const nodeKeyToInsert = nodeToInsert.__key;\n\n      if (prevNode === null) {\n        writableSelf.__first = nodeKeyToInsert;\n        writableNodeToInsert.__prev = null;\n      } else {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = nodeKeyToInsert;\n        writableNodeToInsert.__prev = writablePrevNode.__key;\n      }\n\n      if (nodeToInsert.__key === writableSelfKey) {\n        {\n          throw Error(`append: attempting to append self`);\n        }\n      } // Set child parent to self\n\n\n      writableNodeToInsert.__parent = writableSelfKey;\n      nodesToInsertKeys.push(nodeKeyToInsert);\n      prevNode = nodeToInsert;\n    }\n\n    if (start + deleteCount === oldSize) {\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writablePrevNode.__next = null;\n        writableSelf.__last = prevNode.__key;\n      }\n    } else if (nodeAfterRange !== null) {\n      const writableNodeAfterRange = nodeAfterRange.getWritable();\n\n      if (prevNode !== null) {\n        const writablePrevNode = prevNode.getWritable();\n        writableNodeAfterRange.__prev = prevNode.__key;\n        writablePrevNode.__next = nodeAfterRange.__key;\n      } else {\n        writableNodeAfterRange.__prev = null;\n      }\n    }\n\n    writableSelf.__size = newSize; // In case of deletion we need to adjust selection, unlink removed nodes\n    // and clean up node itself if it becomes empty. None of these needed\n    // for insertion-only cases\n\n    if (nodesToRemoveKeys.length) {\n      // Adjusting selection, in case node that was anchor/focus will be deleted\n      const selection = $getSelection();\n\n      if ($isRangeSelection(selection)) {\n        const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);\n        const nodesToInsertKeySet = new Set(nodesToInsertKeys);\n        const {\n          anchor,\n          focus\n        } = selection;\n\n        if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        }\n\n        if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {\n          moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);\n        } // Cleanup if node can't be empty\n\n\n        if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot(this)) {\n          this.remove();\n        }\n      }\n    }\n\n    return writableSelf;\n  } // JSON serialization\n\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'element',\n      version: 1\n    };\n  } // These are intended to be extends for specific element heuristics.\n\n\n  insertNewAfter(selection, restoreSelection) {\n    return null;\n  }\n\n  canIndent() {\n    return true;\n  }\n  /*\n   * This method controls the behavior of a the node during backwards\n   * deletion (i.e., backspace) when selection is at the beginning of\n   * the node (offset 0)\n   */\n\n\n  collapseAtStart(selection) {\n    return false;\n  }\n\n  excludeFromCopy(destination) {\n    return false;\n  } // TODO 0.10 deprecate\n\n\n  canExtractContents() {\n    return true;\n  }\n\n  canReplaceWith(replacement) {\n    return true;\n  }\n\n  canInsertAfter(node) {\n    return true;\n  }\n\n  canBeEmpty() {\n    return true;\n  }\n\n  canInsertTextBefore() {\n    return true;\n  }\n\n  canInsertTextAfter() {\n    return true;\n  }\n\n  isInline() {\n    return false;\n  } // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the\n  // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)\n  // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode\n  // will return the immediate first child underneath TableCellNode instead of RootNode.\n\n\n  isShadowRoot() {\n    return false;\n  }\n\n  canMergeWith(node) {\n    return false;\n  }\n\n  extractWithChild(child, selection, destination) {\n    return false;\n  }\n\n}\nfunction $isElementNode(node) {\n  return node instanceof ElementNode;\n}\n\nfunction isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {\n  let node = point.getNode();\n\n  while (node) {\n    const nodeKey = node.__key;\n\n    if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {\n      return true;\n    }\n\n    node = node.getParent();\n  }\n\n  return false;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass RootNode extends ElementNode {\n  /** @internal */\n  static getType() {\n    return 'root';\n  }\n\n  static clone() {\n    return new RootNode();\n  }\n\n  constructor() {\n    super('root');\n    this.__cachedText = null;\n  }\n\n  getTopLevelElementOrThrow() {\n    {\n      throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);\n    }\n  }\n\n  getTextContent() {\n    const cachedText = this.__cachedText;\n\n    if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {\n      if (cachedText !== null) {\n        return cachedText;\n      }\n    }\n\n    return super.getTextContent();\n  }\n\n  remove() {\n    {\n      throw Error(`remove: cannot be called on root nodes`);\n    }\n  }\n\n  replace(node) {\n    {\n      throw Error(`replace: cannot be called on root nodes`);\n    }\n  }\n\n  insertBefore(nodeToInsert) {\n    {\n      throw Error(`insertBefore: cannot be called on root nodes`);\n    }\n  }\n\n  insertAfter(nodeToInsert) {\n    {\n      throw Error(`insertAfter: cannot be called on root nodes`);\n    }\n  } // View\n\n\n  updateDOM(prevNode, dom) {\n    return false;\n  } // Mutate\n\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const node = nodesToAppend[i];\n\n      if (!$isElementNode(node) && !$isDecoratorNode(node)) {\n        {\n          throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);\n        }\n      }\n    }\n\n    return super.append(...nodesToAppend);\n  }\n\n  static importJSON(serializedNode) {\n    // We don't create a root, and instead use the existing root.\n    const node = $getRoot();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return {\n      children: [],\n      direction: this.getDirection(),\n      format: this.getFormatType(),\n      indent: this.getIndent(),\n      type: 'root',\n      version: 1\n    };\n  }\n\n  collapseAtStart() {\n    return true;\n  }\n\n}\nfunction $createRootNode() {\n  return new RootNode();\n}\nfunction $isRootNode(node) {\n  return node instanceof RootNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction editorStateHasDirtySelection(editorState, editor) {\n  const currentSelection = editor.getEditorState()._selection;\n\n  const pendingSelection = editorState._selection; // Check if we need to update because of changes in selection\n\n  if (pendingSelection !== null) {\n    if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {\n      return true;\n    }\n  } else if (currentSelection !== null) {\n    return true;\n  }\n\n  return false;\n}\nfunction cloneEditorState(current) {\n  return new EditorState(new Map(current._nodeMap));\n}\nfunction createEmptyEditorState() {\n  return new EditorState(new Map([['root', $createRootNode()]]));\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if ($isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n      const serializedChildNode = exportNodeToJSON(child);\n      serializedChildren.push(serializedChildNode);\n    }\n  } // @ts-expect-error\n\n\n  return serializedNode;\n}\n\nclass EditorState {\n  constructor(nodeMap, selection) {\n    this._nodeMap = nodeMap;\n    this._selection = selection || null;\n    this._flushSync = false;\n    this._readOnly = false;\n  }\n\n  isEmpty() {\n    return this._nodeMap.size === 1 && this._selection === null;\n  }\n\n  read(callbackFn) {\n    return readEditorState(this, callbackFn);\n  }\n\n  clone(selection) {\n    const editorState = new EditorState(this._nodeMap, selection === undefined ? this._selection : selection);\n    editorState._readOnly = true;\n    return editorState;\n  }\n\n  toJSON() {\n    return readEditorState(this, () => ({\n      root: exportNodeToJSON($getRoot())\n    }));\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ParagraphNode extends ElementNode {\n  static getType() {\n    return 'paragraph';\n  }\n\n  static clone(node) {\n    return new ParagraphNode(node.__key);\n  } // View\n\n\n  createDOM(config) {\n    const dom = document.createElement('p');\n    const classNames = getCachedClassNameArray(config.theme, 'paragraph');\n\n    if (classNames !== undefined) {\n      const domClassList = dom.classList;\n      domClassList.add(...classNames);\n    }\n\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      p: node => ({\n        conversion: convertParagraphElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n\n      const indent = this.getIndent();\n\n      if (indent > 0) {\n        // padding-inline-start is not widely supported in email HTML, but\n        // Lexical Reconciler uses padding-inline-start. Using text-indent instead.\n        element.style.textIndent = `${indent * 20}px`;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createParagraphNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'paragraph',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newElement = $createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const children = this.getChildren(); // If we have an empty (trimmed) first paragraph and try and remove it,\n    // delete the paragraph as long as we have another sibling to go to\n\n    if (children.length === 0 || $isTextNode(children[0]) && children[0].getTextContent().trim() === '') {\n      const nextSibling = this.getNextSibling();\n\n      if (nextSibling !== null) {\n        this.selectNext();\n        this.remove();\n        return true;\n      }\n\n      const prevSibling = this.getPreviousSibling();\n\n      if (prevSibling !== null) {\n        this.selectPrevious();\n        this.remove();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n}\n\nfunction convertParagraphElement(element) {\n  const node = $createParagraphNode();\n\n  if (element.style) {\n    node.setFormat(element.style.textAlign);\n    const indent = parseInt(element.style.textIndent, 10) / 20;\n\n    if (indent > 0) {\n      node.setIndent(indent);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createParagraphNode() {\n  return $applyNodeReplacement(new ParagraphNode());\n}\nfunction $isParagraphNode(node) {\n  return node instanceof ParagraphNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst COMMAND_PRIORITY_EDITOR = 0;\nconst COMMAND_PRIORITY_LOW = 1;\nconst COMMAND_PRIORITY_NORMAL = 2;\nconst COMMAND_PRIORITY_HIGH = 3;\nconst COMMAND_PRIORITY_CRITICAL = 4; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\nfunction resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {\n  const keyNodeMap = editor._keyToDOMMap;\n  keyNodeMap.clear();\n  editor._editorState = createEmptyEditorState();\n  editor._pendingEditorState = pendingEditorState;\n  editor._compositionKey = null;\n  editor._dirtyType = NO_DIRTY_NODES;\n\n  editor._cloneNotNeeded.clear();\n\n  editor._dirtyLeaves = new Set();\n\n  editor._dirtyElements.clear();\n\n  editor._normalizedNodes = new Set();\n  editor._updateTags = new Set();\n  editor._updates = [];\n  editor._blockCursorElement = null;\n  const observer = editor._observer;\n\n  if (observer !== null) {\n    observer.disconnect();\n    editor._observer = null;\n  } // Remove all the DOM nodes from the root element\n\n\n  if (prevRootElement !== null) {\n    prevRootElement.textContent = '';\n  }\n\n  if (nextRootElement !== null) {\n    nextRootElement.textContent = '';\n    keyNodeMap.set('root', nextRootElement);\n  }\n}\n\nfunction initializeConversionCache(nodes) {\n  const conversionCache = new Map();\n  const handledConversions = new Set();\n  nodes.forEach(node => {\n    const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;\n\n    if (importDOM == null || handledConversions.has(importDOM)) {\n      return;\n    }\n\n    handledConversions.add(importDOM);\n    const map = importDOM();\n\n    if (map !== null) {\n      Object.keys(map).forEach(key => {\n        let currentCache = conversionCache.get(key);\n\n        if (currentCache === undefined) {\n          currentCache = [];\n          conversionCache.set(key, currentCache);\n        }\n\n        currentCache.push(map[key]);\n      });\n    }\n  });\n  return conversionCache;\n}\n/**\n * Creates a new LexicalEditor attached to a single contentEditable (provided in the config). This is\n * the lowest-level initialization API for a LexicalEditor. If you're using React or another framework,\n * consider using the appropriate abstractions, such as LexicalComposer\n * @param editorConfig - the editor configuration.\n * @returns a LexicalEditor instance\n */\n\n\nfunction createEditor(editorConfig) {\n  const config = editorConfig || {};\n  const activeEditor = internalGetActiveEditor();\n  const theme = config.theme || {};\n  const parentEditor = editorConfig === undefined ? activeEditor : config.parentEditor || null;\n  const disableEvents = config.disableEvents || false;\n  const editorState = createEmptyEditorState();\n  const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());\n  const initialEditorState = config.editorState;\n  const nodes = [RootNode, TextNode, LineBreakNode, TabNode, ParagraphNode, ...(config.nodes || [])];\n  const onError = config.onError;\n  const isEditable = config.editable !== undefined ? config.editable : true;\n  let registeredNodes;\n\n  if (editorConfig === undefined && activeEditor !== null) {\n    registeredNodes = activeEditor._nodes;\n  } else {\n    registeredNodes = new Map();\n\n    for (let i = 0; i < nodes.length; i++) {\n      let klass = nodes[i];\n      let replacementClass = null;\n      let replacementKlass = null;\n\n      if (typeof klass !== 'function') {\n        const options = klass;\n        klass = options.replace;\n        replacementClass = options.with;\n        replacementKlass = options.withKlass ? options.withKlass : null;\n      } // Ensure custom nodes implement required methods.\n\n\n      {\n        const name = klass.name;\n\n        if (name !== 'RootNode') {\n          const proto = klass.prototype;\n          ['getType', 'clone'].forEach(method => {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!klass.hasOwnProperty(method)) {\n              console.warn(`${name} must implement static \"${method}\" method`);\n            }\n          });\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importDOM') && // eslint-disable-next-line no-prototype-builtins\n          klass.hasOwnProperty('exportDOM')) {\n            console.warn(`${name} should implement \"importDOM\" if using a custom \"exportDOM\" method to ensure HTML serialization (important for copy & paste) works as expected`);\n          }\n\n          if (proto instanceof DecoratorNode) {\n            // eslint-disable-next-line no-prototype-builtins\n            if (!proto.hasOwnProperty('decorate')) {\n              console.warn(`${proto.constructor.name} must implement \"decorate\" method`);\n            }\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !klass.hasOwnProperty('importJSON')) {\n            console.warn(`${name} should implement \"importJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n\n          if ( // eslint-disable-next-line no-prototype-builtins\n          !proto.hasOwnProperty('exportJSON')) {\n            console.warn(`${name} should implement \"exportJSON\" method to ensure JSON and default HTML serialization works as expected`);\n          }\n        }\n      }\n\n      const type = klass.getType();\n      const transform = klass.transform();\n      const transforms = new Set();\n\n      if (transform !== null) {\n        transforms.add(transform);\n      }\n\n      registeredNodes.set(type, {\n        klass,\n        replace: replacementClass,\n        replaceWithKlass: replacementKlass,\n        transforms\n      });\n    }\n  }\n\n  const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {\n    disableEvents,\n    namespace,\n    theme\n  }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);\n\n  if (initialEditorState !== undefined) {\n    editor._pendingEditorState = initialEditorState;\n    editor._dirtyType = FULL_RECONCILE;\n  }\n\n  return editor;\n}\nclass LexicalEditor {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {\n    this._parentEditor = parentEditor; // The root element associated with this editor\n\n    this._rootElement = null; // The current editor state\n\n    this._editorState = editorState; // Handling of drafts and updates\n\n    this._pendingEditorState = null; // Used to help co-ordinate selection and events\n\n    this._compositionKey = null;\n    this._deferred = []; // Used during reconciliation\n\n    this._keyToDOMMap = new Map();\n    this._updates = [];\n    this._updating = false; // Listeners\n\n    this._listeners = {\n      decorator: new Set(),\n      editable: new Set(),\n      mutation: new Map(),\n      root: new Set(),\n      textcontent: new Set(),\n      update: new Set()\n    }; // Commands\n\n    this._commands = new Map(); // Editor configuration for theme/context.\n\n    this._config = config; // Mapping of types to their nodes\n\n    this._nodes = nodes; // React node decorators for portals\n\n    this._decorators = {};\n    this._pendingDecorators = null; // Used to optimize reconciliation\n\n    this._dirtyType = NO_DIRTY_NODES;\n    this._cloneNotNeeded = new Set();\n    this._dirtyLeaves = new Set();\n    this._dirtyElements = new Map();\n    this._normalizedNodes = new Set();\n    this._updateTags = new Set(); // Handling of DOM mutations\n\n    this._observer = null; // Used for identifying owning editors\n\n    this._key = createUID();\n    this._onError = onError;\n    this._htmlConversions = htmlConversions;\n    this._editable = editable;\n    this._headless = parentEditor !== null && parentEditor._headless;\n    this._window = null;\n    this._blockCursorElement = null;\n  }\n  /**\n   *\n   * @returns true if the editor is currently in \"composition\" mode due to receiving input\n   * through an IME, or 3P extension, for example. Returns false otherwise.\n   */\n\n\n  isComposing() {\n    return this._compositionKey != null;\n  }\n  /**\n   * Registers a listener for Editor update event. Will trigger the provided callback\n   * each time the editor goes through an update (via {@link LexicalEditor.update}) until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerUpdateListener(listener) {\n    const listenerSetOrMap = this._listeners.update;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for for when the editor changes between editable and non-editable states.\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerEditableListener(listener) {\n    const listenerSetOrMap = this._listeners.editable;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's decorator object changes. The decorator object contains\n   * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerDecoratorListener(listener) {\n    const listenerSetOrMap = this._listeners.decorator;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when Lexical commits an update to the DOM and the text content of\n   * the editor changes from the previous state of the editor. If the text content is the\n   * same between updates, no notifications to the listeners will happen.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerTextContentListener(listener) {\n    const listenerSetOrMap = this._listeners.textcontent;\n    listenerSetOrMap.add(listener);\n    return () => {\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener for when the editor's root DOM element (the content editable\n   * Lexical attaches to) changes. This is primarily used to attach event listeners to the root\n   *  element. The root listener function is executed directly upon registration and then on\n   * any subsequent update.\n   *\n   * Will trigger the provided callback each time the editor transitions between these states until the\n   * teardown function is called.\n   *\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerRootListener(listener) {\n    const listenerSetOrMap = this._listeners.root;\n    listener(this._rootElement, null);\n    listenerSetOrMap.add(listener);\n    return () => {\n      listener(null, this._rootElement);\n      listenerSetOrMap.delete(listener);\n    };\n  }\n  /**\n   * Registers a listener that will trigger anytime the provided command\n   * is dispatched, subject to priority. Listeners that run at a higher priority can \"intercept\"\n   * commands and prevent them from propagating to other handlers by returning true.\n   *\n   * Listeners registered at the same priority level will run deterministically in the order of registration.\n   *\n   * @param command - the command that will trigger the callback.\n   * @param listener - the function that will execute when the command is dispatched.\n   * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerCommand(command, listener, priority) {\n    if (priority === undefined) {\n      {\n        throw Error(`Listener for type \"command\" requires a \"priority\".`);\n      }\n    }\n\n    const commandsMap = this._commands;\n\n    if (!commandsMap.has(command)) {\n      commandsMap.set(command, [new Set(), new Set(), new Set(), new Set(), new Set()]);\n    }\n\n    const listenersInPriorityOrder = commandsMap.get(command);\n\n    if (listenersInPriorityOrder === undefined) {\n      {\n        throw Error(`registerCommand: Command ${String(command)} not found in command map`);\n      }\n    }\n\n    const listeners = listenersInPriorityOrder[priority];\n    listeners.add(listener);\n    return () => {\n      listeners.delete(listener);\n\n      if (listenersInPriorityOrder.every(listenersSet => listenersSet.size === 0)) {\n        commandsMap.delete(command);\n      }\n    };\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * mutated. The listener will receive a list of nodes along with the type of mutation\n   * that was performed on each: created, destroyed, or updated.\n   *\n   * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.\n   * {@link LexicalEditor.getElementByKey} can be used for this.\n   *\n   * @param klass - The class of the node that you want to listen to mutations on.\n   * @param listener - The logic you want to run when the node is mutated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerMutationListener(klass, listener) {\n    const registeredNode = this._nodes.get(klass.getType());\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const mutations = this._listeners.mutation;\n    mutations.set(listener, klass);\n    return () => {\n      mutations.delete(listener);\n    };\n  }\n  /** @internal */\n\n\n  registerNodeTransformToKlass(klass, listener) {\n    const type = klass.getType();\n\n    const registeredNode = this._nodes.get(type);\n\n    if (registeredNode === undefined) {\n      {\n        throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);\n      }\n    }\n\n    const transforms = registeredNode.transforms;\n    transforms.add(listener);\n    return registeredNode;\n  }\n  /**\n   * Registers a listener that will run when a Lexical node of the provided class is\n   * marked dirty during an update. The listener will continue to run as long as the node\n   * is marked dirty. There are no guarantees around the order of transform execution!\n   *\n   * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)\n   * @param klass - The class of the node that you want to run transforms on.\n   * @param listener - The logic you want to run when the node is updated.\n   * @returns a teardown function that can be used to cleanup the listener.\n   */\n\n\n  registerNodeTransform(klass, listener) {\n    const registeredNode = this.registerNodeTransformToKlass(klass, listener);\n    const registeredNodes = [registeredNode];\n    const replaceWithKlass = registeredNode.replaceWithKlass;\n\n    if (replaceWithKlass != null) {\n      const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);\n      registeredNodes.push(registeredReplaceWithNode);\n    }\n\n    markAllNodesAsDirty(this, klass.getType());\n    return () => {\n      registeredNodes.forEach(node => node.transforms.delete(listener));\n    };\n  }\n  /**\n   * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered the provided node type, false otherwise.\n   */\n\n\n  hasNode(node) {\n    return this._nodes.has(node.getType());\n  }\n  /**\n   * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they\n   * depend on have been registered.\n   * @returns True if the editor has registered all of the provided node types, false otherwise.\n   */\n\n\n  hasNodes(nodes) {\n    return nodes.every(this.hasNode.bind(this));\n  }\n  /**\n   * Dispatches a command of the specified type with the specified payload.\n   * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})\n   * for this type, passing them the provided payload.\n   * @param type - the type of command listeners to trigger.\n   * @param payload - the data to pass as an argument to the command listeners.\n   */\n\n\n  dispatchCommand(type, payload) {\n    return dispatchCommand(this, type, payload);\n  }\n  /**\n   * Gets a map of all decorators in the editor.\n   * @returns A mapping of call decorator keys to their decorated content\n   */\n\n\n  getDecorators() {\n    return this._decorators;\n  }\n  /**\n   *\n   * @returns the current root element of the editor. If you want to register\n   * an event listener, do it via {@link LexicalEditor.registerRootListener}, since\n   * this reference may not be stable.\n   */\n\n\n  getRootElement() {\n    return this._rootElement;\n  }\n  /**\n   * Gets the key of the editor\n   * @returns The editor key\n   */\n\n\n  getKey() {\n    return this._key;\n  }\n  /**\n   * Imperatively set the root contenteditable element that Lexical listens\n   * for events on.\n   */\n\n\n  setRootElement(nextRootElement) {\n    const prevRootElement = this._rootElement;\n\n    if (nextRootElement !== prevRootElement) {\n      const classNames = getCachedClassNameArray(this._config.theme, 'root');\n      const pendingEditorState = this._pendingEditorState || this._editorState;\n      this._rootElement = nextRootElement;\n      resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);\n\n      if (prevRootElement !== null) {\n        // TODO: remove this flag once we no longer use UEv2 internally\n        if (!this._config.disableEvents) {\n          removeRootElementEvents(prevRootElement);\n        }\n\n        if (classNames != null) {\n          prevRootElement.classList.remove(...classNames);\n        }\n      }\n\n      if (nextRootElement !== null) {\n        const windowObj = getDefaultView(nextRootElement);\n        const style = nextRootElement.style;\n        style.userSelect = 'text';\n        style.whiteSpace = 'pre-wrap';\n        style.wordBreak = 'break-word';\n        nextRootElement.setAttribute('data-lexical-editor', 'true');\n        this._window = windowObj;\n        this._dirtyType = FULL_RECONCILE;\n        initMutationObserver(this);\n\n        this._updateTags.add('history-merge');\n\n        commitPendingUpdates(this); // TODO: remove this flag once we no longer use UEv2 internally\n\n        if (!this._config.disableEvents) {\n          addRootElementEvents(nextRootElement, this);\n        }\n\n        if (classNames != null) {\n          nextRootElement.classList.add(...classNames);\n        }\n      } else {\n        // If content editable is unmounted we'll reset editor state back to original\n        // (or pending) editor state since there will be no reconciliation\n        this._editorState = pendingEditorState;\n        this._pendingEditorState = null;\n        this._window = null;\n      }\n\n      triggerListeners('root', this, false, nextRootElement, prevRootElement);\n    }\n  }\n  /**\n   * Gets the underlying HTMLElement associated with the LexicalNode for the given key.\n   * @returns the HTMLElement rendered by the LexicalNode associated with the key.\n   * @param key - the key of the LexicalNode.\n   */\n\n\n  getElementByKey(key) {\n    return this._keyToDOMMap.get(key) || null;\n  }\n  /**\n   * Gets the active editor state.\n   * @returns The editor state\n   */\n\n\n  getEditorState() {\n    return this._editorState;\n  }\n  /**\n   * Imperatively set the EditorState. Triggers reconciliation like an update.\n   * @param editorState - the state to set the editor\n   * @param options - options for the update.\n   */\n\n\n  setEditorState(editorState, options) {\n    if (editorState.isEmpty()) {\n      {\n        throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);\n      }\n    }\n\n    flushRootMutations(this);\n    const pendingEditorState = this._pendingEditorState;\n    const tags = this._updateTags;\n    const tag = options !== undefined ? options.tag : null;\n\n    if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {\n      if (tag != null) {\n        tags.add(tag);\n      }\n\n      commitPendingUpdates(this);\n    }\n\n    this._pendingEditorState = editorState;\n    this._dirtyType = FULL_RECONCILE;\n\n    this._dirtyElements.set('root', false);\n\n    this._compositionKey = null;\n\n    if (tag != null) {\n      tags.add(tag);\n    }\n\n    commitPendingUpdates(this);\n  }\n  /**\n   * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns\n   * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,\n   * deserliazation from JSON stored in a database uses this method.\n   * @param maybeStringifiedEditorState\n   * @param updateFn\n   * @returns\n   */\n\n\n  parseEditorState(maybeStringifiedEditorState, updateFn) {\n    const serializedEditorState = typeof maybeStringifiedEditorState === 'string' ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;\n    return parseEditorState(serializedEditorState, this, updateFn);\n  }\n  /**\n   * Executes an update to the editor state. The updateFn callback is the ONLY place\n   * where Lexical editor state can be safely mutated.\n   * @param updateFn - A function that has access to writable editor state.\n   * @param options - A bag of options to control the behavior of the update.\n   * @param options.onUpdate - A function to run once the update is complete.\n   * Useful for synchronizing updates in some cases.\n   * @param options.skipTransforms - Setting this to true will suppress all node\n   * transforms for this update cycle.\n   * @param options.tag - A tag to identify this update, in an update listener, for instance.\n   * Some tags are reserved by the core and control update behavior in different ways.\n   * @param options.discrete - If true, prevents this update from being batched, forcing it to\n   * run synchronously.\n   */\n\n\n  update(updateFn, options) {\n    updateEditor(this, updateFn, options);\n  }\n  /**\n   * Focuses the editor\n   * @param callbackFn - A function to run after the editor is focused.\n   * @param options - A bag of options\n   * @param options.defaultSelection - Where to move selection when the editor is\n   * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.\n   */\n\n\n  focus(callbackFn, options = {}) {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      // This ensures that iOS does not trigger caps lock upon focus\n      rootElement.setAttribute('autocapitalize', 'off');\n      updateEditor(this, () => {\n        const selection = $getSelection();\n        const root = $getRoot();\n\n        if (selection !== null) {\n          // Marking the selection dirty will force the selection back to it\n          selection.dirty = true;\n        } else if (root.getChildrenSize() !== 0) {\n          if (options.defaultSelection === 'rootStart') {\n            root.selectStart();\n          } else {\n            root.selectEnd();\n          }\n        }\n      }, {\n        onUpdate: () => {\n          rootElement.removeAttribute('autocapitalize');\n\n          if (callbackFn) {\n            callbackFn();\n          }\n        },\n        tag: 'focus'\n      }); // In the case where onUpdate doesn't fire (due to the focus update not\n      // occuring).\n\n      if (this._pendingEditorState === null) {\n        rootElement.removeAttribute('autocapitalize');\n      }\n    }\n  }\n  /**\n   * Removes focus from the editor.\n   */\n\n\n  blur() {\n    const rootElement = this._rootElement;\n\n    if (rootElement !== null) {\n      rootElement.blur();\n    }\n\n    const domSelection = getDOMSelection(this._window);\n\n    if (domSelection !== null) {\n      domSelection.removeAllRanges();\n    }\n  }\n  /**\n   * Returns true if the editor is editable, false otherwise.\n   * @returns True if the editor is editable, false otherwise.\n   */\n\n\n  isEditable() {\n    return this._editable;\n  }\n  /**\n   * Sets the editable property of the editor. When false, the\n   * editor will not listen for user events on the underling contenteditable.\n   * @param editable - the value to set the editable mode to.\n   */\n\n\n  setEditable(editable) {\n    if (this._editable !== editable) {\n      this._editable = editable;\n      triggerListeners('editable', this, true, editable);\n    }\n  }\n  /**\n   * Returns a JSON-serializable javascript object NOT a JSON string.\n   * You still must call JSON.stringify (or something else) to turn the\n   * state into a string you can transfer over the wire and store in a database.\n   *\n   * See {@link LexicalNode.exportJSON}\n   *\n   * @returns A JSON-serializable javascript object\n   */\n\n\n  toJSON() {\n    return {\n      editorState: this._editorState.toJSON()\n    };\n  }\n\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass DEPRECATED_GridCellNode extends ElementNode {\n  /** @internal */\n  constructor(colSpan, key) {\n    super(key);\n    this.__colSpan = colSpan;\n    this.__rowSpan = 1;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      colSpan: this.__colSpan,\n      rowSpan: this.__rowSpan\n    };\n  }\n\n  getColSpan() {\n    return this.__colSpan;\n  }\n\n  setColSpan(colSpan) {\n    this.getWritable().__colSpan = colSpan;\n    return this;\n  }\n\n  getRowSpan() {\n    return this.__rowSpan;\n  }\n\n  setRowSpan(rowSpan) {\n    this.getWritable().__rowSpan = rowSpan;\n    return this;\n  }\n\n}\nfunction DEPRECATED_$isGridCellNode(node) {\n  return node instanceof DEPRECATED_GridCellNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridNode extends ElementNode {}\nfunction DEPRECATED_$isGridNode(node) {\n  return node instanceof DEPRECATED_GridNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nclass DEPRECATED_GridRowNode extends ElementNode {}\nfunction DEPRECATED_$isGridRowNode(node) {\n  return node instanceof DEPRECATED_GridRowNode;\n}\n\nexports.$addUpdateTag = $addUpdateTag;\nexports.$applyNodeReplacement = $applyNodeReplacement;\nexports.$copyNode = $copyNode;\nexports.$createLineBreakNode = $createLineBreakNode;\nexports.$createNodeSelection = $createNodeSelection;\nexports.$createParagraphNode = $createParagraphNode;\nexports.$createRangeSelection = $createRangeSelection;\nexports.$createTabNode = $createTabNode;\nexports.$createTextNode = $createTextNode;\nexports.$getAdjacentNode = $getAdjacentNode;\nexports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;\nexports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;\nexports.$getNodeByKey = $getNodeByKey;\nexports.$getPreviousSelection = $getPreviousSelection;\nexports.$getRoot = $getRoot;\nexports.$getSelection = $getSelection;\nexports.$getTextContent = $getTextContent;\nexports.$hasAncestor = $hasAncestor;\nexports.$hasUpdateTag = $hasUpdateTag;\nexports.$insertNodes = $insertNodes;\nexports.$isBlockElementNode = $isBlockElementNode;\nexports.$isDecoratorNode = $isDecoratorNode;\nexports.$isElementNode = $isElementNode;\nexports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;\nexports.$isLeafNode = $isLeafNode;\nexports.$isLineBreakNode = $isLineBreakNode;\nexports.$isNodeSelection = $isNodeSelection;\nexports.$isParagraphNode = $isParagraphNode;\nexports.$isRangeSelection = $isRangeSelection;\nexports.$isRootNode = $isRootNode;\nexports.$isRootOrShadowRoot = $isRootOrShadowRoot;\nexports.$isTabNode = $isTabNode;\nexports.$isTextNode = $isTextNode;\nexports.$nodesOfType = $nodesOfType;\nexports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;\nexports.$parseSerializedNode = $parseSerializedNode;\nexports.$selectAll = $selectAll;\nexports.$setCompositionKey = $setCompositionKey;\nexports.$setSelection = $setSelection;\nexports.$splitNode = $splitNode;\nexports.BLUR_COMMAND = BLUR_COMMAND;\nexports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;\nexports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;\nexports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;\nexports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;\nexports.CLICK_COMMAND = CLICK_COMMAND;\nexports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL;\nexports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;\nexports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;\nexports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;\nexports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;\nexports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;\nexports.COPY_COMMAND = COPY_COMMAND;\nexports.CUT_COMMAND = CUT_COMMAND;\nexports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;\nexports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;\nexports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;\nexports.DEPRECATED_$computeGridMap = DEPRECATED_$computeGridMap;\nexports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;\nexports.DEPRECATED_$getGridCellNodeRect = DEPRECATED_$getGridCellNodeRect;\nexports.DEPRECATED_$getNodeTriplet = DEPRECATED_$getNodeTriplet;\nexports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;\nexports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;\nexports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;\nexports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;\nexports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;\nexports.DEPRECATED_GridNode = DEPRECATED_GridNode;\nexports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;\nexports.DRAGEND_COMMAND = DRAGEND_COMMAND;\nexports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;\nexports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;\nexports.DROP_COMMAND = DROP_COMMAND;\nexports.DecoratorNode = DecoratorNode;\nexports.ElementNode = ElementNode;\nexports.FOCUS_COMMAND = FOCUS_COMMAND;\nexports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;\nexports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND;\nexports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;\nexports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;\nexports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;\nexports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;\nexports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;\nexports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;\nexports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;\nexports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;\nexports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;\nexports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;\nexports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND;\nexports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;\nexports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;\nexports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;\nexports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;\nexports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;\nexports.LineBreakNode = LineBreakNode;\nexports.MOVE_TO_END = MOVE_TO_END;\nexports.MOVE_TO_START = MOVE_TO_START;\nexports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;\nexports.PASTE_COMMAND = PASTE_COMMAND;\nexports.ParagraphNode = ParagraphNode;\nexports.REDO_COMMAND = REDO_COMMAND;\nexports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;\nexports.RootNode = RootNode;\nexports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND;\nexports.SELECT_ALL_COMMAND = SELECT_ALL_COMMAND;\nexports.TabNode = TabNode;\nexports.TextNode = TextNode;\nexports.UNDO_COMMAND = UNDO_COMMAND;\nexports.createCommand = createCommand;\nexports.createEditor = createEditor;\nexports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;\nexports.isHTMLAnchorElement = isHTMLAnchorElement;\nexports.isHTMLElement = isHTMLElement;\nexports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;\nexports.isSelectionWithinEditor = isSelectionWithinEditor;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst Lexical = process.env.NODE_ENV === 'development' ? require('./Lexical.dev.js') : require('./Lexical.prod.js')\nmodule.exports = Lexical;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CSS_TO_STYLES = new Map();\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction getDOMTextNode(element) {\n  let node = element;\n\n  while (node != null) {\n    if (node.nodeType === Node.TEXT_NODE) {\n      return node;\n    }\n\n    node = node.firstChild;\n  }\n\n  return null;\n}\n\nfunction getDOMIndexWithinParent(node) {\n  const parent = node.parentNode;\n\n  if (parent == null) {\n    throw new Error('Should never happen');\n  }\n\n  return [parent, Array.from(parent.childNodes).indexOf(node)];\n}\n/**\n * Creates a selection range for the DOM.\n * @param editor - The lexical editor.\n * @param anchorNode - The anchor node of a selection.\n * @param _anchorOffset - The amount of space offset from the anchor to the focus.\n * @param focusNode - The current focus.\n * @param _focusOffset - The amount of space offset from the focus to the anchor.\n * @returns The range of selection for the DOM that was created.\n */\n\n\nfunction createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {\n  const anchorKey = anchorNode.getKey();\n  const focusKey = focusNode.getKey();\n  const range = document.createRange();\n  let anchorDOM = editor.getElementByKey(anchorKey);\n  let focusDOM = editor.getElementByKey(focusKey);\n  let anchorOffset = _anchorOffset;\n  let focusOffset = _focusOffset;\n\n  if (lexical.$isTextNode(anchorNode)) {\n    anchorDOM = getDOMTextNode(anchorDOM);\n  }\n\n  if (lexical.$isTextNode(focusNode)) {\n    focusDOM = getDOMTextNode(focusDOM);\n  }\n\n  if (anchorNode === undefined || focusNode === undefined || anchorDOM === null || focusDOM === null) {\n    return null;\n  }\n\n  if (anchorDOM.nodeName === 'BR') {\n    [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);\n  }\n\n  if (focusDOM.nodeName === 'BR') {\n    [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);\n  }\n\n  const firstChild = anchorDOM.firstChild;\n\n  if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === 'BR' && anchorOffset === 0 && focusOffset === 0) {\n    focusOffset = 1;\n  }\n\n  try {\n    range.setStart(anchorDOM, anchorOffset);\n    range.setEnd(focusDOM, focusOffset);\n  } catch (e) {\n    return null;\n  }\n\n  if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {\n    // Range is backwards, we need to reverse it\n    range.setStart(focusDOM, focusOffset);\n    range.setEnd(anchorDOM, anchorOffset);\n  }\n\n  return range;\n}\n/**\n * Creates DOMRects, generally used to help the editor find a specific location on the screen.\n * @param editor - The lexical editor\n * @param range - A fragment of a document that can contain nodes and parts of text nodes.\n * @returns The selectionRects as an array.\n */\n\nfunction createRectsFromDOMRange(editor, range) {\n  const rootElement = editor.getRootElement();\n\n  if (rootElement === null) {\n    return [];\n  }\n\n  const rootRect = rootElement.getBoundingClientRect();\n  const computedStyle = getComputedStyle(rootElement);\n  const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);\n  const selectionRects = Array.from(range.getClientRects());\n  let selectionRectsLength = selectionRects.length; //sort rects from top left to bottom right.\n\n  selectionRects.sort((a, b) => {\n    const top = a.top - b.top; // Some rects match position closely, but not perfectly,\n    // so we give a 3px tolerance.\n\n    if (Math.abs(top) <= 3) {\n      return a.left - b.left;\n    }\n\n    return top;\n  });\n  let prevRect;\n\n  for (let i = 0; i < selectionRectsLength; i++) {\n    const selectionRect = selectionRects[i]; // Exclude rects that overlap preceding Rects in the sorted list.\n\n    const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left; // Exclude selections that span the entire element\n\n    const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;\n\n    if (isOverlappingRect || selectionSpansElement) {\n      selectionRects.splice(i--, 1);\n      selectionRectsLength--;\n      continue;\n    }\n\n    prevRect = selectionRect;\n  }\n\n  return selectionRects;\n}\n/**\n * Creates an object containing all the styles and their values provided in the CSS string.\n * @param css - The CSS string of styles and their values.\n * @returns The styleObject containing all the styles and their values.\n */\n\nfunction getStyleObjectFromRawCSS(css) {\n  const styleObject = {};\n  const styles = css.split(';');\n\n  for (const style of styles) {\n    if (style !== '') {\n      const [key, value] = style.split(/:([^]+)/); // split on first colon\n\n      styleObject[key.trim()] = value.trim();\n    }\n  }\n\n  return styleObject;\n}\n/**\n * Given a CSS string, returns an object from the style cache.\n * @param css - The CSS property as a string.\n * @returns The value of the given CSS property.\n */\n\nfunction getStyleObjectFromCSS(css) {\n  let value = CSS_TO_STYLES.get(css);\n\n  if (value === undefined) {\n    value = getStyleObjectFromRawCSS(css);\n    CSS_TO_STYLES.set(css, value);\n  }\n\n  {\n    // Freeze the value in DEV to prevent accidental mutations\n    Object.freeze(value);\n  }\n\n  return value;\n}\n/**\n * Gets the CSS styles from the style object.\n * @param styles - The style object containing the styles to get.\n * @returns A string containing the CSS styles and their values.\n */\n\nfunction getCSSFromStyleObject(styles) {\n  let css = '';\n\n  for (const style in styles) {\n    if (style) {\n      css += `${style}: ${styles[style]};`;\n    }\n  }\n\n  return css;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $updateElementNodeProperties(target, source) {\n  target.__first = source.__first;\n  target.__last = source.__last;\n  target.__size = source.__size;\n  target.__format = source.__format;\n  target.__indent = source.__indent;\n  target.__dir = source.__dir;\n  return target;\n}\n\nfunction $updateTextNodeProperties(target, source) {\n  target.__format = source.__format;\n  target.__style = source.__style;\n  target.__mode = source.__mode;\n  target.__detail = source.__detail;\n  return target;\n}\n/**\n * Returns a copy of a node, but generates a new key for the copy.\n * @param node - The node to be cloned.\n * @returns The clone of the node.\n */\n\n\nfunction $cloneWithProperties(node) {\n  const constructor = node.constructor; // @ts-expect-error\n\n  const clone = constructor.clone(node);\n  clone.__parent = node.__parent;\n  clone.__next = node.__next;\n  clone.__prev = node.__prev;\n\n  if (lexical.$isElementNode(node) && lexical.$isElementNode(clone)) {\n    return $updateElementNodeProperties(clone, node);\n  }\n\n  if (lexical.$isTextNode(node) && lexical.$isTextNode(clone)) {\n    return $updateTextNodeProperties(clone, node);\n  }\n\n  return clone;\n}\n/**\n * Generally used to append text content to HTML and JSON. Grabs the text content and \"slices\"\n * it to be generated into the new TextNode.\n * @param selection - The selection containing the node whose TextNode is to be edited.\n * @param textNode - The TextNode to be edited.\n * @returns The updated TextNode.\n */\n\nfunction $sliceSelectedTextNodeContent(selection, textNode) {\n  if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    const isAnchor = textNode.is(anchorNode);\n    const isFocus = textNode.is(focusNode);\n\n    if (isAnchor || isFocus) {\n      const isBackward = selection.isBackward();\n      const [anchorOffset, focusOffset] = selection.getCharacterOffsets();\n      const isSame = anchorNode.is(focusNode);\n      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);\n      const isLast = textNode.is(isBackward ? anchorNode : focusNode);\n      let startOffset = 0;\n      let endOffset = undefined;\n\n      if (isSame) {\n        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;\n        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;\n      } else if (isFirst) {\n        const offset = isBackward ? focusOffset : anchorOffset;\n        startOffset = offset;\n        endOffset = undefined;\n      } else if (isLast) {\n        const offset = isBackward ? anchorOffset : focusOffset;\n        startOffset = 0;\n        endOffset = offset;\n      }\n\n      textNode.__text = textNode.__text.slice(startOffset, endOffset);\n      return textNode;\n    }\n  }\n\n  return textNode;\n}\n/**\n * Determines if the current selection is at the end of the node.\n * @param point - The point of the selection to test.\n * @returns true if the provided point offset is in the last possible position, false otherwise.\n */\n\nfunction $isAtNodeEnd(point) {\n  if (point.type === 'text') {\n    return point.offset === point.getNode().getTextContentSize();\n  }\n\n  return point.offset === point.getNode().getChildrenSize();\n}\n/**\n * Trims text from a node in order to shorten it, eg. to enforce a text's max length. If it deletes text\n * that is an ancestor of the anchor then it will leave 2 indents, otherwise, if no text content exists, it deletes\n * the TextNode. It will move the focus to either the end of any left over text or beginning of a new TextNode.\n * @param editor - The lexical editor.\n * @param anchor - The anchor of the current selection, where the selection should be pointing.\n * @param delCount - The amount of characters to delete. Useful as a dynamic variable eg. textContentSize - maxLength;\n */\n\nfunction trimTextContentFromAnchor(editor, anchor, delCount) {\n  // Work from the current selection anchor point\n  let currentNode = anchor.getNode();\n  let remaining = delCount;\n\n  if (lexical.$isElementNode(currentNode)) {\n    const descendantNode = currentNode.getDescendantByIndex(anchor.offset);\n\n    if (descendantNode !== null) {\n      currentNode = descendantNode;\n    }\n  }\n\n  while (remaining > 0 && currentNode !== null) {\n    let nextNode = currentNode.getPreviousSibling();\n    let additionalElementWhitespace = 0;\n\n    if (nextNode === null) {\n      let parent = currentNode.getParentOrThrow();\n      let parentSibling = parent.getPreviousSibling();\n\n      while (parentSibling === null) {\n        parent = parent.getParent();\n\n        if (parent === null) {\n          nextNode = null;\n          break;\n        }\n\n        parentSibling = parent.getPreviousSibling();\n      }\n\n      if (parent !== null) {\n        additionalElementWhitespace = parent.isInline() ? 0 : 2;\n\n        if (lexical.$isElementNode(parentSibling)) {\n          nextNode = parentSibling.getLastDescendant();\n        } else {\n          nextNode = parentSibling;\n        }\n      }\n    }\n\n    let text = currentNode.getTextContent(); // If the text is empty, we need to consider adding in two line breaks to match\n    // the content if we were to get it from its parent.\n\n    if (text === '' && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {\n      // TODO: should this be handled in core?\n      text = '\\n\\n';\n    }\n\n    const currentNodeSize = text.length;\n\n    if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {\n      const parent = currentNode.getParent();\n      currentNode.remove();\n\n      if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {\n        parent.remove();\n      }\n\n      remaining -= currentNodeSize + additionalElementWhitespace;\n      currentNode = nextNode;\n    } else {\n      const key = currentNode.getKey(); // See if we can just revert it to what was in the last editor state\n\n      const prevTextContent = editor.getEditorState().read(() => {\n        const prevNode = lexical.$getNodeByKey(key);\n\n        if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {\n          return prevNode.getTextContent();\n        }\n\n        return null;\n      });\n      const offset = currentNodeSize - remaining;\n      const slicedText = text.slice(0, offset);\n\n      if (prevTextContent !== null && prevTextContent !== text) {\n        const prevSelection = lexical.$getPreviousSelection();\n        let target = currentNode;\n\n        if (!currentNode.isSimpleText()) {\n          const textNode = lexical.$createTextNode(prevTextContent);\n          currentNode.replace(textNode);\n          target = textNode;\n        } else {\n          currentNode.setTextContent(prevTextContent);\n        }\n\n        if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {\n          const prevOffset = prevSelection.anchor.offset;\n          target.select(prevOffset, prevOffset);\n        }\n      } else if (currentNode.isSimpleText()) {\n        // Split text\n        const isSelected = anchor.key === key;\n        let anchorOffset = anchor.offset; // Move offset to end if it's less than the remaining number, otherwise\n        // we'll have a negative splitStart.\n\n        if (anchorOffset < remaining) {\n          anchorOffset = currentNodeSize;\n        }\n\n        const splitStart = isSelected ? anchorOffset - remaining : 0;\n        const splitEnd = isSelected ? anchorOffset : offset;\n\n        if (isSelected && splitStart === 0) {\n          const [excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        } else {\n          const [, excessNode] = currentNode.splitText(splitStart, splitEnd);\n          excessNode.remove();\n        }\n      } else {\n        const textNode = lexical.$createTextNode(slicedText);\n        currentNode.replace(textNode);\n      }\n\n      remaining = 0;\n    }\n  }\n}\n/**\n * Gets the TextNode's style object and adds the styles to the CSS.\n * @param node - The TextNode to add styles to.\n */\n\nfunction $addNodeStyle(node) {\n  const CSSText = node.getStyle();\n  const styles = getStyleObjectFromRawCSS(CSSText);\n  CSS_TO_STYLES.set(CSSText, styles);\n}\n\nfunction $patchStyle(target, patch) {\n  const prevStyles = getStyleObjectFromCSS('getStyle' in target ? target.getStyle() : target.style);\n  const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {\n    if (value === null) {\n      delete styles[key];\n    } else {\n      styles[key] = value;\n    }\n\n    return styles;\n  }, { ...prevStyles\n  } || {});\n  const newCSSText = getCSSFromStyleObject(newStyles);\n  target.setStyle(newCSSText);\n  CSS_TO_STYLES.set(newCSSText, newStyles);\n}\n/**\n * Applies the provided styles to the TextNodes in the provided Selection.\n * Will update partially selected TextNodes by splitting the TextNode and applying\n * the styles to the appropriate one.\n * @param selection - The selected node(s) to update.\n * @param patch - The patch to apply, which can include multiple styles. { CSSProperty: value }\n */\n\n\nfunction $patchStyleText(selection, patch) {\n  const selectedNodes = selection.getNodes();\n  const selectedNodesLength = selectedNodes.length;\n\n  if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    const cellSelection = lexical.$createRangeSelection();\n    const cellSelectionAnchor = cellSelection.anchor;\n    const cellSelectionFocus = cellSelection.focus;\n\n    for (let i = 0; i < selectedNodesLength; i++) {\n      const node = selectedNodes[i];\n\n      if (lexical.DEPRECATED_$isGridCellNode(node)) {\n        cellSelectionAnchor.set(node.getKey(), 0, 'element');\n        cellSelectionFocus.set(node.getKey(), node.getChildrenSize(), 'element');\n        $patchStyleText(lexical.$normalizeSelection__EXPERIMENTAL(cellSelection), patch);\n      }\n    }\n\n    lexical.$setSelection(selection);\n    return;\n  }\n\n  const lastIndex = selectedNodesLength - 1;\n  let firstNode = selectedNodes[0];\n  let lastNode = selectedNodes[lastIndex];\n\n  if (selection.isCollapsed()) {\n    $patchStyle(selection, patch);\n    return;\n  }\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const firstNodeText = firstNode.getTextContent();\n  const firstNodeTextLength = firstNodeText.length;\n  const focusOffset = focus.offset;\n  let anchorOffset = anchor.offset;\n  const isBefore = anchor.isBefore(focus);\n  let startOffset = isBefore ? anchorOffset : focusOffset;\n  let endOffset = isBefore ? focusOffset : anchorOffset;\n  const startType = isBefore ? anchor.type : focus.type;\n  const endType = isBefore ? focus.type : anchor.type;\n  const endKey = isBefore ? focus.key : anchor.key; // This is the case where the user only selected the very end of the\n  // first node so we don't want to include it in the formatting change.\n\n  if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {\n    const nextSibling = firstNode.getNextSibling();\n\n    if (lexical.$isTextNode(nextSibling)) {\n      // we basically make the second node the firstNode, changing offsets accordingly\n      anchorOffset = 0;\n      startOffset = 0;\n      firstNode = nextSibling;\n    }\n  } // This is the case where we only selected a single node\n\n\n  if (selectedNodes.length === 1) {\n    if (lexical.$isTextNode(firstNode)) {\n      startOffset = startType === 'element' ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;\n      endOffset = endType === 'element' ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset; // No actual text is selected, so do nothing.\n\n      if (startOffset === endOffset) {\n        return;\n      } // The entire node is selected, so just format it\n\n\n      if (startOffset === 0 && endOffset === firstNodeTextLength) {\n        $patchStyle(firstNode, patch);\n        firstNode.select(startOffset, endOffset);\n      } else {\n        // The node is partially selected, so split it into two nodes\n        // and style the selected one.\n        const splitNodes = firstNode.splitText(startOffset, endOffset);\n        const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];\n        $patchStyle(replacement, patch);\n        replacement.select(0, endOffset - startOffset);\n      }\n    } // multiple nodes selected.\n\n  } else {\n    if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {\n      if (startOffset !== 0) {\n        // the entire first node isn't selected, so split it\n        firstNode = firstNode.splitText(startOffset)[1];\n        startOffset = 0;\n      }\n\n      $patchStyle(firstNode, patch);\n    }\n\n    if (lexical.$isTextNode(lastNode)) {\n      const lastNodeText = lastNode.getTextContent();\n      const lastNodeTextLength = lastNodeText.length; // The last node might not actually be the end node\n      //\n      // If not, assume the last node is fully-selected unless the end offset is\n      // zero.\n\n      if (lastNode.__key !== endKey && endOffset !== 0) {\n        endOffset = lastNodeTextLength;\n      } // if the entire last node isn't selected, split it\n\n\n      if (endOffset !== lastNodeTextLength) {\n        [lastNode] = lastNode.splitText(endOffset);\n      }\n\n      if (endOffset !== 0) {\n        $patchStyle(lastNode, patch);\n      }\n    } // style all the text nodes in between\n\n\n    for (let i = 1; i < lastIndex; i++) {\n      const selectedNode = selectedNodes[i];\n      const selectedNodeKey = selectedNode.getKey();\n\n      if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {\n        $patchStyle(selectedNode, patch);\n      }\n    }\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Converts all nodes in the selection that are of one block type to another.\n * @param selection - The selected blocks to be converted.\n * @param createElement - The function that creates the node. eg. $createParagraphNode.\n */\n\nfunction $setBlocksType(selection, createElement) {\n  if (selection.anchor.key === 'root') {\n    const element = createElement();\n    const root = lexical.$getRoot();\n    const firstChild = root.getFirstChild();\n\n    if (firstChild) {\n      firstChild.replace(element, true);\n    } else {\n      root.append(element);\n    }\n\n    return;\n  }\n\n  const nodes = selection.getNodes();\n  let maybeBlock = selection.anchor.getNode().getParentOrThrow();\n\n  if (nodes.indexOf(maybeBlock) === -1) {\n    nodes.push(maybeBlock);\n  }\n\n  if (maybeBlock.isInline()) {\n    maybeBlock = maybeBlock.getParentOrThrow();\n\n    if (nodes.indexOf(maybeBlock) === -1) {\n      nodes.push(maybeBlock);\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if (!isBlock(node)) {\n      continue;\n    }\n\n    const targetElement = createElement();\n    targetElement.setFormat(node.getFormatType());\n    targetElement.setIndent(node.getIndent());\n    node.replace(targetElement, true);\n  }\n}\n\nfunction isBlock(node) {\n  if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {\n    return false;\n  }\n\n  const firstChild = node.getFirstChild();\n  const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();\n  return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;\n}\n\nfunction isPointAttached(point) {\n  return point.getNode().isAttached();\n}\n\nfunction $removeParentEmptyElements(startingNode) {\n  let node = startingNode;\n\n  while (node !== null && !lexical.$isRootOrShadowRoot(node)) {\n    const latest = node.getLatest();\n    const parentNode = node.getParent();\n\n    if (latest.getChildrenSize() === 0) {\n      node.remove(true);\n    }\n\n    node = parentNode;\n  }\n}\n/**\n * @deprecated\n * Wraps all nodes in the selection into another node of the type returned by createElement.\n * @param selection - The selection of nodes to be wrapped.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to append the wrapped selection and its children to.\n */\n\n\nfunction $wrapNodes(selection, createElement, wrappingElement = null) {\n  const nodes = selection.getNodes();\n  const nodesLength = nodes.length;\n  const anchor = selection.anchor;\n\n  if (nodesLength === 0 || nodesLength === 1 && anchor.type === 'element' && anchor.getNode().getChildrenSize() === 0) {\n    const target = anchor.type === 'text' ? anchor.getNode().getParentOrThrow() : anchor.getNode();\n    const children = target.getChildren();\n    let element = createElement();\n    element.setFormat(target.getFormatType());\n    element.setIndent(target.getIndent());\n    children.forEach(child => element.append(child));\n\n    if (wrappingElement) {\n      element = wrappingElement.append(element);\n    }\n\n    target.replace(element);\n    return;\n  }\n\n  let topLevelNode = null;\n  let descendants = [];\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i]; // Determine whether wrapping has to be broken down into multiple chunks. This can happen if the\n    // user selected multiple Root-like nodes that have to be treated separately as if they are\n    // their own branch. I.e. you don't want to wrap a whole table, but rather the contents of each\n    // of each of the cell nodes.\n\n    if (lexical.$isRootOrShadowRoot(node)) {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [];\n      topLevelNode = node;\n    } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {\n      descendants.push(node);\n    } else {\n      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n      descendants = [node];\n    }\n  }\n\n  $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);\n}\n/**\n * Wraps each node into a new ElementNode.\n * @param selection - The selection of nodes to wrap.\n * @param nodes - An array of nodes, generally the descendants of the selection.\n * @param nodesLength - The length of nodes.\n * @param createElement - A function that creates the wrapping ElementNode. eg. $createParagraphNode.\n * @param wrappingElement - An element to wrap all the nodes into.\n * @returns\n */\n\nfunction $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {\n  if (nodes.length === 0) {\n    return;\n  }\n\n  const firstNode = nodes[0];\n  const elementMapping = new Map();\n  const elements = []; // The below logic is to find the right target for us to\n  // either insertAfter/insertBefore/append the corresponding\n  // elements to. This is made more complicated due to nested\n  // structures.\n\n  let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();\n\n  if (target.isInline()) {\n    target = target.getParentOrThrow();\n  }\n\n  let targetIsPrevSibling = false;\n\n  while (target !== null) {\n    const prevSibling = target.getPreviousSibling();\n\n    if (prevSibling !== null) {\n      target = prevSibling;\n      targetIsPrevSibling = true;\n      break;\n    }\n\n    target = target.getParentOrThrow();\n\n    if (lexical.$isRootOrShadowRoot(target)) {\n      break;\n    }\n  }\n\n  const emptyElements = new Set(); // Find any top level empty elements\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {\n      emptyElements.add(node.getKey());\n    }\n  }\n\n  const movedNodes = new Set(); // Move out all leaf nodes into our elements array.\n  // If we find a top level empty element, also move make\n  // an element for that.\n\n  for (let i = 0; i < nodesLength; i++) {\n    const node = nodes[i];\n    let parent = node.getParent();\n\n    if (parent !== null && parent.isInline()) {\n      parent = parent.getParent();\n    }\n\n    if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {\n      const parentKey = parent.getKey();\n\n      if (elementMapping.get(parentKey) === undefined) {\n        const targetElement = createElement();\n        targetElement.setFormat(parent.getFormatType());\n        targetElement.setIndent(parent.getIndent());\n        elements.push(targetElement);\n        elementMapping.set(parentKey, targetElement); // Move node and its siblings to the new\n        // element.\n\n        parent.getChildren().forEach(child => {\n          targetElement.append(child);\n          movedNodes.add(child.getKey());\n\n          if (lexical.$isElementNode(child)) {\n            // Skip nested leaf nodes if the parent has already been moved\n            child.getChildrenKeys().forEach(key => movedNodes.add(key));\n          }\n        });\n        $removeParentEmptyElements(parent);\n      }\n    } else if (emptyElements.has(node.getKey())) {\n      const targetElement = createElement();\n      targetElement.setFormat(node.getFormatType());\n      targetElement.setIndent(node.getIndent());\n      elements.push(targetElement);\n      node.remove(true);\n    }\n  }\n\n  if (wrappingElement !== null) {\n    for (let i = 0; i < elements.length; i++) {\n      const element = elements[i];\n      wrappingElement.append(element);\n    }\n  }\n\n  let lastElement = null; // If our target is Root-like, let's see if we can re-adjust\n  // so that the target is the first child instead.\n\n  if (lexical.$isRootOrShadowRoot(target)) {\n    if (targetIsPrevSibling) {\n      if (wrappingElement !== null) {\n        target.insertAfter(wrappingElement);\n      } else {\n        for (let i = elements.length - 1; i >= 0; i--) {\n          const element = elements[i];\n          target.insertAfter(element);\n        }\n      }\n    } else {\n      const firstChild = target.getFirstChild();\n\n      if (lexical.$isElementNode(firstChild)) {\n        target = firstChild;\n      }\n\n      if (firstChild === null) {\n        if (wrappingElement) {\n          target.append(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            target.append(element);\n            lastElement = element;\n          }\n        }\n      } else {\n        if (wrappingElement !== null) {\n          firstChild.insertBefore(wrappingElement);\n        } else {\n          for (let i = 0; i < elements.length; i++) {\n            const element = elements[i];\n            firstChild.insertBefore(element);\n            lastElement = element;\n          }\n        }\n      }\n    }\n  } else {\n    if (wrappingElement) {\n      target.insertAfter(wrappingElement);\n    } else {\n      for (let i = elements.length - 1; i >= 0; i--) {\n        const element = elements[i];\n        target.insertAfter(element);\n        lastElement = element;\n      }\n    }\n  }\n\n  const prevSelection = lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {\n    lexical.$setSelection(prevSelection.clone());\n  } else if (lastElement !== null) {\n    lastElement.selectEnd();\n  } else {\n    selection.dirty = true;\n  }\n}\n/**\n * Determines if the default character selection should be overridden. Used with DecoratorNodes\n * @param selection - The selection whose default character selection may need to be overridden.\n * @param isBackward - Is the selection backwards (the focus comes before the anchor)?\n * @returns true if it should be overridden, false if not.\n */\n\nfunction $shouldOverrideDefaultCharacterSelection(selection, isBackward) {\n  const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);\n  return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();\n}\n/**\n * Moves the selection according to the arguments.\n * @param selection - The selected text or nodes.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection selected backwards (the focus comes before the anchor)?\n * @param granularity - The distance to adjust the current selection.\n */\n\nfunction $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {\n  selection.modify(isHoldingShift ? 'extend' : 'move', isBackward, granularity);\n}\n/**\n * Tests a parent element for right to left direction.\n * @param selection - The selection whose parent is to be tested.\n * @returns true if the selections' parent element has a direction of 'rtl' (right to left), false otherwise.\n */\n\nfunction $isParentElementRTL(selection) {\n  const anchorNode = selection.anchor.getNode();\n  const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();\n  return parent.getDirection() === 'rtl';\n}\n/**\n * Moves selection by character according to arguments.\n * @param selection - The selection of the characters to move.\n * @param isHoldingShift - Is the shift key being held down during the operation.\n * @param isBackward - Is the selection backward (the focus comes before the anchor)?\n */\n\nfunction $moveCharacter(selection, isHoldingShift, isBackward) {\n  const isRTL = $isParentElementRTL(selection);\n  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, 'character');\n}\n/**\n * Expands the current Selection to cover all of the content in the editor.\n * @param selection - The current selection.\n */\n\nfunction $selectAll(selection) {\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const anchorNode = anchor.getNode();\n  const topParent = anchorNode.getTopLevelElementOrThrow();\n  const root = topParent.getParentOrThrow();\n  let firstNode = root.getFirstDescendant();\n  let lastNode = root.getLastDescendant();\n  let firstType = 'element';\n  let lastType = 'element';\n  let lastOffset = 0;\n\n  if (lexical.$isTextNode(firstNode)) {\n    firstType = 'text';\n  } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {\n    firstNode = firstNode.getParentOrThrow();\n  }\n\n  if (lexical.$isTextNode(lastNode)) {\n    lastType = 'text';\n    lastOffset = lastNode.getTextContentSize();\n  } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {\n    lastNode = lastNode.getParentOrThrow();\n  }\n\n  if (firstNode && lastNode) {\n    anchor.set(firstNode.getKey(), 0, firstType);\n    focus.set(lastNode.getKey(), lastOffset, lastType);\n  }\n}\n/**\n * Returns the current value of a CSS property for Nodes, if set. If not set, it returns the defaultValue.\n * @param node - The node whose style value to get.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property.\n * @returns The value of the property for node.\n */\n\nfunction $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {\n  const css = node.getStyle();\n  const styleObject = getStyleObjectFromCSS(css);\n\n  if (styleObject !== null) {\n    return styleObject[styleProperty] || defaultValue;\n  }\n\n  return defaultValue;\n}\n/**\n * Returns the current value of a CSS property for TextNodes in the Selection, if set. If not set, it returns the defaultValue.\n * If all TextNodes do not have the same value, it returns an empty string.\n * @param selection - The selection of TextNodes whose value to find.\n * @param styleProperty - The CSS style property.\n * @param defaultValue - The default value for the property, defaults to an empty string.\n * @returns The value of the property for the selected TextNodes.\n */\n\n\nfunction $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = '') {\n  let styleValue = null;\n  const nodes = selection.getNodes();\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const isBackward = selection.isBackward();\n  const endOffset = isBackward ? focus.offset : anchor.offset;\n  const endNode = isBackward ? focus.getNode() : anchor.getNode();\n\n  if (selection.style !== '') {\n    const css = selection.style;\n    const styleObject = getStyleObjectFromCSS(css);\n\n    if (styleObject !== null && styleProperty in styleObject) {\n      return styleObject[styleProperty];\n    }\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i]; // if no actual characters in the end node are selected, we don't\n    // include it in the selection for purposes of determining style\n    // value\n\n    if (i !== 0 && endOffset === 0 && node.is(endNode)) {\n      continue;\n    }\n\n    if (lexical.$isTextNode(node)) {\n      const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);\n\n      if (styleValue === null) {\n        styleValue = nodeStyleValue;\n      } else if (styleValue !== nodeStyleValue) {\n        // multiple text nodes are in the selection and they don't all\n        // have the same style.\n        styleValue = '';\n        break;\n      }\n    }\n  }\n\n  return styleValue === null ? defaultValue : styleValue;\n}\n\nexports.$addNodeStyle = $addNodeStyle;\nexports.$cloneWithProperties = $cloneWithProperties;\nexports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;\nexports.$isAtNodeEnd = $isAtNodeEnd;\nexports.$isParentElementRTL = $isParentElementRTL;\nexports.$moveCaretSelection = $moveCaretSelection;\nexports.$moveCharacter = $moveCharacter;\nexports.$patchStyleText = $patchStyleText;\nexports.$selectAll = $selectAll;\nexports.$setBlocksType = $setBlocksType;\nexports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;\nexports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;\nexports.$wrapNodes = $wrapNodes;\nexports.createDOMRange = createDOMRange;\nexports.createRectsFromDOMRange = createRectsFromDOMRange;\nexports.getStyleObjectFromCSS = getStyleObjectFromCSS;\nexports.trimTextContentFromAnchor = trimTextContentFromAnchor;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalSelection = process.env.NODE_ENV === 'development' ? require('./LexicalSelection.dev.js') : require('./LexicalSelection.prod.js')\nmodule.exports = LexicalSelection;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar lexical = require('lexical');\n\n/** @module @lexical/utils */\n\n/**\n * Takes an HTML element and adds the classNames passed within an array,\n * ignoring any non-string types. A space can be used to add multiple classes\n * eg. addClassNamesToElement(element, ['element-inner active', true, null])\n * will add both 'element-inner' and 'active' as classes to that element.\n * @param element - The element in which the classes are added\n * @param classNames - An array defining the class names to add to the element\n */\nfunction addClassNamesToElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      const classesToAdd = className.split(' ').filter(n => n !== '');\n      element.classList.add(...classesToAdd);\n    }\n  });\n}\n/**\n * Takes an HTML element and removes the classNames passed within an array,\n * ignoring any non-string types. A space can be used to remove multiple classes\n * eg. removeClassNamesFromElement(element, ['active small', true, null])\n * will remove both the 'active' and 'small' classes from that element.\n * @param element - The element in which the classes are removed\n * @param classNames - An array defining the class names to remove from the element\n */\n\nfunction removeClassNamesFromElement(element, ...classNames) {\n  classNames.forEach(className => {\n    if (typeof className === 'string') {\n      element.classList.remove(...className.split(' '));\n    }\n  });\n}\n/**\n * Returns true if the file type matches the types passed within the acceptableMimeTypes array, false otherwise.\n * The types passed must be strings and are CASE-SENSITIVE.\n * eg. if file is of type 'text' and acceptableMimeTypes = ['TEXT', 'IMAGE'] the function will return false.\n * @param file - The file you want to type check.\n * @param acceptableMimeTypes - An array of strings of types which the file is checked against.\n * @returns true if the file is an acceptable mime type, false otherwise.\n */\n\nfunction isMimeType(file, acceptableMimeTypes) {\n  for (const acceptableType of acceptableMimeTypes) {\n    if (file.type.startsWith(acceptableType)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Lexical File Reader with:\n *  1. MIME type support\n *  2. batched results (HistoryPlugin compatibility)\n *  3. Order aware (respects the order when multiple Files are passed)\n *\n * const filesResult = await mediaFileReader(files, ['image/']);\n * filesResult.forEach(file => editor.dispatchCommand('INSERT_IMAGE', {\n *   src: file.result,\n * }));\n */\n\nfunction mediaFileReader(files, acceptableMimeTypes) {\n  const filesIterator = files[Symbol.iterator]();\n  return new Promise((resolve, reject) => {\n    const processed = [];\n\n    const handleNextFile = () => {\n      const {\n        done,\n        value: file\n      } = filesIterator.next();\n\n      if (done) {\n        return resolve(processed);\n      }\n\n      const fileReader = new FileReader();\n      fileReader.addEventListener('error', reject);\n      fileReader.addEventListener('load', () => {\n        const result = fileReader.result;\n\n        if (typeof result === 'string') {\n          processed.push({\n            file,\n            result\n          });\n        }\n\n        handleNextFile();\n      });\n\n      if (isMimeType(file, acceptableMimeTypes)) {\n        fileReader.readAsDataURL(file);\n      } else {\n        handleNextFile();\n      }\n    };\n\n    handleNextFile();\n  });\n}\n/**\n * \"Depth-First Search\" starts at the root/top node of a tree and goes as far as it can down a branch end\n * before backtracking and finding a new path. Consider solving a maze by hugging either wall, moving down a\n * branch until you hit a dead-end (leaf) and backtracking to find the nearest branching path and repeat.\n * It will then return all the nodes found in the search in an array of objects.\n * @param startingNode - The node to start the search, if ommitted, it will start at the root node.\n * @param endingNode - The node to end the search, if ommitted, it will find all descendants of the startingNode.\n * @returns An array of objects of all the nodes found by the search, including their depth into the tree.\n * {depth: number, node: LexicalNode} It will always return at least 1 node (the ending node) so long as it exists\n */\n\nfunction $dfs(startingNode, endingNode) {\n  const nodes = [];\n  const start = (startingNode || lexical.$getRoot()).getLatest();\n  const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);\n  let node = start;\n  let depth = $getDepth(node);\n\n  while (node !== null && !node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n\n    if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {\n      node = node.getFirstChild();\n      depth++;\n    } else {\n      // Find immediate sibling or nearest parent sibling\n      let sibling = null;\n\n      while (sibling === null && node !== null) {\n        sibling = node.getNextSibling();\n\n        if (sibling === null) {\n          node = node.getParent();\n          depth--;\n        } else {\n          node = sibling;\n        }\n      }\n    }\n  }\n\n  if (node !== null && node.is(end)) {\n    nodes.push({\n      depth,\n      node\n    });\n  }\n\n  return nodes;\n}\n\nfunction $getDepth(node) {\n  let innerNode = node;\n  let depth = 0;\n\n  while ((innerNode = innerNode.getParent()) !== null) {\n    depth++;\n  }\n\n  return depth;\n}\n/**\n * Takes a node and traverses up its ancestors (toward the root node)\n * in order to find a specific type of node.\n * @param node - the node to begin searching.\n * @param klass - an instance of the type of node to look for.\n * @returns the node of type klass that was passed, or null if none exist.\n */\n\n\nfunction $getNearestNodeOfType(node, klass) {\n  let parent = node;\n\n  while (parent != null) {\n    if (parent instanceof klass) {\n      return parent;\n    }\n\n    parent = parent.getParent();\n  }\n\n  return null;\n}\n/**\n * Returns the element node of the nearest ancestor, otherwise throws an error.\n * @param startNode - The starting node of the search\n * @returns The ancestor node found\n */\n\nfunction $getNearestBlockElementAncestorOrThrow(startNode) {\n  const blockNode = $findMatchingParent(startNode, node => lexical.$isElementNode(node) && !node.isInline());\n\n  if (!lexical.$isElementNode(blockNode)) {\n    {\n      throw Error(`Expected node ${startNode.__key} to have closest block element node.`);\n    }\n  }\n\n  return blockNode;\n}\n\n/**\n * Starts with a node and moves up the tree (toward the root node) to find a matching node based on\n * the search parameters of the findFn. (Consider JavaScripts' .find() function where a testing function must be\n * passed as an argument. eg. if( (node) => node.__type === 'div') ) return true; otherwise return false\n * @param startingNode - The node where the search starts.\n * @param findFn - A testing function that returns true if the current node satisfies the testing parameters.\n * @returns A parent node that matches the findFn parameters, or null if one wasn't found.\n */\nfunction $findMatchingParent(startingNode, findFn) {\n  let curr = startingNode;\n\n  while (curr !== lexical.$getRoot() && curr != null) {\n    if (findFn(curr)) {\n      return curr;\n    }\n\n    curr = curr.getParent();\n  }\n\n  return null;\n}\n\n/**\n * Returns a function that will execute all functions passed when called. It is generally used\n * to register multiple lexical listeners and then tear them down with a single function call, such\n * as React's useEffect hook.\n * @example\n * ```ts\n * useEffect(() => {\n *   return mergeRegister(\n *     editor.registerCommand(...registerCommand1 logic),\n *     editor.registerCommand(...registerCommand2 logic),\n *     editor.registerCommand(...registerCommand3 logic)\n *   )\n * }, [editor])\n * ```\n * In this case, useEffect is returning the function returned by mergeRegister as a cleanup\n * function to be executed after either the useEffect runs again (due to one of its dependencies\n * updating) or the compenent it resides in unmounts.\n * Note the functions don't neccesarily need to be in an array as all arguements\n * are considered to be the func argument and spread from there.\n * @param func - An array of functions meant to be executed by the returned function.\n * @returns the function which executes all the passed register command functions.\n */\nfunction mergeRegister(...func) {\n  return () => {\n    func.forEach(f => f());\n  };\n}\n/**\n * Attempts to resolve nested element nodes of the same type into a single node of that type.\n * It is generally used for marks/commenting\n * @param editor - The lexical editor\n * @param targetNode - The target for the nested element to be extracted from.\n * @param cloneNode - See {@link $createMarkNode}\n * @param handleOverlap - Handles any overlap between the node to extract and the targetNode\n * @returns The lexical editor\n */\n\nfunction registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {\n  const $isTargetNode = node => {\n    return node instanceof targetNode;\n  };\n\n  const $findMatch = node => {\n    // First validate we don't have any children that are of the target,\n    // as we need to handle them first.\n    const children = node.getChildren();\n\n    for (let i = 0; i < children.length; i++) {\n      const child = children[i];\n\n      if ($isTargetNode(child)) {\n        return null;\n      }\n    }\n\n    let parentNode = node;\n    let childNode = node;\n\n    while (parentNode !== null) {\n      childNode = parentNode;\n      parentNode = parentNode.getParent();\n\n      if ($isTargetNode(parentNode)) {\n        return {\n          child: childNode,\n          parent: parentNode\n        };\n      }\n    }\n\n    return null;\n  };\n\n  const elementNodeTransform = node => {\n    const match = $findMatch(node);\n\n    if (match !== null) {\n      const {\n        child,\n        parent\n      } = match; // Simple path, we can move child out and siblings into a new parent.\n\n      if (child.is(node)) {\n        handleOverlap(parent, node);\n        const nextSiblings = child.getNextSiblings();\n        const nextSiblingsLength = nextSiblings.length;\n        parent.insertAfter(child);\n\n        if (nextSiblingsLength !== 0) {\n          const newParent = cloneNode(parent);\n          child.insertAfter(newParent);\n\n          for (let i = 0; i < nextSiblingsLength; i++) {\n            newParent.append(nextSiblings[i]);\n          }\n        }\n\n        if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {\n          parent.remove();\n        }\n      }\n    }\n  };\n\n  return editor.registerNodeTransform(targetNode, elementNodeTransform);\n}\n/**\n * Clones the editor and marks it as dirty to be reconciled. If there was a selection,\n * it would be set back to its previous state, or null otherwise.\n * @param editor - The lexical editor\n * @param editorState - The editor's state\n */\n\nfunction $restoreEditorState(editor, editorState) {\n  const FULL_RECONCILE = 2;\n  const nodeMap = new Map();\n  const activeEditorState = editor._pendingEditorState;\n\n  for (const [key, node] of editorState._nodeMap) {\n    const clone = selection.$cloneWithProperties(node);\n\n    if (lexical.$isTextNode(clone)) {\n      clone.__text = node.__text;\n    }\n\n    nodeMap.set(key, clone);\n  }\n\n  if (activeEditorState) {\n    activeEditorState._nodeMap = nodeMap;\n  }\n\n  editor._dirtyType = FULL_RECONCILE;\n  const selection$1 = editorState._selection;\n  lexical.$setSelection(selection$1 === null ? null : selection$1.clone());\n}\n/**\n * If the selected insertion area is the root/shadow root node (see {@link lexical!$isRootOrShadowRoot}),\n * the node will be appended there, otherwise, it will be inserted before the insertion area.\n * If there is no selection where the node is to be inserted, it will be appended after any current nodes\n * within the tree, as a child of the root node. A paragraph node will then be added after the inserted node and selected.\n * @param node - The node to be inserted\n * @returns The node after its insertion\n */\n\nfunction $insertNodeToNearestRoot(node) {\n  const selection = lexical.$getSelection() || lexical.$getPreviousSelection();\n\n  if (lexical.$isRangeSelection(selection)) {\n    const {\n      focus\n    } = selection;\n    const focusNode = focus.getNode();\n    const focusOffset = focus.offset;\n\n    if (lexical.$isRootOrShadowRoot(focusNode)) {\n      const focusChild = focusNode.getChildAtIndex(focusOffset);\n\n      if (focusChild == null) {\n        focusNode.append(node);\n      } else {\n        focusChild.insertBefore(node);\n      }\n\n      node.selectNext();\n    } else {\n      let splitNode;\n      let splitOffset;\n\n      if (lexical.$isTextNode(focusNode)) {\n        splitNode = focusNode.getParentOrThrow();\n        splitOffset = focusNode.getIndexWithinParent();\n\n        if (focusOffset > 0) {\n          splitOffset += 1;\n          focusNode.splitText(focusOffset);\n        }\n      } else {\n        splitNode = focusNode;\n        splitOffset = focusOffset;\n      }\n\n      const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);\n      rightTree.insertBefore(node);\n      rightTree.selectStart();\n    }\n  } else {\n    if (lexical.$isNodeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);\n    } else {\n      const root = lexical.$getRoot();\n      root.append(node);\n    }\n\n    const paragraphNode = lexical.$createParagraphNode();\n    node.insertAfter(paragraphNode);\n    paragraphNode.select();\n  }\n\n  return node.getLatest();\n}\n/**\n * Wraps the node into another node created from a createElementNode function, eg. $createParagraphNode\n * @param node - Node to be wrapped.\n * @param createElementNode - Creates a new lexcial element to wrap the to-be-wrapped node and returns it.\n * @returns A new lexcial element with the previous node appended within (as a child, including its children).\n */\n\nfunction $wrapNodeInElement(node, createElementNode) {\n  const elementNode = createElementNode();\n  node.replace(elementNode);\n  elementNode.append(node);\n  return elementNode;\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * @param object = The instance of the type\n * @param objectClass = The class of the type\n * @returns Whether the object is has the same Klass of the objectClass, ignoring the difference across window (e.g. different iframs)\n */\nfunction objectKlassEquals(object, objectClass) {\n  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;\n}\n/**\n * Filter the nodes\n * @param nodes Array of nodes that needs to be filtered\n * @param filterFn A filter function that returns node if the current node satisfies the condition otherwise null\n * @returns Array of filtered nodes\n */\n\nfunction $filter(nodes, filterFn) {\n  const result = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = filterFn(nodes[i]);\n\n    if (node !== null) {\n      result.push(node);\n    }\n  }\n\n  return result;\n}\n/**\n * Appends the node before the first child of the parent node\n * @param parent A parent node\n * @param node Node that needs to be appended\n */\n\nfunction $insertFirst(parent, node) {\n  const firstChild = parent.getFirstChild();\n\n  if (firstChild !== null) {\n    firstChild.insertBefore(node);\n  } else {\n    parent.append(node);\n  }\n}\n\nexports.$splitNode = lexical.$splitNode;\nexports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;\nexports.isHTMLElement = lexical.isHTMLElement;\nexports.$dfs = $dfs;\nexports.$filter = $filter;\nexports.$findMatchingParent = $findMatchingParent;\nexports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;\nexports.$getNearestNodeOfType = $getNearestNodeOfType;\nexports.$insertFirst = $insertFirst;\nexports.$insertNodeToNearestRoot = $insertNodeToNearestRoot;\nexports.$restoreEditorState = $restoreEditorState;\nexports.$wrapNodeInElement = $wrapNodeInElement;\nexports.addClassNamesToElement = addClassNamesToElement;\nexports.isMimeType = isMimeType;\nexports.mediaFileReader = mediaFileReader;\nexports.mergeRegister = mergeRegister;\nexports.objectKlassEquals = objectKlassEquals;\nexports.registerNestedElementResolver = registerNestedElementResolver;\nexports.removeClassNamesFromElement = removeClassNamesFromElement;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalUtils = process.env.NODE_ENV === 'development' ? require('./LexicalUtils.dev.js') : require('./LexicalUtils.prod.js')\nmodule.exports = LexicalUtils;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/html */\n/**\n * How you parse your html string to get a document is left up to you. In the browser you can use the native\n * DOMParser API to generate a document (see clipboard.ts), but to use in a headless environment you can use JSDom\n * or an equivilant library and pass in the document here.\n */\n\nfunction $generateNodesFromDOM(editor, dom) {\n  const elements = dom.body ? dom.body.childNodes : [];\n  let lexicalNodes = [];\n\n  for (let i = 0; i < elements.length; i++) {\n    const element = elements[i];\n\n    if (!IGNORE_TAGS.has(element.nodeName)) {\n      const lexicalNode = $createNodesFromDOM(element, editor);\n\n      if (lexicalNode !== null) {\n        lexicalNodes = lexicalNodes.concat(lexicalNode);\n      }\n    }\n  }\n\n  return lexicalNodes;\n}\nfunction $generateHtmlFromNodes(editor, selection) {\n  if (typeof document === 'undefined' || typeof window === 'undefined') {\n    throw new Error('To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.');\n  }\n\n  const container = document.createElement('div');\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToHTML(editor, topLevelNode, container, selection);\n  }\n\n  return container.innerHTML;\n}\n\nfunction $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const {\n    element,\n    after\n  } = target.exportDOM(editor);\n\n  if (!element) {\n    return false;\n  }\n\n  const fragment = document.createDocumentFragment();\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'html')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    if (utils.isHTMLElement(element)) {\n      element.append(fragment);\n    }\n\n    parentElement.append(element);\n\n    if (after) {\n      const newElement = after.call(target, element);\n      if (newElement) element.replaceWith(newElement);\n    }\n  } else {\n    parentElement.append(fragment);\n  }\n\n  return shouldInclude;\n}\n\nfunction getConversionFunction(domNode, editor) {\n  const {\n    nodeName\n  } = domNode;\n\n  const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());\n\n  let currentConversion = null;\n\n  if (cachedConversions !== undefined) {\n    for (const cachedConversion of cachedConversions) {\n      const domConversion = cachedConversion(domNode);\n\n      if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {\n        currentConversion = domConversion;\n      }\n    }\n  }\n\n  return currentConversion !== null ? currentConversion.conversion : null;\n}\n\nconst IGNORE_TAGS = new Set(['STYLE', 'SCRIPT']);\n\nfunction $createNodesFromDOM(node, editor, forChildMap = new Map(), parentLexicalNode) {\n  let lexicalNodes = [];\n\n  if (IGNORE_TAGS.has(node.nodeName)) {\n    return lexicalNodes;\n  }\n\n  let currentLexicalNode = null;\n  const transformFunction = getConversionFunction(node, editor);\n  const transformOutput = transformFunction ? transformFunction(node) : null;\n  let postTransform = null;\n\n  if (transformOutput !== null) {\n    postTransform = transformOutput.after;\n    const transformNodes = transformOutput.node;\n    currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;\n\n    if (currentLexicalNode !== null) {\n      for (const [, forChildFunction] of forChildMap) {\n        currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);\n\n        if (!currentLexicalNode) {\n          break;\n        }\n      }\n\n      if (currentLexicalNode) {\n        lexicalNodes.push(...(Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]));\n      }\n    }\n\n    if (transformOutput.forChild != null) {\n      forChildMap.set(node.nodeName, transformOutput.forChild);\n    }\n  } // If the DOM node doesn't have a transformer, we don't know what\n  // to do with it but we still need to process any childNodes.\n\n\n  const children = node.childNodes;\n  let childLexicalNodes = [];\n\n  for (let i = 0; i < children.length; i++) {\n    childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));\n  }\n\n  if (postTransform != null) {\n    childLexicalNodes = postTransform(childLexicalNodes);\n  }\n\n  if (currentLexicalNode == null) {\n    // If it hasn't been converted to a LexicalNode, we hoist its children\n    // up to the same level as it.\n    lexicalNodes = lexicalNodes.concat(childLexicalNodes);\n  } else {\n    if (lexical.$isElementNode(currentLexicalNode)) {\n      // If the current node is a ElementNode after conversion,\n      // we can append all the children to it.\n      currentLexicalNode.append(...childLexicalNodes);\n    }\n  }\n\n  return lexicalNodes;\n}\n\nexports.$generateHtmlFromNodes = $generateHtmlFromNodes;\nexports.$generateNodesFromDOM = $generateNodesFromDOM;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHtml = process.env.NODE_ENV === 'development' ? require('./LexicalHtml.dev.js') : require('./LexicalHtml.prod.js')\nmodule.exports = LexicalHtml;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar html = require('@lexical/html');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nconst getDOMSelection = targetWindow => CAN_USE_DOM ? (targetWindow || window).getSelection() : null;\n/**\n * Returns the *currently selected* Lexical content as an HTML string, relying on the\n * logic defined in the exportDOM methods on the LexicalNode classes. Note that\n * this will not return the HTML content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor - LexicalEditor instance to get HTML content from\n * @returns a string of HTML content\n */\n\n\nfunction $getHtmlContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return '';\n  }\n\n  return html.$generateHtmlFromNodes(editor, selection);\n}\n/**\n * Returns the *currently selected* Lexical content as a JSON string, relying on the\n * logic defined in the exportJSON methods on the LexicalNode classes. Note that\n * this will not return the JSON content of the entire editor (unless all the content is included\n * in the current selection).\n *\n * @param editor  - LexicalEditor instance to get the JSON content from\n * @returns\n */\n\nfunction $getLexicalContent(editor) {\n  const selection = lexical.$getSelection();\n\n  if (selection == null) {\n    {\n      throw Error(`Expected valid LexicalSelection`);\n    }\n  } // If we haven't selected anything\n\n\n  if (lexical.$isRangeSelection(selection) && selection.isCollapsed() || selection.getNodes().length === 0) {\n    return null;\n  }\n\n  return JSON.stringify($generateJSONFromSelectedNodes(editor, selection));\n}\n/**\n * Attempts to insert content of the mime-types text/plain or text/uri-list from\n * the provided DataTransfer object into the editor at the provided selection.\n * text/uri-list is only used if text/plain is not also provided.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n */\n\nfunction $insertDataTransferForPlainText(dataTransfer, selection) {\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    selection.insertRawText(text);\n  }\n}\n/**\n * Attempts to insert content of the mime-types application/x-lexical-editor, text/html,\n * text/plain, or text/uri-list (in descending order of priority) from the provided DataTransfer\n * object into the editor at the provided selection.\n *\n * @param dataTransfer an object conforming to the [DataTransfer interface] (https://html.spec.whatwg.org/multipage/dnd.html#the-datatransfer-interface)\n * @param selection the selection to use as the insertion point for the content in the DataTransfer object\n * @param editor the LexicalEditor the content is being inserted into.\n */\n\nfunction $insertDataTransferForRichText(dataTransfer, selection, editor) {\n  const lexicalString = dataTransfer.getData('application/x-lexical-editor');\n\n  if (lexicalString) {\n    try {\n      const payload = JSON.parse(lexicalString);\n\n      if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {\n        const nodes = $generateNodesFromSerializedNodes(payload.nodes);\n        return $insertGeneratedNodes(editor, nodes, selection);\n      }\n    } catch {// Fail silently.\n    }\n  }\n\n  const htmlString = dataTransfer.getData('text/html');\n\n  if (htmlString) {\n    try {\n      const parser = new DOMParser();\n      const dom = parser.parseFromString(htmlString, 'text/html');\n      const nodes = html.$generateNodesFromDOM(editor, dom);\n      return $insertGeneratedNodes(editor, nodes, selection);\n    } catch {// Fail silently.\n    }\n  } // Multi-line plain text in rich text mode pasted as separate paragraphs\n  // instead of single paragraph with linebreaks.\n  // Webkit-specific: Supports read 'text/uri-list' in clipboard.\n\n\n  const text = dataTransfer.getData('text/plain') || dataTransfer.getData('text/uri-list');\n\n  if (text != null) {\n    if (lexical.$isRangeSelection(selection)) {\n      const parts = text.split(/(\\r?\\n|\\t)/);\n      const partsLength = parts.length;\n\n      for (let i = 0; i < partsLength; i++) {\n        const part = parts[i];\n\n        if (part === '\\n' || part === '\\r\\n') {\n          selection.insertParagraph();\n        } else if (part === '\\t') {\n          selection.insertNodes([lexical.$createTabNode()]);\n        } else {\n          selection.insertText(part);\n        }\n      }\n    } else {\n      selection.insertRawText(text);\n    }\n  }\n}\n/**\n * Inserts Lexical nodes into the editor using different strategies depending on\n * some simple selection-based heuristics. If you're looking for a generic way to\n * to insert nodes into the editor at a specific selection point, you probably want\n * {@link lexical.$insertNodes}\n *\n * @param editor LexicalEditor instance to insert the nodes into.\n * @param nodes The nodes to insert.\n * @param selection The selection to insert the nodes into.\n */\n\nfunction $insertGeneratedNodes(editor, nodes, selection) {\n  const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection) || utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection.focus.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n)) !== null;\n\n  if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    $mergeGridNodesStrategy(nodes, selection, false, editor);\n    return;\n  }\n\n  $basicInsertStrategy(nodes, selection);\n  return;\n}\n\nfunction $basicInsertStrategy(nodes, selection) {\n  // Wrap text and inline nodes in paragraph nodes so we have all blocks at the top-level\n  const topLevelBlocks = [];\n  let currentBlock = null;\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const isLineBreakNode = lexical.$isLineBreakNode(node);\n\n    if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {\n      if (currentBlock === null) {\n        currentBlock = node.createParentElementNode();\n        topLevelBlocks.push(currentBlock); // In the case of LineBreakNode, we just need to\n        // add an empty ParagraphNode to the topLevelBlocks.\n\n        if (isLineBreakNode) {\n          continue;\n        }\n      }\n\n      if (currentBlock !== null) {\n        currentBlock.append(node);\n      }\n    } else {\n      topLevelBlocks.push(node);\n      currentBlock = null;\n    }\n  }\n\n  if (lexical.$isRangeSelection(selection)) {\n    selection.insertNodes(topLevelBlocks);\n  } else if (lexical.DEPRECATED_$isGridSelection(selection)) {\n    // If there's an active grid selection and a non grid is pasted, add to the anchor.\n    const anchorCell = selection.anchor.getNode();\n\n    if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {\n      {\n        throw Error(`Expected Grid Cell in Grid Selection`);\n      }\n    }\n\n    anchorCell.append(...topLevelBlocks);\n  }\n}\n\nfunction $mergeGridNodesStrategy(nodes, selection, isFromLexical, editor) {\n  if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);\n    }\n  }\n\n  const newGrid = nodes[0];\n  const newGridRows = newGrid.getChildren();\n  const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();\n  const newRowCount = newGrid.getChildrenSize();\n  const gridCellNode = utils.$findMatchingParent(selection.anchor.getNode(), n => lexical.DEPRECATED_$isGridCellNode(n));\n  const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, n => lexical.DEPRECATED_$isGridRowNode(n));\n  const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, n => lexical.DEPRECATED_$isGridNode(n));\n\n  if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {\n    {\n      throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);\n    }\n  }\n\n  const startY = gridRowNode.getIndexWithinParent();\n  const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);\n  const startX = gridCellNode.getIndexWithinParent();\n  const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);\n  const fromX = Math.min(startX, stopX);\n  const fromY = Math.min(startY, stopY);\n  const toX = Math.max(startX, stopX);\n  const toY = Math.max(startY, stopY);\n  const gridRowNodes = gridNode.getChildren();\n  let newRowIdx = 0;\n  let newAnchorCellKey;\n  let newFocusCellKey;\n\n  for (let r = fromY; r <= toY; r++) {\n    const currentGridRowNode = gridRowNodes[r];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const newGridRowNode = newGridRows[newRowIdx];\n\n    if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {\n      {\n        throw Error(`getNodes: expected to find GridRowNode`);\n      }\n    }\n\n    const gridCellNodes = currentGridRowNode.getChildren();\n    const newGridCellNodes = newGridRowNode.getChildren();\n    let newColumnIdx = 0;\n\n    for (let c = fromX; c <= toX; c++) {\n      const currentGridCellNode = gridCellNodes[c];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      const newGridCellNode = newGridCellNodes[newColumnIdx];\n\n      if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {\n        {\n          throw Error(`getNodes: expected to find GridCellNode`);\n        }\n      }\n\n      if (r === fromY && c === fromX) {\n        newAnchorCellKey = currentGridCellNode.getKey();\n      } else if (r === toY && c === toX) {\n        newFocusCellKey = currentGridCellNode.getKey();\n      }\n\n      const originalChildren = currentGridCellNode.getChildren();\n      newGridCellNode.getChildren().forEach(child => {\n        if (lexical.$isTextNode(child)) {\n          const paragraphNode = lexical.$createParagraphNode();\n          paragraphNode.append(child);\n          currentGridCellNode.append(child);\n        } else {\n          currentGridCellNode.append(child);\n        }\n      });\n      originalChildren.forEach(n => n.remove());\n      newColumnIdx++;\n    }\n\n    newRowIdx++;\n  }\n\n  if (newAnchorCellKey && newFocusCellKey) {\n    const newGridSelection = lexical.DEPRECATED_$createGridSelection();\n    newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);\n    lexical.$setSelection(newGridSelection);\n    editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, undefined);\n  }\n}\n\nfunction exportNodeToJSON(node) {\n  const serializedNode = node.exportJSON();\n  const nodeClass = node.constructor; // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n  if (serializedNode.type !== nodeClass.getType()) {\n    {\n      throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);\n    }\n  } // @ts-expect-error TODO Replace Class utility type with InstanceType\n\n\n  const serializedChildren = serializedNode.children;\n\n  if (lexical.$isElementNode(node)) {\n    if (!Array.isArray(serializedChildren)) {\n      {\n        throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);\n      }\n    }\n  }\n\n  return serializedNode;\n}\n\nfunction $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {\n  let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;\n  const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy('html');\n  let target = currentNode;\n\n  if (selection$1 !== null) {\n    let clone = selection.$cloneWithProperties(currentNode);\n    clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;\n    target = clone;\n  }\n\n  const children = lexical.$isElementNode(target) ? target.getChildren() : [];\n  const serializedNode = exportNodeToJSON(target); // TODO: TextNode calls getTextContent() (NOT node.__text) within it's exportJSON method\n  // which uses getLatest() to get the text from the original node with the same key.\n  // This is a deeper issue with the word \"clone\" here, it's still a reference to the\n  // same node as far as the LexicalEditor is concerned since it shares a key.\n  // We need a way to create a clone of a Node in memory with it's own key, but\n  // until then this hack will work for the selected text extract use case.\n\n  if (lexical.$isTextNode(target)) {\n    const text = target.__text; // If an uncollapsed selection ends or starts at the end of a line of specialized,\n    // TextNodes, such as code tokens, we will get a 'blank' TextNode here, i.e., one\n    // with text of length 0. We don't want this, it makes a confusing mess. Reset!\n\n    if (text.length > 0) {\n      serializedNode.text = text;\n    } else {\n      shouldInclude = false;\n    }\n  }\n\n  for (let i = 0; i < children.length; i++) {\n    const childNode = children[i];\n    const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);\n\n    if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, 'clone')) {\n      shouldInclude = true;\n    }\n  }\n\n  if (shouldInclude && !shouldExclude) {\n    targetArray.push(serializedNode);\n  } else if (Array.isArray(serializedNode.children)) {\n    for (let i = 0; i < serializedNode.children.length; i++) {\n      const serializedChildNode = serializedNode.children[i];\n      targetArray.push(serializedChildNode);\n    }\n  }\n\n  return shouldInclude;\n} // TODO why $ function with Editor instance?\n\n/**\n * Gets the Lexical JSON of the nodes inside the provided Selection.\n *\n * @param editor LexicalEditor to get the JSON content from.\n * @param selection Selection to get the JSON content from.\n * @returns an object with the editor namespace and a list of serializable nodes as JavaScript objects.\n */\n\n\nfunction $generateJSONFromSelectedNodes(editor, selection) {\n  const nodes = [];\n  const root = lexical.$getRoot();\n  const topLevelChildren = root.getChildren();\n\n  for (let i = 0; i < topLevelChildren.length; i++) {\n    const topLevelNode = topLevelChildren[i];\n    $appendNodesToJSON(editor, selection, topLevelNode, nodes);\n  }\n\n  return {\n    namespace: editor._config.namespace,\n    nodes\n  };\n}\n/**\n * This method takes an array of objects conforming to the BaseSeralizedNode interface and returns\n * an Array containing instances of the corresponding LexicalNode classes registered on the editor.\n * Normally, you'd get an Array of BaseSerialized nodes from {@link $generateJSONFromSelectedNodes}\n *\n * @param serializedNodes an Array of objects conforming to the BaseSerializedNode interface.\n * @returns an Array of Lexical Node objects.\n */\n\nfunction $generateNodesFromSerializedNodes(serializedNodes) {\n  const nodes = [];\n\n  for (let i = 0; i < serializedNodes.length; i++) {\n    const serializedNode = serializedNodes[i];\n    const node = lexical.$parseSerializedNode(serializedNode);\n\n    if (lexical.$isTextNode(node)) {\n      selection.$addNodeStyle(node);\n    }\n\n    nodes.push(node);\n  }\n\n  return nodes;\n}\nconst EVENT_LATENCY = 50;\nlet clipboardEventTimeout = null; // TODO custom selection\n// TODO potentially have a node customizable version for plain text\n\n/**\n * Copies the content of the current selection to the clipboard in\n * text/plain, text/html, and application/x-lexical-editor (Lexical JSON)\n * formats.\n *\n * @param editor the LexicalEditor instance to copy content from\n * @param event the native browser ClipboardEvent to add the content to.\n * @returns\n */\n\nasync function copyToClipboard(editor, event) {\n  if (clipboardEventTimeout !== null) {\n    // Prevent weird race conditions that can happen when this function is run multiple times\n    // synchronously. In the future, we can do better, we can cancel/override the previously running job.\n    return false;\n  }\n\n  if (event !== null) {\n    return new Promise((resolve, reject) => {\n      editor.update(() => {\n        resolve($copyToClipboardEvent(editor, event));\n      });\n    });\n  }\n\n  const rootElement = editor.getRootElement();\n  const windowDocument = editor._window == null ? window.document : editor._window.document;\n  const domSelection = getDOMSelection(editor._window);\n\n  if (rootElement === null || domSelection === null) {\n    return false;\n  }\n\n  const element = windowDocument.createElement('span');\n  element.style.cssText = 'position: fixed; top: -1000px;';\n  element.append(windowDocument.createTextNode('#'));\n  rootElement.append(element);\n  const range = new Range();\n  range.setStart(element, 0);\n  range.setEnd(element, 1);\n  domSelection.removeAllRanges();\n  domSelection.addRange(range);\n  return new Promise((resolve, reject) => {\n    const removeListener = editor.registerCommand(lexical.COPY_COMMAND, secondEvent => {\n      if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {\n        removeListener();\n\n        if (clipboardEventTimeout !== null) {\n          window.clearTimeout(clipboardEventTimeout);\n          clipboardEventTimeout = null;\n        }\n\n        resolve($copyToClipboardEvent(editor, secondEvent));\n      } // Block the entire copy flow while we wait for the next ClipboardEvent\n\n\n      return true;\n    }, lexical.COMMAND_PRIORITY_CRITICAL); // If the above hack execCommand hack works, this timeout code should never fire. Otherwise,\n    // the listener will be quickly freed so that the user can reuse it again\n\n    clipboardEventTimeout = window.setTimeout(() => {\n      removeListener();\n      clipboardEventTimeout = null;\n      resolve(false);\n    }, EVENT_LATENCY);\n    windowDocument.execCommand('copy');\n    element.remove();\n  });\n} // TODO shouldn't pass editor (pass namespace directly)\n\nfunction $copyToClipboardEvent(editor, event) {\n  const domSelection = getDOMSelection(editor._window);\n\n  if (!domSelection) {\n    return false;\n  }\n\n  const anchorDOM = domSelection.anchorNode;\n  const focusDOM = domSelection.focusNode;\n\n  if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {\n    return false;\n  }\n\n  event.preventDefault();\n  const clipboardData = event.clipboardData;\n  const selection = lexical.$getSelection();\n\n  if (clipboardData === null || selection === null) {\n    return false;\n  }\n\n  const htmlString = $getHtmlContent(editor);\n  const lexicalString = $getLexicalContent(editor);\n  let plainString = '';\n\n  if (selection !== null) {\n    plainString = selection.getTextContent();\n  }\n\n  if (htmlString !== null) {\n    clipboardData.setData('text/html', htmlString);\n  }\n\n  if (lexicalString !== null) {\n    clipboardData.setData('application/x-lexical-editor', lexicalString);\n  }\n\n  clipboardData.setData('text/plain', plainString);\n  return true;\n}\n\nexports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;\nexports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;\nexports.$getHtmlContent = $getHtmlContent;\nexports.$getLexicalContent = $getLexicalContent;\nexports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;\nexports.$insertDataTransferForRichText = $insertDataTransferForRichText;\nexports.$insertGeneratedNodes = $insertGeneratedNodes;\nexports.copyToClipboard = copyToClipboard;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalClipboard = process.env.NODE_ENV === 'development' ? require('./LexicalClipboard.dev.js') : require('./LexicalClipboard.prod.js')\nmodule.exports = LexicalClipboard;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar clipboard = require('@lexical/clipboard');\nvar selection = require('@lexical/selection');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction caretFromPoint(x, y) {\n  if (typeof document.caretRangeFromPoint !== 'undefined') {\n    const range = document.caretRangeFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.startContainer,\n      offset: range.startOffset\n    }; // @ts-ignore\n  } else if (document.caretPositionFromPoint !== 'undefined') {\n    // @ts-ignore FF - no types\n    const range = document.caretPositionFromPoint(x, y);\n\n    if (range === null) {\n      return null;\n    }\n\n    return {\n      node: range.offsetNode,\n      offset: range.offset\n    };\n  } else {\n    // Gracefully handle IE\n    return null;\n  }\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst CAN_USE_DOM = typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined';\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst documentMode = CAN_USE_DOM && 'documentMode' in document ? document.documentMode : null;\nCAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nCAN_USE_DOM && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);\nconst CAN_USE_BEFORE_INPUT = CAN_USE_DOM && 'InputEvent' in window && !documentMode ? 'getTargetRanges' in new window.InputEvent('input') : false;\nconst IS_SAFARI = CAN_USE_DOM && /Version\\/[\\d.]+.*Safari/.test(navigator.userAgent);\nconst IS_IOS = CAN_USE_DOM && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; // Keep these in case we need to use them in the future.\n// export const IS_WINDOWS: boolean = CAN_USE_DOM && /Win/.test(navigator.platform);\n\nconst IS_CHROME = CAN_USE_DOM && /^(?=.*Chrome).*/i.test(navigator.userAgent); // export const canUseTextInputEvent: boolean = CAN_USE_DOM && 'TextEvent' in window && !documentMode;\n\nconst IS_APPLE_WEBKIT = CAN_USE_DOM && /AppleWebKit\\/[\\d.]+/.test(navigator.userAgent) && !IS_CHROME;\n\n/** @module @lexical/rich-text */\nconst DRAG_DROP_PASTE = lexical.createCommand('DRAG_DROP_PASTE_FILE');\n\n/** @noInheritDoc */\nclass QuoteNode extends lexical.ElementNode {\n  static getType() {\n    return 'quote';\n  }\n\n  static clone(node) {\n    return new QuoteNode(node.__key);\n  }\n\n  constructor(key) {\n    super(key);\n  } // View\n\n\n  createDOM(config) {\n    const element = document.createElement('blockquote');\n    utils.addClassNamesToElement(element, config.theme.quote);\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      blockquote: node => ({\n        conversion: convertBlockquoteElement,\n        priority: 0\n      })\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && utils.isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createQuoteNode();\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      type: 'quote'\n    };\n  } // Mutation\n\n\n  insertNewAfter(_, restoreSelection) {\n    const newBlock = lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newBlock.setDirection(direction);\n    this.insertAfter(newBlock, restoreSelection);\n    return newBlock;\n  }\n\n  collapseAtStart() {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    this.replace(paragraph);\n    return true;\n  }\n\n}\nfunction $createQuoteNode() {\n  return lexical.$applyNodeReplacement(new QuoteNode());\n}\nfunction $isQuoteNode(node) {\n  return node instanceof QuoteNode;\n}\n\n/** @noInheritDoc */\nclass HeadingNode extends lexical.ElementNode {\n  /** @internal */\n  static getType() {\n    return 'heading';\n  }\n\n  static clone(node) {\n    return new HeadingNode(node.__tag, node.__key);\n  }\n\n  constructor(tag, key) {\n    super(key);\n    this.__tag = tag;\n  }\n\n  getTag() {\n    return this.__tag;\n  } // View\n\n\n  createDOM(config) {\n    const tag = this.__tag;\n    const element = document.createElement(tag);\n    const theme = config.theme;\n    const classNames = theme.heading;\n\n    if (classNames !== undefined) {\n      const className = classNames[tag];\n      utils.addClassNamesToElement(element, className);\n    }\n\n    return element;\n  }\n\n  updateDOM(prevNode, dom) {\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      h1: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h2: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h3: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h4: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h5: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      h6: node => ({\n        conversion: convertHeadingElement,\n        priority: 0\n      }),\n      p: node => {\n        // domNode is a <p> since we matched it by nodeName\n        const paragraph = node;\n        const firstChild = paragraph.firstChild;\n\n        if (firstChild !== null && isGoogleDocsTitle(firstChild)) {\n          return {\n            conversion: () => ({\n              node: null\n            }),\n            priority: 3\n          };\n        }\n\n        return null;\n      },\n      span: node => {\n        if (isGoogleDocsTitle(node)) {\n          return {\n            conversion: domNode => {\n              return {\n                node: $createHeadingNode('h1')\n              };\n            },\n            priority: 3\n          };\n        }\n\n        return null;\n      }\n    };\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && utils.isHTMLElement(element)) {\n      if (this.isEmpty()) element.append(document.createElement('br'));\n      const formatType = this.getFormatType();\n      element.style.textAlign = formatType;\n      const direction = this.getDirection();\n\n      if (direction) {\n        element.dir = direction;\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createHeadingNode(serializedNode.tag);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      tag: this.getTag(),\n      type: 'heading',\n      version: 1\n    };\n  } // Mutation\n\n\n  insertNewAfter(selection, restoreSelection = true) {\n    const anchorOffet = selection ? selection.anchor.offset : 0;\n    const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const direction = this.getDirection();\n    newElement.setDirection(direction);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart() {\n    const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => newElement.append(child));\n    this.replace(newElement);\n    return true;\n  }\n\n  extractWithChild() {\n    return true;\n  }\n\n}\n\nfunction isGoogleDocsTitle(domNode) {\n  if (domNode.nodeName.toLowerCase() === 'span') {\n    return domNode.style.fontSize === '26pt';\n  }\n\n  return false;\n}\n\nfunction convertHeadingElement(element) {\n  const nodeName = element.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'h1' || nodeName === 'h2' || nodeName === 'h3' || nodeName === 'h4' || nodeName === 'h5' || nodeName === 'h6') {\n    node = $createHeadingNode(nodeName);\n\n    if (element.style !== null) {\n      node.setFormat(element.style.textAlign);\n    }\n  }\n\n  return {\n    node\n  };\n}\n\nfunction convertBlockquoteElement(element) {\n  const node = $createQuoteNode();\n\n  if (element.style !== null) {\n    node.setFormat(element.style.textAlign);\n  }\n\n  return {\n    node\n  };\n}\n\nfunction $createHeadingNode(headingTag) {\n  return lexical.$applyNodeReplacement(new HeadingNode(headingTag));\n}\nfunction $isHeadingNode(node) {\n  return node instanceof HeadingNode;\n}\n\nfunction onPasteForRichText(event, editor) {\n  event.preventDefault();\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n    const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;\n\n    if (clipboardData != null && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {\n      clipboard.$insertDataTransferForRichText(clipboardData, selection, editor);\n    }\n  }, {\n    tag: 'paste'\n  });\n}\n\nasync function onCutForRichText(event, editor) {\n  await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      selection.removeText();\n    } else if (lexical.$isNodeSelection(selection)) {\n      selection.getNodes().forEach(node => node.remove());\n    }\n  });\n} // Clipboard may contain files that we aren't allowed to read. While the event is arguably useless,\n// in certain ocassions, we want to know whether it was a file transfer, as opposed to text. We\n// control this with the first boolean flag.\n\n\nfunction eventFiles(event) {\n  let dataTransfer = null;\n\n  if (event instanceof DragEvent) {\n    dataTransfer = event.dataTransfer;\n  } else if (event instanceof ClipboardEvent) {\n    dataTransfer = event.clipboardData;\n  }\n\n  if (dataTransfer === null) {\n    return [false, [], false];\n  }\n\n  const types = dataTransfer.types;\n  const hasFiles = types.includes('Files');\n  const hasContent = types.includes('text/html') || types.includes('text/plain');\n  return [hasFiles, Array.from(dataTransfer.files), hasContent];\n}\n\nfunction handleIndentAndOutdent(indentOrOutdent) {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection)) {\n    return false;\n  }\n\n  const alreadyHandled = new Set();\n  const nodes = selection.getNodes();\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    const key = node.getKey();\n\n    if (alreadyHandled.has(key)) {\n      continue;\n    }\n\n    const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);\n    const parentKey = parentBlock.getKey();\n\n    if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {\n      alreadyHandled.add(parentKey);\n      indentOrOutdent(parentBlock);\n    }\n  }\n\n  return alreadyHandled.size > 0;\n}\n\nfunction $isTargetWithinDecorator(target) {\n  const node = lexical.$getNearestNodeFromDOMNode(target);\n  return lexical.$isDecoratorNode(node);\n}\n\nfunction $isSelectionAtEndOfRoot(selection) {\n  const focus = selection.focus;\n  return focus.key === 'root' && focus.offset === lexical.$getRoot().getChildrenSize();\n}\n\nfunction registerRichText(editor) {\n  const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, payload => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      selection.clear();\n      return true;\n    }\n\n    return false;\n  }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteCharacter(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteWord(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, isBackward => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.deleteLine(isBackward);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, eventOrText => {\n    const selection = lexical.$getSelection();\n\n    if (typeof eventOrText === 'string') {\n      if (lexical.$isRangeSelection(selection)) {\n        selection.insertText(eventOrText);\n      } else if (lexical.DEPRECATED_$isGridSelection(selection)) ;\n    } else {\n      if (!lexical.$isRangeSelection(selection) && !lexical.DEPRECATED_$isGridSelection(selection)) {\n        return false;\n      }\n\n      const dataTransfer = eventOrText.dataTransfer;\n\n      if (dataTransfer != null) {\n        clipboard.$insertDataTransferForRichText(dataTransfer, selection, editor);\n      } else if (lexical.$isRangeSelection(selection)) {\n        const data = eventOrText.data;\n\n        if (data) {\n          selection.insertText(data);\n        }\n\n        return true;\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.removeText();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.formatText(format);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, format => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection) && !lexical.$isNodeSelection(selection)) {\n      return false;\n    }\n\n    const nodes = selection.getNodes();\n\n    for (const node of nodes) {\n      const element = utils.$findMatchingParent(node, parentNode => lexical.$isElementNode(parentNode) && !parentNode.isInline());\n\n      if (element !== null) {\n        element.setFormat(format);\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, selectStart => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertLineBreak(selectStart);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    selection.insertParagraph();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {\n    lexical.$insertNodes([lexical.$createTabNode()]);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n      block.setIndent(indent + 1);\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {\n    return handleIndentAndOutdent(block => {\n      const indent = block.getIndent();\n\n      if (indent > 0) {\n        block.setIndent(indent - 1);\n      }\n    });\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectPrevious();\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, true);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectPrevious();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection.getNodes();\n\n      if (nodes.length > 0) {\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    } else if (lexical.$isRangeSelection(selection)) {\n      if ($isSelectionAtEndOfRoot(selection)) {\n        event.preventDefault();\n        return true;\n      }\n\n      const possibleNode = lexical.$getAdjacentNode(selection.focus, false);\n\n      if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {\n        possibleNode.selectNext();\n        event.preventDefault();\n        return true;\n      }\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectPrevious();\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {\n      const isHoldingShift = event.shiftKey;\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, true);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, event => {\n    const selection$1 = lexical.$getSelection();\n\n    if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {\n      // If selection is on a node, let's try and move selection\n      // back to being a range selection.\n      const nodes = selection$1.getNodes();\n\n      if (nodes.length > 0) {\n        event.preventDefault();\n        nodes[0].selectNext(0, 0);\n        return true;\n      }\n    }\n\n    if (!lexical.$isRangeSelection(selection$1)) {\n      return false;\n    }\n\n    const isHoldingShift = event.shiftKey;\n\n    if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {\n      event.preventDefault();\n      selection.$moveCharacter(selection$1, isHoldingShift, false);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const {\n      anchor\n    } = selection;\n    const anchorNode = anchor.getNode();\n\n    if (selection.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {\n      const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);\n\n      if (element.getIndent() > 0) {\n        return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, undefined);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, event => {\n    if ($isTargetWithinDecorator(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    if (event !== null) {\n      // If we have beforeinput, then we can avoid blocking\n      // the default behavior. This ensures that the iOS can\n      // intercept that we're actually inserting a paragraph,\n      // and autocomplete, autocapitalize etc work as intended.\n      // This can also cause a strange performance issue in\n      // Safari, where there is a noticeable pause due to\n      // preventing the key down of enter.\n      if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {\n        return false;\n      }\n\n      event.preventDefault();\n\n      if (event.shiftKey) {\n        return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);\n      }\n    }\n\n    return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    editor.blur();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, event => {\n    const [, files] = eventFiles(event);\n\n    if (files.length > 0) {\n      const x = event.clientX;\n      const y = event.clientY;\n      const eventRange = caretFromPoint(x, y);\n\n      if (eventRange !== null) {\n        const {\n          offset: domOffset,\n          node: domNode\n        } = eventRange;\n        const node = lexical.$getNearestNodeFromDOMNode(domNode);\n\n        if (node !== null) {\n          const selection = lexical.$createRangeSelection();\n\n          if (lexical.$isTextNode(node)) {\n            selection.anchor.set(node.getKey(), domOffset, 'text');\n            selection.focus.set(node.getKey(), domOffset, 'text');\n          } else {\n            const parentKey = node.getParentOrThrow().getKey();\n            const offset = node.getIndexWithinParent() + 1;\n            selection.anchor.set(parentKey, offset, 'element');\n            selection.focus.set(parentKey, offset, 'element');\n          }\n\n          const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection);\n          lexical.$setSelection(normalizedSelection);\n        }\n\n        editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      }\n\n      event.preventDefault();\n      return true;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, event => {\n    const [isFileTransfer] = eventFiles(event);\n    const selection = lexical.$getSelection();\n\n    if (isFileTransfer && !lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const x = event.clientX;\n    const y = event.clientY;\n    const eventRange = caretFromPoint(x, y);\n\n    if (eventRange !== null) {\n      const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);\n\n      if (lexical.$isDecoratorNode(node)) {\n        // Show browser caret as the user is dragging the media across the screen. Won't work\n        // for DecoratorNode nor it's relevant.\n        event.preventDefault();\n      }\n    }\n\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.SELECT_ALL_COMMAND, () => {\n    lexical.$selectAll();\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, event => {\n    clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, event => {\n    onCutForRichText(event, editor);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, event => {\n    const [, files, hasTextContent] = eventFiles(event);\n\n    if (files.length > 0 && !hasTextContent) {\n      editor.dispatchCommand(DRAG_DROP_PASTE, files);\n      return true;\n    } // if inputs then paste within the input ignore creating a new node on paste event\n\n\n    if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {\n      return false;\n    }\n\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      onPasteForRichText(event, editor);\n      return true;\n    }\n\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR));\n  return removeListener;\n}\n\nexports.$createHeadingNode = $createHeadingNode;\nexports.$createQuoteNode = $createQuoteNode;\nexports.$isHeadingNode = $isHeadingNode;\nexports.$isQuoteNode = $isQuoteNode;\nexports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;\nexports.HeadingNode = HeadingNode;\nexports.QuoteNode = QuoteNode;\nexports.eventFiles = eventFiles;\nexports.registerRichText = registerRichText;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalRichText = process.env.NODE_ENV === 'development' ? require('./LexicalRichText.dev.js') : require('./LexicalRichText.prod.js')\nmodule.exports = LexicalRichText;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nconst LexicalComposerContext = /*#__PURE__*/react.createContext(null);\nfunction createLexicalComposerContext(parent, theme) {\n  let parentContext = null;\n\n  if (parent != null) {\n    parentContext = parent[1];\n  }\n\n  function getTheme() {\n    if (theme != null) {\n      return theme;\n    }\n\n    return parentContext != null ? parentContext.getTheme() : null;\n  }\n\n  return {\n    getTheme\n  };\n}\nfunction useLexicalComposerContext() {\n  const composerContext = react.useContext(LexicalComposerContext);\n\n  if (composerContext == null) {\n    {\n      throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);\n    }\n  }\n\n  return composerContext;\n}\n\nexports.LexicalComposerContext = LexicalComposerContext;\nexports.createLexicalComposerContext = createLexicalComposerContext;\nexports.useLexicalComposerContext = useLexicalComposerContext;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalComposerContext = process.env.NODE_ENV === 'development' ? require('./LexicalComposerContext.dev.js') : require('./LexicalComposerContext.prod.js')\nmodule.exports = LexicalComposerContext;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/** @module @lexical/history */\nconst HISTORY_MERGE = 0;\nconst HISTORY_PUSH = 1;\nconst DISCARD_HISTORY_CANDIDATE = 2;\nconst OTHER = 0;\nconst COMPOSING_CHARACTER = 1;\nconst INSERT_CHARACTER_AFTER_SELECTION = 2;\nconst DELETE_CHARACTER_BEFORE_SELECTION = 3;\nconst DELETE_CHARACTER_AFTER_SELECTION = 4;\n\nfunction getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {\n  const nodeMap = editorState._nodeMap;\n  const nodes = [];\n\n  for (const dirtyLeafKey of dirtyLeaves) {\n    const dirtyLeaf = nodeMap.get(dirtyLeafKey);\n\n    if (dirtyLeaf !== undefined) {\n      nodes.push(dirtyLeaf);\n    }\n  }\n\n  for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {\n    if (!intentionallyMarkedAsDirty) {\n      continue;\n    }\n\n    const dirtyElement = nodeMap.get(dirtyElementKey);\n\n    if (dirtyElement !== undefined && !lexical.$isRootNode(dirtyElement)) {\n      nodes.push(dirtyElement);\n    }\n  }\n\n  return nodes;\n}\n\nfunction getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {\n  if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {\n    return OTHER;\n  }\n\n  const nextSelection = nextEditorState._selection;\n  const prevSelection = prevEditorState._selection;\n\n  if (isComposing) {\n    return COMPOSING_CHARACTER;\n  }\n\n  if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {\n    return OTHER;\n  }\n\n  const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);\n\n  if (dirtyNodes.length === 0) {\n    return OTHER;\n  } // Catching the case when inserting new text node into an element (e.g. first char in paragraph/list),\n  // or after existing node.\n\n\n  if (dirtyNodes.length > 1) {\n    const nextNodeMap = nextEditorState._nodeMap;\n    const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);\n    const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);\n\n    if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {\n      return INSERT_CHARACTER_AFTER_SELECTION;\n    }\n\n    return OTHER;\n  }\n\n  const nextDirtyNode = dirtyNodes[0];\n\n  const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);\n\n  if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {\n    return OTHER;\n  }\n\n  const prevText = prevDirtyNode.__text;\n  const nextText = nextDirtyNode.__text;\n\n  if (prevText === nextText) {\n    return OTHER;\n  }\n\n  const nextAnchor = nextSelection.anchor;\n  const prevAnchor = prevSelection.anchor;\n\n  if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== 'text') {\n    return OTHER;\n  }\n\n  const nextAnchorOffset = nextAnchor.offset;\n  const prevAnchorOffset = prevAnchor.offset;\n  const textDiff = nextText.length - prevText.length;\n\n  if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {\n    return INSERT_CHARACTER_AFTER_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {\n    return DELETE_CHARACTER_BEFORE_SELECTION;\n  }\n\n  if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {\n    return DELETE_CHARACTER_AFTER_SELECTION;\n  }\n\n  return OTHER;\n}\n\nfunction isTextNodeUnchanged(key, prevEditorState, nextEditorState) {\n  const prevNode = prevEditorState._nodeMap.get(key);\n\n  const nextNode = nextEditorState._nodeMap.get(key);\n\n  const prevSelection = prevEditorState._selection;\n  const nextSelection = nextEditorState._selection;\n  let isDeletingLine = false;\n\n  if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {\n    isDeletingLine = prevSelection.anchor.type === 'element' && prevSelection.focus.type === 'element' && nextSelection.anchor.type === 'text' && nextSelection.focus.type === 'text';\n  }\n\n  if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {\n    return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;\n  }\n\n  return false;\n}\n\nfunction createMergeActionGetter(editor, delay) {\n  let prevChangeTime = Date.now();\n  let prevChangeType = OTHER;\n  return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {\n    const changeTime = Date.now(); // If applying changes from history stack there's no need\n    // to run history logic again, as history entries already calculated\n\n    if (tags.has('historic')) {\n      prevChangeType = OTHER;\n      prevChangeTime = changeTime;\n      return DISCARD_HISTORY_CANDIDATE;\n    }\n\n    const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());\n\n    const mergeAction = (() => {\n      const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;\n      const shouldPushHistory = tags.has('history-push');\n      const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has('history-merge');\n\n      if (shouldMergeHistory) {\n        return HISTORY_MERGE;\n      }\n\n      if (prevEditorState === null) {\n        return HISTORY_PUSH;\n      }\n\n      const selection = nextEditorState._selection;\n      const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;\n\n      if (!hasDirtyNodes) {\n        if (selection !== null) {\n          return HISTORY_MERGE;\n        }\n\n        return DISCARD_HISTORY_CANDIDATE;\n      }\n\n      if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {\n        return HISTORY_MERGE;\n      } // A single node might have been marked as dirty, but not have changed\n      // due to some node transform reverting the change.\n\n\n      if (dirtyLeaves.size === 1) {\n        const dirtyLeafKey = Array.from(dirtyLeaves)[0];\n\n        if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {\n          return HISTORY_MERGE;\n        }\n      }\n\n      return HISTORY_PUSH;\n    })();\n\n    prevChangeTime = changeTime;\n    prevChangeType = changeType;\n    return mergeAction;\n  };\n}\n\nfunction redo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n\n  if (redoStack.length !== 0) {\n    const current = historyState.current;\n\n    if (current !== null) {\n      undoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n    }\n\n    const historyStateEntry = redoStack.pop();\n\n    if (redoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction undo(editor, historyState) {\n  const redoStack = historyState.redoStack;\n  const undoStack = historyState.undoStack;\n  const undoStackLength = undoStack.length;\n\n  if (undoStackLength !== 0) {\n    const current = historyState.current;\n    const historyStateEntry = undoStack.pop();\n\n    if (current !== null) {\n      redoStack.push(current);\n      editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);\n    }\n\n    if (undoStack.length === 0) {\n      editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    }\n\n    historyState.current = historyStateEntry || null;\n\n    if (historyStateEntry) {\n      historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {\n        tag: 'historic'\n      });\n    }\n  }\n}\n\nfunction clearHistory(historyState) {\n  historyState.undoStack = [];\n  historyState.redoStack = [];\n  historyState.current = null;\n}\n/**\n * Registers necessary listeners to manage undo/redo history stack and related editor commands.\n * It returns `unregister` callback that cleans up all listeners and should be called on editor unmount.\n * @param editor - The lexical editor.\n * @param historyState - The history state, containing the current state and the undo/redo stack.\n * @param delay - The time (in milliseconds) the editor should delay generating a new history stack,\n * instead of merging the current changes with the current stack.\n * @returns The listeners cleanup callback function.\n */\n\n\nfunction registerHistory(editor, historyState, delay) {\n  const getMergeAction = createMergeActionGetter(editor, delay);\n\n  const applyChange = ({\n    editorState,\n    prevEditorState,\n    dirtyLeaves,\n    dirtyElements,\n    tags\n  }) => {\n    const current = historyState.current;\n    const redoStack = historyState.redoStack;\n    const undoStack = historyState.undoStack;\n    const currentEditorState = current === null ? null : current.editorState;\n\n    if (current !== null && editorState === currentEditorState) {\n      return;\n    }\n\n    const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);\n\n    if (mergeAction === HISTORY_PUSH) {\n      if (redoStack.length !== 0) {\n        historyState.redoStack = [];\n        editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n      }\n\n      if (current !== null) {\n        undoStack.push({ ...current\n        });\n        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);\n      }\n    } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {\n      return;\n    } // Else we merge\n\n\n    historyState.current = {\n      editor,\n      editorState\n    };\n  };\n\n  const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {\n    undo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {\n    redo(editor, historyState);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {\n    clearHistory(historyState);\n    return false;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {\n    clearHistory(historyState);\n    editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);\n    editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);\n    return true;\n  }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));\n  const unregisterUpdateListener = editor.registerUpdateListener(applyChange);\n  return () => {\n    unregisterCommandListener();\n    unregisterUpdateListener();\n  };\n}\n/**\n * Creates an empty history state.\n * @returns - The empty history state, as an object.\n */\n\nfunction createEmptyHistoryState() {\n  return {\n    current: null,\n    redoStack: [],\n    undoStack: []\n  };\n}\n\nexports.createEmptyHistoryState = createEmptyHistoryState;\nexports.registerHistory = registerHistory;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHistory = process.env.NODE_ENV === 'development' ? require('./LexicalHistory.dev.js') : require('./LexicalHistory.prod.js')\nmodule.exports = LexicalHistory;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar history = require('@lexical/history');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useHistory(editor, externalHistoryState, delay = 1000) {\n  const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);\n  react.useEffect(() => {\n    return history.registerHistory(editor, historyState, delay);\n  }, [delay, editor, historyState]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction HistoryPlugin({\n  externalHistoryState\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useHistory(editor, externalHistoryState);\n  return null;\n}\n\nexports.createEmptyHistoryState = history.createEmptyHistoryState;\nexports.HistoryPlugin = HistoryPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalHistoryPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalHistoryPlugin.dev.js') : require('./LexicalHistoryPlugin.prod.js')\nmodule.exports = LexicalHistoryPlugin;", "const IS_BOLD = 1;\nconst IS_ITALIC = 2;\nconst IS_UNDERLINE = 8;\nconst IS_CODE = 16;\nexport {\n  IS_BOLD,\n  IS_CODE,\n  IS_ITALIC,\n  IS_UNDERLINE\n};\n", "function tap(arg, proc) {\n  proc(arg);\n  return arg;\n}\nfunction always(value) {\n  return () => value;\n}\nfunction noop() {\n}\nexport {\n  always,\n  noop,\n  tap\n};\n", "const CAN_USE_DOM = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);\nfunction controlOrMeta(metaKey, ctrlKey) {\n  if (IS_APPLE) {\n    return metaKey;\n  }\n  return ctrlKey;\n}\nexport {\n  CAN_USE_DOM,\n  IS_APPLE,\n  controlOrMeta\n};\n", "function uuidv4() {\n  const hex = [...Array(256).keys()].map((index) => index.toString(16).padStart(2, \"0\"));\n  const r = crypto.getRandomValues(new Uint8Array(16));\n  r[6] = r[6] & 15 | 64;\n  r[8] = r[8] & 63 | 128;\n  return [...r.entries()].map(([index, int]) => [4, 6, 8, 10].includes(index) ? `-${hex[int]}` : hex[int]).join(\"\");\n}\nexport {\n  uuidv4\n};\n", "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nimport { tap } from \"../utils/fp.js\";\nimport { uuidv4 } from \"../utils/uuid4.js\";\nfunction defaultComparator(current, next) {\n  return current === next;\n}\nclass SetMap {\n  constructor() {\n    __publicField(this, \"map\", /* @__PURE__ */ new Map());\n  }\n  getOrCreate(key) {\n    let record = this.map.get(key);\n    if (!record) {\n      record = /* @__PURE__ */ new Set();\n      this.map.set(key, record);\n    }\n    return record;\n  }\n  get(key) {\n    return this.map.get(key);\n  }\n  use(key, cb) {\n    const set = this.get(key);\n    if (set !== void 0) {\n      cb(set);\n    }\n  }\n  delete(key) {\n    return this.map.delete(key);\n  }\n}\nclass RefCount {\n  constructor(map = /* @__PURE__ */ new Map()) {\n    __publicField(this, \"map\");\n    this.map = map;\n  }\n  clone() {\n    return new RefCount(new Map(this.map));\n  }\n  increment(key) {\n    const counter = this.map.get(key) ?? 0;\n    this.map.set(key, counter + 1);\n  }\n  decrement(key, ifZero) {\n    let counter = this.map.get(key);\n    if (counter !== void 0) {\n      counter -= 1;\n      this.map.set(key, counter);\n      if (counter === 0) {\n        ifZero();\n      }\n    }\n  }\n}\nconst NO_VALUE = Symbol(\"NO_VALUE\");\nfunction realm() {\n  const subscriptions = new SetMap();\n  const singletonSubscriptions = /* @__PURE__ */ new Map();\n  const graph = new SetMap();\n  const state = /* @__PURE__ */ new Map();\n  const distinctNodes = /* @__PURE__ */ new Map();\n  const labels = {};\n  function node(value = NO_VALUE, distinct = false) {\n    const key = uuidv4();\n    if (value !== NO_VALUE) {\n      state.set(key, value);\n    }\n    if (distinct !== false) {\n      distinctNodes.set(key, distinct === true ? defaultComparator : distinct);\n    }\n    return { key, toString: () => key };\n  }\n  function subSingle({ key }, subscription) {\n    const nodeSubscriptions = subscriptions.getOrCreate(key);\n    nodeSubscriptions.add(subscription);\n    return () => nodeSubscriptions.delete(subscription);\n  }\n  function singletonSub({ key }, subscription) {\n    if (!subscription) {\n      singletonSubscriptions.delete(key);\n    } else {\n      singletonSubscriptions.set(key, subscription);\n    }\n    return () => singletonSubscriptions.delete(key);\n  }\n  function singletonSubKey(key, subscription) {\n    return singletonSub(labels[key], subscription);\n  }\n  function resetSingletonSubs() {\n    singletonSubscriptions.clear();\n  }\n  function subMultiple(sources, cb) {\n    const sink = node();\n    connect({\n      map: (done) => (...args) => {\n        done(args);\n      },\n      sink,\n      sources\n    });\n    return subSingle(sink, cb);\n  }\n  function sub(...args) {\n    const [subscription] = args.slice(-1);\n    const nodes = args.slice(0, -1);\n    if (nodes.length === 1) {\n      return subSingle(nodes[0], subscription);\n    } else {\n      return subMultiple(nodes, subscription);\n    }\n  }\n  function calculateExecutionMap(keys) {\n    const participatingNodeKeys = [];\n    const visitedNodes = /* @__PURE__ */ new Set();\n    const pendingPulls = new SetMap();\n    const refCount = new RefCount();\n    const projections = new SetMap();\n    function visit(key, insertIndex = 0) {\n      refCount.increment(key);\n      if (visitedNodes.has(key)) {\n        return;\n      }\n      pendingPulls.use(key, (pulls) => {\n        insertIndex = Math.max(...Array.from(pulls).map((key2) => participatingNodeKeys.indexOf(key2))) + 1;\n      });\n      graph.use(key, (sinkProjections) => {\n        sinkProjections.forEach((projection) => {\n          if (projection.sources.has(key)) {\n            projections.getOrCreate(projection.sink).add(projection);\n            visit(projection.sink, insertIndex);\n          } else {\n            pendingPulls.getOrCreate(projection.sink).add(key);\n          }\n        });\n      });\n      visitedNodes.add(key);\n      participatingNodeKeys.splice(insertIndex, 0, key);\n    }\n    keys.forEach((key) => visit(key));\n    return { participatingNodeKeys, pendingPulls, projections, refCount };\n  }\n  const executionMaps = /* @__PURE__ */ new Map();\n  function pubIn(values) {\n    var _a;\n    const keys = Object.keys(values);\n    const executionMapKey = keys.join(\",\");\n    if (!executionMaps.has(executionMapKey)) {\n      executionMaps.set(executionMapKey, calculateExecutionMap(keys));\n    }\n    const map2 = executionMaps.get(executionMapKey);\n    const refCount = map2.refCount.clone();\n    const participatingNodeKeys = map2.participatingNodeKeys.slice();\n    const transientState = new Map(state);\n    function nodeWillNotEmit(key) {\n      graph.use(key, (projections) => {\n        projections.forEach(({ sources, sink }) => {\n          if (sources.has(key)) {\n            refCount.decrement(sink, () => {\n              participatingNodeKeys.splice(participatingNodeKeys.indexOf(sink), 1);\n              nodeWillNotEmit(sink);\n            });\n          }\n        });\n      });\n    }\n    let nodeKey;\n    while (nodeKey = participatingNodeKeys.shift()) {\n      let resolved = false;\n      const done = (value) => {\n        if (distinctNodes.has(nodeKey) && distinctNodes.get(nodeKey)(state.get(nodeKey), value)) {\n          resolved = false;\n          return;\n        }\n        resolved = true;\n        transientState.set(nodeKey, value);\n        if (state.has(nodeKey)) {\n          state.set(nodeKey, value);\n        }\n      };\n      if (Object.prototype.hasOwnProperty.call(values, nodeKey)) {\n        done(values[nodeKey]);\n      } else {\n        map2.projections.use(nodeKey, (nodeProjections) => {\n          nodeProjections.forEach((projection) => {\n            const args = [...Array.from(projection.sources), ...Array.from(projection.pulls)].map((id) => transientState.get(id));\n            projection.map(done)(...args);\n          });\n        });\n      }\n      if (resolved) {\n        const value = transientState.get(nodeKey);\n        subscriptions.use(nodeKey, (nodeSubscriptions) => {\n          nodeSubscriptions.forEach((subscription) => subscription(value));\n        });\n        (_a = singletonSubscriptions.get(nodeKey)) == null ? void 0 : _a(value);\n      } else {\n        nodeWillNotEmit(nodeKey);\n      }\n    }\n  }\n  function nodesToKeySet(nodes) {\n    return new Set(nodes.map((s) => s.key));\n  }\n  function connect({ sources, pulls = [], map: map2, sink: { key: sink } }) {\n    const dependency = {\n      map: map2,\n      pulls: nodesToKeySet(pulls),\n      sink,\n      sources: nodesToKeySet(sources)\n    };\n    [...sources, ...pulls].forEach(({ key: sourceKey }) => {\n      graph.getOrCreate(sourceKey).add(dependency);\n    });\n    executionMaps.clear();\n  }\n  function debug() {\n    Object.entries(labels).forEach(([name, value]) => {\n      state.get(value.key);\n    });\n  }\n  function pub(...args) {\n    const map2 = {};\n    for (let index = 0; index < args.length; index += 2) {\n      const node2 = args[index];\n      map2[node2.key] = args[index + 1];\n    }\n    pubIn(map2);\n  }\n  function label(newLabels) {\n    Object.assign(labels, newLabels);\n  }\n  function pipe(source, ...operators) {\n    for (const operator of operators) {\n      source = operator(source);\n    }\n    return source;\n  }\n  function spread(source, initialValues) {\n    return initialValues.map((initialValue, index) => {\n      return tap(node(initialValue, true), (sink) => {\n        connect({\n          map: (done) => (sourceValue) => {\n            done(sourceValue[index]);\n          },\n          sink,\n          sources: [source]\n        });\n      });\n    });\n  }\n  function link(source, sink) {\n    connect({ map: (done) => (value) => done(value), sink, sources: [source] });\n  }\n  function derive(source, initial) {\n    return tap(node(initial, true), (sink) => {\n      connect({ map: (done) => (value) => done(value), sink, sources: [source] });\n    });\n  }\n  function map(mapFunction) {\n    return (source) => {\n      const sink = node();\n      connect({\n        map: (done) => (value) => {\n          done(mapFunction(value));\n        },\n        sink,\n        sources: [source]\n      });\n      return sink;\n    };\n  }\n  function mapTo(value) {\n    return (source) => {\n      const sink = node();\n      connect({ map: (done) => () => done(value), sink, sources: [source] });\n      return sink;\n    };\n  }\n  function filter(predicate) {\n    return (source) => {\n      const sink = node();\n      connect({ map: (done) => (value) => predicate(value) && done(value), sink, sources: [source] });\n      return sink;\n    };\n  }\n  function once() {\n    return (source) => {\n      const sink = node();\n      let passed = false;\n      connect({\n        map: (done) => (value) => {\n          if (!passed) {\n            passed = true;\n            done(value);\n          }\n        },\n        sink,\n        sources: [source]\n      });\n      return sink;\n    };\n  }\n  function scan(accumulator, seed) {\n    return (source) => {\n      const sink = node();\n      connect({ map: (done) => (value) => done(seed = accumulator(seed, value)), sink, sources: [source] });\n      return sink;\n    };\n  }\n  function throttleTime(delay) {\n    return (source) => {\n      const sink = node();\n      let currentValue;\n      let timeout;\n      sub(source, (value) => {\n        currentValue = value;\n        if (timeout) {\n          return;\n        }\n        timeout = setTimeout(() => {\n          timeout = void 0;\n          pub(sink, currentValue);\n        }, delay);\n      });\n      return sink;\n    };\n  }\n  function delayWithMicrotask() {\n    return (source) => {\n      const sink = node();\n      sub(source, (value) => queueMicrotask(() => pub(sink, value)));\n      return sink;\n    };\n  }\n  function debounceTime(delay) {\n    return (source) => {\n      const sink = node();\n      let currentValue;\n      let timeout;\n      sub(source, (value) => {\n        currentValue = value;\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        timeout = setTimeout(() => {\n          pub(sink, currentValue);\n        }, delay);\n      });\n      return sink;\n    };\n  }\n  function onNext(bufNode) {\n    return (source) => {\n      const sink = node();\n      let pendingValue = NO_VALUE;\n      sub(source, (value) => pendingValue = value);\n      connect({\n        map: (done) => (value) => {\n          if (pendingValue !== NO_VALUE) {\n            done([pendingValue, value]);\n            pendingValue = NO_VALUE;\n          }\n        },\n        sink,\n        sources: [bufNode]\n      });\n      return sink;\n    };\n  }\n  function passOnlyAfterNodeHasEmittedBefore(starterNode, durationNode) {\n    return (source) => {\n      const sink = node();\n      let startTime = 0;\n      sub(starterNode, () => startTime = Date.now());\n      connect({\n        map: (done) => (value) => {\n          if (Date.now() < startTime + state.get(durationNode.key)) {\n            done(value);\n          }\n        },\n        sink,\n        sources: [source]\n      });\n      return sink;\n    };\n  }\n  function withLatestFrom(...nodes) {\n    return (source) => {\n      const sink = node();\n      connect({\n        map: (done) => (...args) => done(args),\n        pulls: nodes,\n        sink,\n        sources: [source]\n      });\n      return sink;\n    };\n  }\n  function combine(...nodes) {\n    const sink = node();\n    connect({\n      map: (done) => (...args) => done(args),\n      sink,\n      sources: nodes\n    });\n    return sink;\n  }\n  function subKey(key, subscription) {\n    return sub(labels[key], subscription);\n  }\n  function subKeys(keys, subscription) {\n    const nodes = keys.map((key) => labels[key]);\n    return sub(...nodes.concat(subscription));\n  }\n  function pubKey(key, value) {\n    pubKeys({ [key]: value });\n  }\n  function pubKeys(values) {\n    const valuesWithInternalKeys = Object.entries(values).reduce(\n      (acc, [key, value]) => tap(acc, (acc2) => {\n        const label2 = labels[key];\n        if (!label2) {\n          throw new Error(`No label for key ${key}. Do you miss a plugin?`);\n        }\n        acc2[label2.key] = value;\n        return value;\n      }),\n      {}\n    );\n    pubIn(valuesWithInternalKeys);\n  }\n  function getKeyValue(key) {\n    return state.get(labels[key].key);\n  }\n  function getValue(node2) {\n    return state.get(node2.key);\n  }\n  function getKeyValues(keys) {\n    return keys.map((key) => {\n      const label2 = labels[key];\n      if (!label2) {\n        throw new Error(`No label for key ${key}. Do you miss a plugin?`);\n      }\n      return state.get(label2.key);\n    });\n  }\n  return {\n    combine,\n    connect,\n    debug,\n    derive,\n    getKeyValue,\n    getValue,\n    getKeyValues,\n    label,\n    labels,\n    link,\n    node,\n    o: {\n      delayWithMicrotask,\n      debounceTime,\n      filter,\n      map,\n      mapTo,\n      onNext,\n      scan,\n      throttleTime,\n      withLatestFrom,\n      once,\n      passOnlyAfterNodeHasEmittedBefore\n    },\n    pipe,\n    pub,\n    pubIn,\n    pubKey,\n    pubKeys,\n    resetSingletonSubs,\n    singletonSub,\n    singletonSubKey,\n    spread,\n    sub,\n    subKey,\n    subKeys\n  };\n}\nexport {\n  RefCount,\n  defaultComparator,\n  realm\n};\n", "import { uuidv4 } from \"../utils/uuid4.js\";\nimport { realm } from \"./realm.js\";\nfunction system(constructor, dependencies = []) {\n  return {\n    constructor,\n    dependencies,\n    id: uuidv4()\n  };\n}\nfunction realmFactory(...specs) {\n  const singletons = /* @__PURE__ */ new Map();\n  const r = realm();\n  const _init = ({ id, constructor, dependencies }) => {\n    if (singletons.has(id)) {\n      return singletons.get(id);\n    }\n    const system2 = constructor(r, dependencies.map((t) => _init(specs.find((spec) => spec.id === t.id))));\n    r.label(system2);\n    singletons.set(id, system2);\n    return system2;\n  };\n  specs.forEach(_init);\n  return r;\n}\nfunction getRealmFactory(...specs) {\n  return () => realmFactory(...specs);\n}\nexport {\n  getRealmFactory,\n  realmFactory,\n  system\n};\n", "import React__default, { useEffect } from \"react\";\nimport { tap, always } from \"../utils/fp.js\";\nimport { realmFactory } from \"./realmFactory.js\";\nfunction omit(keys, obj) {\n  const result = {};\n  const index = {};\n  let idx = 0;\n  const len = keys.length;\n  while (idx < len) {\n    index[keys[idx]] = 1;\n    idx += 1;\n  }\n  for (const prop in obj) {\n    if (!Object.prototype.hasOwnProperty.call(index, prop)) {\n      result[prop] = obj[prop];\n    }\n  }\n  return result;\n}\nconst useIsomorphicLayoutEffect = typeof document !== \"undefined\" ? React__default.useLayoutEffect : React__default.useEffect;\nconst GurxContext = React__default.createContext(void 0);\nfunction realmFactoryToComponent(realmFactory2, map, Root) {\n  const requiredPropNames = Object.keys(map.required || {});\n  const optionalPropNames = Object.keys(map.optional || {});\n  const methodNames = Object.keys(map.methods || {});\n  const eventNames = Object.keys(map.events || {});\n  const Context = GurxContext;\n  function applyPropsToRealm(realm, props) {\n    const toBePublished = {};\n    for (const requiredPropName of requiredPropNames) {\n      const nodeName = map.required[requiredPropName];\n      toBePublished[nodeName] = props[requiredPropName];\n    }\n    for (const optionalPropName of optionalPropNames) {\n      const value = props[optionalPropName];\n      if (value !== void 0) {\n        const nodeName = map.optional[optionalPropName];\n        toBePublished[nodeName] = value;\n      }\n    }\n    realm.pubKeys(toBePublished);\n  }\n  function buildMethods(realm) {\n    return methodNames.reduce((acc, methodName) => {\n      const nodeName = map.methods[methodName];\n      acc[methodName] = (value) => {\n        realm.pubKey(nodeName, value);\n      };\n      return acc;\n    }, {});\n  }\n  const Component = React__default.forwardRef((props, ref) => {\n    const realm = React__default.useMemo(() => {\n      return tap(realmFactory2(), (realm2) => applyPropsToRealm(realm2, props));\n    }, []);\n    useIsomorphicLayoutEffect(() => {\n      applyPropsToRealm(realm, props);\n      realm.resetSingletonSubs();\n      for (const eventName of eventNames) {\n        if (eventName in props) {\n          realm.singletonSubKey(map.events[eventName], props[eventName]);\n        }\n      }\n      return () => {\n        realm.resetSingletonSubs();\n      };\n    }, [props]);\n    React__default.useImperativeHandle(ref, always(buildMethods(realm)));\n    const children = props.children;\n    return React__default.createElement(\n      Context.Provider,\n      { value: realm },\n      Root ? React__default.createElement(\n        Root,\n        omit([...requiredPropNames, ...optionalPropNames, ...eventNames], props),\n        children\n      ) : children\n    );\n  });\n  Component.displayName = \"Gurx Component\";\n  return {\n    Component,\n    ...sysHooks()\n  };\n}\nfunction sysHooks() {\n  const Context = GurxContext;\n  const usePublisher = (key) => {\n    const realm = React__default.useContext(Context);\n    return React__default.useCallback(\n      (value) => {\n        realm.pubKey(key, value);\n      },\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      [key, realm]\n    );\n  };\n  const useEmitterValues = (...keys) => {\n    const realm = React__default.useContext(Context);\n    const [values, setValues] = React__default.useState(() => realm.getKeyValues(keys));\n    useEffect(\n      () => realm == null ? void 0 : realm.subKeys(keys, (newValues) => {\n        const setter = () => {\n          if (keys.length === 1) {\n            newValues = [newValues];\n          }\n          for (let i = 0; i < keys.length; i++) {\n            if (newValues[i] !== values[i]) {\n              setValues(newValues);\n            }\n          }\n        };\n        setter();\n      }),\n      [keys, realm, values]\n    );\n    return values;\n  };\n  const usePubKeys = () => {\n    return React__default.useContext(Context).pubKeys;\n  };\n  const useEmitter = (key, callback) => {\n    const realm = React__default.useContext(Context);\n    useIsomorphicLayoutEffect(() => realm.subKey(key, callback), [callback]);\n  };\n  const useRealmContext = () => {\n    return React__default.useContext(Context);\n  };\n  return {\n    useRealmContext,\n    useEmitter,\n    useEmitterValues,\n    usePubKeys,\n    usePublisher\n  };\n}\nconst UsedPluginsContext = React__default.createContext(/* @__PURE__ */ new Set());\nfunction realmPlugin(params) {\n  const plugin = (pluginParams) => {\n    return {\n      systemSpec: params.systemSpec,\n      pluginParams,\n      applyParamsToSystem: params.applyParamsToSystem,\n      init: params.init,\n      id: params.id,\n      dependencies: params.dependencies\n    };\n  };\n  return [plugin, sysHooks()];\n}\nconst RealmPluginInitializer = function({\n  plugins,\n  children\n}) {\n  const validPlugins = React__default.useMemo(() => {\n    const availablePlugins = plugins.map((plugin) => plugin.id);\n    const validPlugins2 = plugins.filter((plugin) => {\n      if (plugin.dependencies) {\n        if (plugin.dependencies.some((dep) => !availablePlugins.includes(dep))) {\n          console.warn(\"MDXEditor plugin\", plugin.id, \"has some missing dependencies\", plugin.dependencies, \", skipping\");\n          return false;\n        }\n      }\n      return true;\n    });\n    return validPlugins2;\n  }, [plugins]);\n  const realm = React__default.useMemo(() => {\n    const specs = validPlugins.map((plugin) => plugin.systemSpec);\n    const pluginIds = validPlugins.map((plugin) => plugin.id);\n    const realm2 = realmFactory(...specs);\n    validPlugins.forEach((plugin) => {\n      var _a, _b;\n      (_a = plugin.init) == null ? void 0 : _a.call(plugin, realm2, plugin.pluginParams, pluginIds);\n      (_b = plugin.applyParamsToSystem) == null ? void 0 : _b.call(plugin, realm2, plugin.pluginParams);\n    });\n    return realm2;\n  }, []);\n  React__default.useEffect(() => {\n    validPlugins.forEach((plugin) => {\n      var _a;\n      (_a = plugin.applyParamsToSystem) == null ? void 0 : _a.call(plugin, realm, plugin.pluginParams);\n    });\n  }, [realm, validPlugins]);\n  const Context = GurxContext;\n  return React__default.createElement(\n    Context.Provider,\n    { value: realm },\n    React__default.createElement(UsedPluginsContext.Provider, { value: new Set(plugins.map((plugin) => plugin.id)) }, children)\n  );\n};\nfunction useHasPlugin(id) {\n  const usedPlugins = React__default.useContext(UsedPluginsContext);\n  return usedPlugins.has(id);\n}\nconst RequirePlugin = ({ id, children }) => {\n  return useHasPlugin(id) ? React__default.createElement(React__default.Fragment, {}, children) : null;\n};\nexport {\n  RealmPluginInitializer,\n  RequirePlugin,\n  realmFactoryToComponent,\n  realmPlugin,\n  sysHooks,\n  useHasPlugin\n};\n", "import { createEmptyHistoryState } from \"@lexical/react/LexicalHistoryPlugin.js\";\nimport { $isHeadingNode } from \"@lexical/rich-text\";\nimport { $setBlocksType } from \"@lexical/selection\";\nimport { $findMatchingParent, $wrapNodeInElement, $insertNodeToNearestRoot } from \"@lexical/utils\";\nimport { createCommand, SELECTION_CHANGE_COMMAND, $getRoot, COMMAND_PRIORITY_CRITICAL, $setSelection, BLUR_COMMAND, KEY_DOWN_COMMAND, $isDecoratorNode, FORMAT_TEXT_COMMAND, $isRootOrShadowRoot, $getSelection, $isRangeSelection, $insertNodes, $createParagraphNode, ParagraphNode, TextNode } from \"lexical\";\nimport { exportMarkdownFromLexical } from \"../../exportMarkdownFromLexical.js\";\nimport { importMarkdownToLexical } from \"../../importMarkdownToLexical.js\";\nimport { LexicalLinebreakVisitor } from \"./LexicalLinebreakVisitor.js\";\nimport { LexicalParagraphVisitor } from \"./LexicalParagraphVisitor.js\";\nimport { LexicalRootVisitor } from \"./LexicalRootVisitor.js\";\nimport { LexicalTextVisitor } from \"./LexicalTextVisitor.js\";\nimport { MdastFormattingVisitor } from \"./MdastFormattingVisitor.js\";\nimport { MdastInlineCodeVisitor } from \"./MdastInlineCodeVisitor.js\";\nimport { MdastParagraphVisitor } from \"./MdastParagraphVisitor.js\";\nimport { MdastRootVisitor } from \"./MdastRootVisitor.js\";\nimport { MdastTextVisitor } from \"./MdastTextVisitor.js\";\nimport { SharedHistoryPlugin } from \"./SharedHistoryPlugin.js\";\nimport { noop } from \"../../utils/fp.js\";\nimport { controlOrMeta } from \"../../utils/detectMac.js\";\nimport { MdastBreakVisitor } from \"./MdastBreakVisitor.js\";\nimport { system } from \"../../gurx/realmFactory.js\";\nimport { realmPlugin } from \"../../gurx/react.js\";\nconst NESTED_EDITOR_UPDATED_COMMAND = createCommand(\"NESTED_EDITOR_UPDATED_COMMAND\");\nconst coreSystem = system((r) => {\n  function createAppendNodeFor(node) {\n    const appendNode = r.node();\n    r.link(\n      r.pipe(\n        appendNode,\n        r.o.withLatestFrom(node),\n        r.o.map(([newValue, values]) => {\n          if (values.includes(newValue)) {\n            return values;\n          }\n          return [...values, newValue];\n        })\n      ),\n      node\n    );\n    return appendNode;\n  }\n  const rootEditor = r.node(null);\n  const activeEditor = r.node(null, true);\n  const contentEditableClassName = r.node(\"\");\n  const readOnly = r.node(false);\n  const placeholder = r.node(\"\");\n  const autoFocus = r.node(false);\n  const inFocus = r.node(false, true);\n  const currentFormat = r.node(0, true);\n  const applyFormat = r.node();\n  const currentSelection = r.node(null);\n  const activeEditorSubscriptions = r.node([]);\n  const rootEditorSubscriptions = r.node([]);\n  const editorInFocus = r.node(null);\n  const onBlur = r.node();\n  const rebind = () => r.o.scan((teardowns, [subs, activeEditorValue]) => {\n    teardowns.forEach((teardown) => {\n      if (!teardown) {\n        throw new Error(\"You have a subscription that does not return a teardown\");\n      }\n      teardown();\n    });\n    return activeEditorValue ? subs.map((s) => s(activeEditorValue)) : [];\n  }, []);\n  r.pipe(r.combine(activeEditorSubscriptions, activeEditor), rebind());\n  r.pipe(r.combine(rootEditorSubscriptions, rootEditor), rebind());\n  const createRootEditorSubscription = createAppendNodeFor(rootEditorSubscriptions);\n  const createActiveEditorSubscription = createAppendNodeFor(activeEditorSubscriptions);\n  function handleSelectionChange() {\n    const selection = $getSelection();\n    if ($isRangeSelection(selection)) {\n      r.pubKeys({\n        currentSelection: selection,\n        currentFormat: selection.format\n      });\n    }\n  }\n  r.pub(createRootEditorSubscription, (theRootEditor) => {\n    return theRootEditor.registerCommand(\n      SELECTION_CHANGE_COMMAND,\n      (_, theActiveEditor) => {\n        r.pubIn({\n          [activeEditor.key]: theActiveEditor,\n          [inFocus.key]: true\n        });\n        if (theActiveEditor._parentEditor === null) {\n          theActiveEditor.getEditorState().read(() => {\n            r.pub(editorInFocus, {\n              rootNode: $getRoot(),\n              editorType: \"lexical\"\n            });\n          });\n        }\n        handleSelectionChange();\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL\n    );\n  });\n  r.pub(createRootEditorSubscription, (theRootEditor) => {\n    return theRootEditor.registerUpdateListener(({ dirtyElements, dirtyLeaves, editorState }) => {\n      if (dirtyElements.size === 0 && dirtyLeaves.size === 0) {\n        return;\n      }\n      let theNewMarkdownValue;\n      editorState.read(() => {\n        theNewMarkdownValue = exportMarkdownFromLexical({\n          root: $getRoot(),\n          visitors: r.getValue(exportVisitors),\n          jsxComponentDescriptors: r.getValue(jsxComponentDescriptors),\n          toMarkdownExtensions: r.getValue(toMarkdownExtensions),\n          toMarkdownOptions: r.getValue(toMarkdownOptions),\n          jsxIsAvailable: r.getValue(jsxIsAvailable)\n        });\n      });\n      r.pub(markdown, theNewMarkdownValue.trim());\n    });\n  });\n  const initialMarkdown = r.node(\"\");\n  const markdown = r.node(\"\", true);\n  r.link(initialMarkdown, markdown);\n  const importVisitors = r.node([]);\n  const syntaxExtensions = r.node([]);\n  const mdastExtensions = r.node([]);\n  const usedLexicalNodes = r.node([]);\n  const exportVisitors = r.node([]);\n  const toMarkdownExtensions = r.node([]);\n  const toMarkdownOptions = r.node({}, true);\n  const jsxIsAvailable = r.node(false);\n  const jsxComponentDescriptors = r.node([]);\n  const editorRootElementRef = r.node(null);\n  const addLexicalNode = createAppendNodeFor(usedLexicalNodes);\n  const addImportVisitor = createAppendNodeFor(importVisitors);\n  const addSyntaxExtension = createAppendNodeFor(syntaxExtensions);\n  const addMdastExtension = createAppendNodeFor(mdastExtensions);\n  const addExportVisitor = createAppendNodeFor(exportVisitors);\n  const addToMarkdownExtension = createAppendNodeFor(toMarkdownExtensions);\n  const setMarkdown = r.node();\n  r.sub(\n    r.pipe(setMarkdown, r.o.withLatestFrom(rootEditor, importVisitors, mdastExtensions, syntaxExtensions, inFocus)),\n    ([theNewMarkdownValue, editor, importVisitors2, mdastExtensions2, syntaxExtensions2, inFocus2]) => {\n      editor == null ? void 0 : editor.update(() => {\n        $getRoot().clear();\n        importMarkdownToLexical({\n          root: $getRoot(),\n          visitors: importVisitors2,\n          mdastExtensions: mdastExtensions2,\n          markdown: theNewMarkdownValue,\n          syntaxExtensions: syntaxExtensions2\n        });\n        if (!inFocus2) {\n          $setSelection(null);\n        }\n      });\n    }\n  );\n  const initialRootEditorState = r.node((theRootEditor) => {\n    r.pub(rootEditor, theRootEditor);\n    r.pub(activeEditor, theRootEditor);\n    importMarkdownToLexical({\n      root: $getRoot(),\n      visitors: r.getValue(importVisitors),\n      mdastExtensions: r.getValue(mdastExtensions),\n      markdown: r.getValue(initialMarkdown),\n      syntaxExtensions: r.getValue(syntaxExtensions)\n    });\n    const autoFocusValue = r.getValue(autoFocus);\n    if (autoFocusValue) {\n      if (autoFocusValue === true) {\n        setTimeout(() => theRootEditor.focus(noop, { defaultSelection: \"rootStart\" }));\n        return;\n      }\n      setTimeout(\n        () => theRootEditor.focus(noop, {\n          defaultSelection: autoFocusValue.defaultSelection ?? \"rootStart\"\n        })\n      );\n    }\n  });\n  r.pub(createActiveEditorSubscription, (editor) => {\n    return editor.registerUpdateListener(({ editorState }) => {\n      editorState.read(() => {\n        handleSelectionChange();\n      });\n    });\n  });\n  r.pub(createActiveEditorSubscription, (theEditor) => {\n    return theEditor.registerCommand(\n      BLUR_COMMAND,\n      (payload) => {\n        var _a;\n        const theRootEditor = r.getValue(rootEditor);\n        if (theRootEditor) {\n          const movingOutside = !((_a = theRootEditor.getRootElement()) == null ? void 0 : _a.contains(payload.relatedTarget));\n          if (movingOutside) {\n            r.pubIn({\n              [inFocus.key]: false,\n              [onBlur.key]: payload\n            });\n          }\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL\n    );\n  });\n  r.pub(createRootEditorSubscription, (theRootEditor) => {\n    return theRootEditor.registerCommand(\n      KEY_DOWN_COMMAND,\n      (event) => {\n        const { keyCode, ctrlKey, metaKey } = event;\n        if (keyCode === 65 && controlOrMeta(metaKey, ctrlKey)) {\n          let shouldOverride = false;\n          theRootEditor.getEditorState().read(() => {\n            shouldOverride = $isDecoratorNode($getRoot().getFirstChild()) || $isDecoratorNode($getRoot().getLastChild());\n          });\n          if (shouldOverride) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            theRootEditor.update(() => {\n              var _a;\n              const rootElement = theRootEditor.getRootElement();\n              (_a = window.getSelection()) == null ? void 0 : _a.selectAllChildren(rootElement);\n              rootElement.focus({\n                preventScroll: true\n              });\n            });\n            return true;\n          }\n        }\n        return false;\n      },\n      COMMAND_PRIORITY_CRITICAL\n    );\n  });\n  const composerChildren = r.node([]);\n  const addComposerChild = createAppendNodeFor(composerChildren);\n  const topAreaChildren = r.node([]);\n  const addTopAreaChild = createAppendNodeFor(topAreaChildren);\n  const editorWrappers = r.node([]);\n  const addEditorWrapper = createAppendNodeFor(editorWrappers);\n  const nestedEditorChildren = r.node([]);\n  const addNestedEditorChild = createAppendNodeFor(nestedEditorChildren);\n  const historyState = r.node(createEmptyHistoryState());\n  r.sub(r.pipe(applyFormat, r.o.withLatestFrom(activeEditor)), ([format, theEditor]) => {\n    theEditor == null ? void 0 : theEditor.dispatchCommand(FORMAT_TEXT_COMMAND, format);\n  });\n  const currentBlockType = r.node(\"\");\n  const applyBlockType = r.node();\n  r.sub(r.pipe(currentSelection, r.o.withLatestFrom(activeEditor)), ([selection, theEditor]) => {\n    if (!selection || !theEditor) {\n      return;\n    }\n    const anchorNode = selection.anchor.getNode();\n    let element = anchorNode.getKey() === \"root\" ? anchorNode : $findMatchingParent(anchorNode, (e) => {\n      const parent = e.getParent();\n      return parent !== null && $isRootOrShadowRoot(parent);\n    });\n    if (element === null) {\n      element = anchorNode.getTopLevelElementOrThrow();\n    }\n    const elementKey = element.getKey();\n    const elementDOM = theEditor.getElementByKey(elementKey);\n    if (elementDOM !== null) {\n      const blockType = $isHeadingNode(element) ? element.getTag() : element.getType();\n      r.pub(currentBlockType, blockType);\n    }\n  });\n  const convertSelectionToNode = r.node();\n  r.sub(r.pipe(convertSelectionToNode, r.o.withLatestFrom(activeEditor)), ([factory, editor]) => {\n    editor == null ? void 0 : editor.update(() => {\n      const selection = $getSelection();\n      if ($isRangeSelection(selection)) {\n        $setBlocksType(selection, factory);\n        setTimeout(() => {\n          editor.focus();\n        });\n      }\n    });\n  });\n  const insertDecoratorNode = r.node();\n  r.sub(r.pipe(insertDecoratorNode, r.o.withLatestFrom(activeEditor)), ([nodeFactory, theEditor]) => {\n    theEditor == null ? void 0 : theEditor.focus(\n      () => {\n        theEditor.getEditorState().read(() => {\n          const selection = $getSelection();\n          if ($isRangeSelection(selection)) {\n            const focusNode = selection.focus.getNode();\n            if (focusNode !== null) {\n              theEditor.update(() => {\n                const node = nodeFactory();\n                if (node.isInline()) {\n                  $insertNodes([node]);\n                  if ($isRootOrShadowRoot(node.getParentOrThrow())) {\n                    $wrapNodeInElement(node, $createParagraphNode).selectEnd();\n                  }\n                } else {\n                  $insertNodeToNearestRoot(node);\n                }\n                if (Object.hasOwn(node, \"select\") && typeof node.select === \"function\") {\n                  setTimeout(() => node.select());\n                }\n              });\n            }\n          }\n        });\n      },\n      { defaultSelection: \"rootEnd\" }\n    );\n  });\n  r.sub(r.pipe(readOnly, r.o.withLatestFrom(rootEditor)), ([readOnly2, theRootEditor]) => {\n    theRootEditor == null ? void 0 : theRootEditor.setEditable(!readOnly2);\n  });\n  return {\n    // state\n    activeEditor,\n    inFocus,\n    historyState,\n    currentSelection,\n    // jsx\n    jsxIsAvailable,\n    jsxComponentDescriptors,\n    // lexical editor\n    initialRootEditorState,\n    rootEditor,\n    createRootEditorSubscription,\n    createActiveEditorSubscription,\n    // import\n    importVisitors,\n    syntaxExtensions,\n    mdastExtensions,\n    usedLexicalNodes,\n    addImportVisitor,\n    addLexicalNode,\n    addSyntaxExtension,\n    addMdastExtension,\n    // export\n    toMarkdownExtensions,\n    toMarkdownOptions,\n    addToMarkdownExtension,\n    addExportVisitor,\n    exportVisitors,\n    // markdown strings\n    initialMarkdown,\n    setMarkdown,\n    markdown,\n    // DOM\n    editorRootElementRef,\n    contentEditableClassName,\n    placeholder,\n    autoFocus,\n    readOnly,\n    // child controls\n    composerChildren,\n    addComposerChild,\n    topAreaChildren,\n    addTopAreaChild,\n    nestedEditorChildren,\n    addNestedEditorChild,\n    editorWrappers,\n    addEditorWrapper,\n    // editor content state and commands\n    currentFormat,\n    editorInFocus,\n    applyFormat,\n    currentBlockType,\n    applyBlockType,\n    convertSelectionToNode,\n    insertDecoratorNode,\n    // Events\n    onBlur\n  };\n}, []);\nconst [\n  /** @internal */\n  corePlugin,\n  /** @internal */\n  corePluginHooks\n] = realmPlugin({\n  id: \"core\",\n  systemSpec: coreSystem,\n  applyParamsToSystem(realm, params) {\n    realm.pubKeys({\n      contentEditableClassName: params.contentEditableClassName,\n      toMarkdownOptions: params.toMarkdownOptions,\n      autoFocus: params.autoFocus,\n      placeholder: params.placeholder,\n      readOnly: params.readOnly\n    });\n    realm.singletonSubKey(\"markdown\", params.onChange);\n    realm.singletonSubKey(\"onBlur\", params.onBlur);\n  },\n  init(realm, params) {\n    realm.pubKey(\"initialMarkdown\", params.initialMarkdown.trim());\n    realm.pubKey(\"addImportVisitor\", MdastRootVisitor);\n    realm.pubKey(\"addImportVisitor\", MdastParagraphVisitor);\n    realm.pubKey(\"addImportVisitor\", MdastTextVisitor);\n    realm.pubKey(\"addImportVisitor\", MdastFormattingVisitor);\n    realm.pubKey(\"addImportVisitor\", MdastInlineCodeVisitor);\n    realm.pubKey(\"addImportVisitor\", MdastBreakVisitor);\n    realm.pubKey(\"addLexicalNode\", ParagraphNode);\n    realm.pubKey(\"addLexicalNode\", TextNode);\n    realm.pubKey(\"addExportVisitor\", LexicalRootVisitor);\n    realm.pubKey(\"addExportVisitor\", LexicalParagraphVisitor);\n    realm.pubKey(\"addExportVisitor\", LexicalTextVisitor);\n    realm.pubKey(\"addExportVisitor\", LexicalLinebreakVisitor);\n    realm.pubKey(\"addComposerChild\", SharedHistoryPlugin);\n  }\n});\nexport {\n  NESTED_EDITOR_UPDATED_COMMAND,\n  corePlugin,\n  corePluginHooks,\n  coreSystem\n};\n", "import { $isElementNode } from \"lexical\";\nimport { toMarkdown } from \"mdast-util-to-markdown\";\nfunction isParent(node) {\n  return node.children instanceof Array;\n}\nfunction exportLexicalTreeToMdast({\n  root,\n  visitors,\n  jsxComponentDescriptors,\n  jsxIsAvailable\n}) {\n  let unistRoot = null;\n  const referredComponents = /* @__PURE__ */ new Set();\n  visit(root, null);\n  function registerReferredComponent(componentName) {\n    referredComponents.add(componentName);\n  }\n  function appendToParent(parentNode, node) {\n    if (unistRoot === null) {\n      unistRoot = node;\n      return unistRoot;\n    }\n    if (!isParent(parentNode)) {\n      throw new Error(\"Attempting to append children to a non-parent\");\n    }\n    const siblings = parentNode.children;\n    const prevSibling = siblings.at(-1);\n    if (prevSibling) {\n      const joinVisitor = visitors.find((visitor) => {\n        var _a;\n        return (_a = visitor.shouldJoin) == null ? void 0 : _a.call(visitor, prevSibling, node);\n      });\n      if (joinVisitor) {\n        const joinedNode = joinVisitor.join(prevSibling, node);\n        siblings.splice(siblings.length - 1, 1, joinedNode);\n        return joinedNode;\n      }\n    }\n    siblings.push(node);\n    return node;\n  }\n  function visitChildren(lexicalNode, parentNode) {\n    lexicalNode.getChildren().forEach((lexicalChild) => {\n      visit(lexicalChild, parentNode);\n    });\n  }\n  function visit(lexicalNode, mdastParent) {\n    var _a;\n    const visitor = visitors.find((visitor2) => {\n      var _a2;\n      return (_a2 = visitor2.testLexicalNode) == null ? void 0 : _a2.call(visitor2, lexicalNode);\n    });\n    if (!visitor) {\n      throw new Error(`no lexical visitor found for ${lexicalNode.getType()}`, {\n        cause: lexicalNode\n      });\n    }\n    (_a = visitor.visitLexicalNode) == null ? void 0 : _a.call(visitor, {\n      lexicalNode,\n      mdastParent,\n      actions: {\n        addAndStepInto(type, props = {}, hasChildren = true) {\n          const newNode = {\n            type,\n            ...props,\n            ...hasChildren ? { children: [] } : {}\n          };\n          appendToParent(mdastParent, newNode);\n          if ($isElementNode(lexicalNode) && hasChildren) {\n            visitChildren(lexicalNode, newNode);\n          }\n        },\n        appendToParent,\n        visitChildren,\n        registerReferredComponent\n      }\n    });\n  }\n  if (unistRoot === null) {\n    throw new Error(\"traversal ended with no root element\");\n  }\n  const importsMap = /* @__PURE__ */ new Map();\n  const defaultImportsMap = /* @__PURE__ */ new Map();\n  for (const componentName of referredComponents) {\n    const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === componentName);\n    if (!descriptor) {\n      throw new Error(`Component ${componentName} is used but not imported`);\n    }\n    if (!descriptor.source) {\n      continue;\n    }\n    if (descriptor.defaultExport) {\n      defaultImportsMap.set(componentName, descriptor.source);\n    } else {\n      const { source } = descriptor;\n      const existing = importsMap.get(source);\n      if (existing) {\n        existing.push(componentName);\n      } else {\n        importsMap.set(source, [componentName]);\n      }\n    }\n  }\n  const imports = Array.from(importsMap).map(([source, componentNames]) => {\n    return {\n      type: \"mdxjsEsm\",\n      value: `import { ${componentNames.join(\", \")} } from '${source}'`\n    };\n  });\n  imports.push(\n    ...Array.from(defaultImportsMap).map(([componentName, source]) => {\n      return {\n        type: \"mdxjsEsm\",\n        value: `import ${componentName} from '${source}'`\n      };\n    })\n  );\n  const typedRoot = unistRoot;\n  const frontmatter = typedRoot.children.find((child) => child.type === \"yaml\");\n  if (frontmatter) {\n    typedRoot.children.splice(typedRoot.children.indexOf(frontmatter) + 1, 0, ...imports);\n  } else {\n    typedRoot.children.unshift(...imports);\n  }\n  fixWrappingWhitespace(typedRoot, []);\n  if (!jsxIsAvailable) {\n    convertUnderlineJsxToHtml(typedRoot);\n  }\n  return typedRoot;\n}\nfunction convertUnderlineJsxToHtml(node) {\n  if (Object.hasOwn(node, \"children\")) {\n    const nodeAsParent = node;\n    const newChildren = [];\n    nodeAsParent.children.forEach((child) => {\n      if (child.type === \"mdxJsxTextElement\" && child.name === \"u\") {\n        newChildren.push(...[{ type: \"html\", value: \"<u>\" }, ...child.children, { type: \"html\", value: \"</u>\" }]);\n      } else {\n        newChildren.push(child);\n        convertUnderlineJsxToHtml(child);\n      }\n    });\n    nodeAsParent.children = newChildren;\n  }\n}\nconst TRAILING_WHITESPACE_REGEXP = /\\s+$/;\nconst LEADING_WHITESPACE_REGEXP = /^\\s+/;\nfunction fixWrappingWhitespace(node, parentChain) {\n  if (node.type === \"strong\" || node.type === \"emphasis\") {\n    const lastChild = node.children.at(-1);\n    if ((lastChild == null ? void 0 : lastChild.type) === \"text\") {\n      const trailingWhitespace = lastChild.value.match(TRAILING_WHITESPACE_REGEXP);\n      if (trailingWhitespace) {\n        lastChild.value = lastChild.value.replace(TRAILING_WHITESPACE_REGEXP, \"\");\n        const parent = parentChain.at(-1);\n        if (parent) {\n          parent.children.splice(parent.children.indexOf(node) + 1, 0, {\n            type: \"text\",\n            value: trailingWhitespace[0]\n          });\n          fixWrappingWhitespace(parent, parentChain.slice(0, -1));\n        }\n      }\n    }\n    const firstChild = node.children.at(0);\n    if ((firstChild == null ? void 0 : firstChild.type) === \"text\") {\n      const leadingWhitespace = firstChild.value.match(LEADING_WHITESPACE_REGEXP);\n      if (leadingWhitespace) {\n        firstChild.value = firstChild.value.replace(LEADING_WHITESPACE_REGEXP, \"\");\n        const parent = parentChain.at(-1);\n        if (parent) {\n          parent.children.splice(parent.children.indexOf(node), 0, {\n            type: \"text\",\n            value: leadingWhitespace[0]\n          });\n          fixWrappingWhitespace(parent, parentChain.slice(0, -1));\n        }\n      }\n    }\n  }\n  if (Object.hasOwn(node, \"children\")) {\n    const nodeAsParent = node;\n    nodeAsParent.children.forEach((child) => fixWrappingWhitespace(child, [...parentChain, nodeAsParent]));\n  }\n}\nfunction exportMarkdownFromLexical({\n  root,\n  toMarkdownOptions,\n  toMarkdownExtensions,\n  visitors,\n  jsxComponentDescriptors,\n  jsxIsAvailable\n}) {\n  return toMarkdown(exportLexicalTreeToMdast({ root, visitors, jsxComponentDescriptors, jsxIsAvailable }), {\n    extensions: toMarkdownExtensions,\n    ...toMarkdownOptions\n  });\n}\nexport {\n  exportLexicalTreeToMdast,\n  exportMarkdownFromLexical\n};\n", "/**\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').State} State\n */\n\n/**\n * @param {State} base\n * @param {Options} extension\n * @returns {State}\n */\nexport function configure(base, extension) {\n  let index = -1\n  /** @type {keyof Options} */\n  let key\n\n  // First do subextensions.\n  if (extension.extensions) {\n    while (++index < extension.extensions.length) {\n      configure(base, extension.extensions[index])\n    }\n  }\n\n  for (key in extension) {\n    if (key === 'extensions') {\n      // Empty.\n    } else if (key === 'unsafe' || key === 'join') {\n      /* c8 ignore next 2 */\n      // @ts-expect-error: hush.\n      base[key] = [...(base[key] || []), ...(extension[key] || [])]\n    } else if (key === 'handlers') {\n      base[key] = Object.assign(base[key], extension[key] || {})\n    } else {\n      // @ts-expect-error: hush.\n      base.options[key] = extension[key]\n    }\n  }\n\n  return base\n}\n", "/**\n * @typedef {import('mdast').Blockquote} Blockquote\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\n/**\n * @param {Blockquote} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function blockquote(node, _, state, info) {\n  const exit = state.enter('blockquote')\n  const tracker = state.createTracker(info)\n  tracker.move('> ')\n  tracker.shift(2)\n  const value = state.indentLines(\n    state.containerFlow(node, tracker.current()),\n    map\n  )\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return '>' + (blank ? '' : ' ') + line\n}\n", "/**\n * @typedef {import('mdast').Break} Break\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {patternInScope} from '../util/pattern-in-scope.js'\n\n/**\n * @param {Break} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function hardBreak(_, _1, state, info) {\n  let index = -1\n\n  while (++index < state.unsafe.length) {\n    // If we can’t put eols in this construct (setext headings, tables), use a\n    // space instead.\n    if (\n      state.unsafe[index].character === '\\n' &&\n      patternInScope(state.stack, state.unsafe[index])\n    ) {\n      return /[ \\t]/.test(info.before) ? '' : ' '\n    }\n  }\n\n  return '\\\\\\n'\n}\n", "/**\n * Get the count of the longest repeating streak of `substring` in `value`.\n *\n * @param {string} value\n *   Content to search in.\n * @param {string} substring\n *   Substring to look for, typically one character.\n * @returns {number}\n *   Count of most frequent adjacent `substring`s in `value`.\n */\nexport function longestStreak(value, substring) {\n  const source = String(value)\n  let index = source.indexOf(substring)\n  let expected = index\n  let count = 0\n  let max = 0\n\n  if (typeof substring !== 'string') {\n    throw new TypeError('Expected substring')\n  }\n\n  while (index !== -1) {\n    if (index === expected) {\n      if (++count > max) {\n        max = count\n      }\n    } else {\n      count = 1\n    }\n\n    expected = index + substring.length\n    index = source.indexOf(substring, expected)\n  }\n\n  return max\n}\n", "/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').State} State\n */\n\n/**\n * @param {Code} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatCodeAsIndented(node, state) {\n  return Boolean(\n    !state.options.fences &&\n      node.value &&\n      // If there’s no info…\n      !node.lang &&\n      // And there’s a non-whitespace character…\n      /[^ \\r\\n]/.test(node.value) &&\n      // And the value doesn’t start or end in a blank…\n      !/^[\\t ]*(?:[\\r\\n]|$)|(?:^|[\\r\\n])[\\t ]*$/.test(node.value)\n  )\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['fence'], null | undefined>}\n */\nexport function checkFence(state) {\n  const marker = state.options.fence || '`'\n\n  if (marker !== '`' && marker !== '~') {\n    throw new Error(\n      'Cannot serialize code with `' +\n        marker +\n        '` for `options.fence`, expected `` ` `` or `~`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Code} Code\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Map} Map\n */\n\nimport {longestStreak} from 'longest-streak'\nimport {formatCodeAsIndented} from '../util/format-code-as-indented.js'\nimport {checkFence} from '../util/check-fence.js'\n\n/**\n * @param {Code} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function code(node, _, state, info) {\n  const marker = checkFence(state)\n  const raw = node.value || ''\n  const suffix = marker === '`' ? 'GraveAccent' : 'Tilde'\n\n  if (formatCodeAsIndented(node, state)) {\n    const exit = state.enter('codeIndented')\n    const value = state.indentLines(raw, map)\n    exit()\n    return value\n  }\n\n  const tracker = state.createTracker(info)\n  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3))\n  const exit = state.enter('codeFenced')\n  let value = tracker.move(sequence)\n\n  if (node.lang) {\n    const subexit = state.enter(`codeFencedLang${suffix}`)\n    value += tracker.move(\n      state.safe(node.lang, {\n        before: value,\n        after: ' ',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  if (node.lang && node.meta) {\n    const subexit = state.enter(`codeFencedMeta${suffix}`)\n    value += tracker.move(' ')\n    value += tracker.move(\n      state.safe(node.meta, {\n        before: value,\n        after: '\\n',\n        encode: ['`'],\n        ...tracker.current()\n      })\n    )\n    subexit()\n  }\n\n  value += tracker.move('\\n')\n\n  if (raw) {\n    value += tracker.move(raw + '\\n')\n  }\n\n  value += tracker.move(sequence)\n  exit()\n  return value\n}\n\n/** @type {Map} */\nfunction map(line, _, blank) {\n  return (blank ? '' : '    ') + line\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['quote'], null | undefined>}\n */\nexport function checkQuote(state) {\n  const marker = state.options.quote || '\"'\n\n  if (marker !== '\"' && marker !== \"'\") {\n    throw new Error(\n      'Cannot serialize title with `' +\n        marker +\n        '` for `options.quote`, expected `\"`, or `\\'`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Definition} Definition\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\n/**\n * @param {Definition} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function definition(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('definition')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.safe(state.associationId(node), {\n      before: value,\n      after: ']',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(']: ')\n\n  subexit()\n\n  if (\n    // If there’s no url, or…\n    !node.url ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : '\\n',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  exit()\n\n  return value\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['emphasis'], null | undefined>}\n */\nexport function checkEmphasis(state) {\n  const marker = state.options.emphasis || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize emphasis with `' +\n        marker +\n        '` for `options.emphasis`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Emphasis} Emphasis\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkEmphasis} from '../util/check-emphasis.js'\n\nemphasis.peek = emphasisPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Emphasis} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function emphasis(node, _, state, info) {\n  const marker = checkEmphasis(state)\n  const exit = state.enter('emphasis')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Emphasis} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction emphasisPeek(_, _1, state) {\n  return state.options.emphasis || '*'\n}\n", "/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').State} State\n */\n\nimport {visit, EXIT} from 'unist-util-visit'\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Heading} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatHeadingAsSetext(node, state) {\n  let literalWithBreak = false\n\n  // Look for literals with a line break.\n  // Note that this also\n  visit(node, (node) => {\n    if (\n      ('value' in node && /\\r?\\n|\\r/.test(node.value)) ||\n      node.type === 'break'\n    ) {\n      literalWithBreak = true\n      return EXIT\n    }\n  })\n\n  return Boolean(\n    (!node.depth || node.depth < 3) &&\n      toString(node) &&\n      (state.options.setext || literalWithBreak)\n  )\n}\n", "/**\n * @typedef {import('mdast').Heading} Heading\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {formatHeadingAsSetext} from '../util/format-heading-as-setext.js'\n\n/**\n * @param {Heading} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function heading(node, _, state, info) {\n  const rank = Math.max(Math.min(6, node.depth || 1), 1)\n  const tracker = state.createTracker(info)\n\n  if (formatHeadingAsSetext(node, state)) {\n    const exit = state.enter('headingSetext')\n    const subexit = state.enter('phrasing')\n    const value = state.containerPhrasing(node, {\n      ...tracker.current(),\n      before: '\\n',\n      after: '\\n'\n    })\n    subexit()\n    exit()\n\n    return (\n      value +\n      '\\n' +\n      (rank === 1 ? '=' : '-').repeat(\n        // The whole size…\n        value.length -\n          // Minus the position of the character after the last EOL (or\n          // 0 if there is none)…\n          (Math.max(value.lastIndexOf('\\r'), value.lastIndexOf('\\n')) + 1)\n      )\n    )\n  }\n\n  const sequence = '#'.repeat(rank)\n  const exit = state.enter('headingAtx')\n  const subexit = state.enter('phrasing')\n\n  // Note: for proper tracking, we should reset the output positions when there\n  // is no content returned, because then the space is not output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  tracker.move(sequence + ' ')\n\n  let value = state.containerPhrasing(node, {\n    before: '# ',\n    after: '\\n',\n    ...tracker.current()\n  })\n\n  if (/^[\\t ]/.test(value)) {\n    // To do: what effect has the character reference on tracking?\n    value =\n      '&#x' +\n      value.charCodeAt(0).toString(16).toUpperCase() +\n      ';' +\n      value.slice(1)\n  }\n\n  value = value ? sequence + ' ' + value : sequence\n\n  if (state.options.closeAtx) {\n    value += ' ' + sequence\n  }\n\n  subexit()\n  exit()\n\n  return value\n}\n", "/**\n * @typedef {import('mdast').HTML} HTML\n */\n\nhtml.peek = htmlPeek\n\n/**\n * @param {HTML} node\n * @returns {string}\n */\nexport function html(node) {\n  return node.value || ''\n}\n\n/**\n * @returns {string}\n */\nfunction htmlPeek() {\n  return '<'\n}\n", "/**\n * @typedef {import('mdast').Image} Image\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkQuote} from '../util/check-quote.js'\n\nimage.peek = imagePeek\n\n/**\n * @param {Image} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function image(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const exit = state.enter('image')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  value += tracker.move(\n    state.safe(node.alt, {before: value, after: ']', ...tracker.current()})\n  )\n  value += tracker.move('](')\n\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n  exit()\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imagePeek() {\n  return '!'\n}\n", "/**\n * @typedef {import('mdast').ImageReference} ImageReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimageReference.peek = imageReferencePeek\n\n/**\n * @param {ImageReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function imageReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('imageReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('![')\n  const alt = state.safe(node.alt, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(alt + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !alt || alt !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction imageReferencePeek() {\n  return '!'\n}\n", "/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').State} State\n */\n\nimport {toString} from 'mdast-util-to-string'\n\n/**\n * @param {Link} node\n * @param {State} state\n * @returns {boolean}\n */\nexport function formatLinkAsAutolink(node, state) {\n  const raw = toString(node)\n\n  return Boolean(\n    !state.options.resourceLink &&\n      // If there’s a url…\n      node.url &&\n      // And there’s a no title…\n      !node.title &&\n      // And the content of `node` is a single text node…\n      node.children &&\n      node.children.length === 1 &&\n      node.children[0].type === 'text' &&\n      // And if the url is the same as the content…\n      (raw === node.url || 'mailto:' + raw === node.url) &&\n      // And that starts w/ a protocol…\n      /^[a-z][a-z+.-]+:/i.test(node.url) &&\n      // And that doesn’t contain ASCII control codes (character escapes and\n      // references don’t work), space, or angle brackets…\n      !/[\\0- <>\\u007F]/.test(node.url)\n  )\n}\n", "/**\n * @typedef {import('mdast').Link} Link\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n * @typedef {import('../types.js').Exit} Exit\n */\n\nimport {checkQuote} from '../util/check-quote.js'\nimport {formatLinkAsAutolink} from '../util/format-link-as-autolink.js'\n\nlink.peek = linkPeek\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function link(node, _, state, info) {\n  const quote = checkQuote(state)\n  const suffix = quote === '\"' ? 'Quote' : 'Apostrophe'\n  const tracker = state.createTracker(info)\n  /** @type {Exit} */\n  let exit\n  /** @type {Exit} */\n  let subexit\n\n  if (formatLinkAsAutolink(node, state)) {\n    // Hide the fact that we’re in phrasing, because escapes don’t work.\n    const stack = state.stack\n    state.stack = []\n    exit = state.enter('autolink')\n    let value = tracker.move('<')\n    value += tracker.move(\n      state.containerPhrasing(node, {\n        before: value,\n        after: '>',\n        ...tracker.current()\n      })\n    )\n    value += tracker.move('>')\n    exit()\n    state.stack = stack\n    return value\n  }\n\n  exit = state.enter('link')\n  subexit = state.enter('label')\n  let value = tracker.move('[')\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: '](',\n      ...tracker.current()\n    })\n  )\n  value += tracker.move('](')\n  subexit()\n\n  if (\n    // If there’s no url but there is a title…\n    (!node.url && node.title) ||\n    // If there are control characters or whitespace.\n    /[\\0- \\u007F]/.test(node.url)\n  ) {\n    subexit = state.enter('destinationLiteral')\n    value += tracker.move('<')\n    value += tracker.move(\n      state.safe(node.url, {before: value, after: '>', ...tracker.current()})\n    )\n    value += tracker.move('>')\n  } else {\n    // No whitespace, raw is prettier.\n    subexit = state.enter('destinationRaw')\n    value += tracker.move(\n      state.safe(node.url, {\n        before: value,\n        after: node.title ? ' ' : ')',\n        ...tracker.current()\n      })\n    )\n  }\n\n  subexit()\n\n  if (node.title) {\n    subexit = state.enter(`title${suffix}`)\n    value += tracker.move(' ' + quote)\n    value += tracker.move(\n      state.safe(node.title, {\n        before: value,\n        after: quote,\n        ...tracker.current()\n      })\n    )\n    value += tracker.move(quote)\n    subexit()\n  }\n\n  value += tracker.move(')')\n\n  exit()\n  return value\n}\n\n/**\n * @param {Link} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @returns {string}\n */\nfunction linkPeek(node, _, state) {\n  return formatLinkAsAutolink(node, state) ? '<' : '['\n}\n", "/**\n * @typedef {import('mdast').LinkReference} LinkReference\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nlinkReference.peek = linkReferencePeek\n\n/**\n * @param {LinkReference} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function linkReference(node, _, state, info) {\n  const type = node.referenceType\n  const exit = state.enter('linkReference')\n  let subexit = state.enter('label')\n  const tracker = state.createTracker(info)\n  let value = tracker.move('[')\n  const text = state.containerPhrasing(node, {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  value += tracker.move(text + '][')\n\n  subexit()\n  // Hide the fact that we’re in phrasing, because escapes don’t work.\n  const stack = state.stack\n  state.stack = []\n  subexit = state.enter('reference')\n  // Note: for proper tracking, we should reset the output positions when we end\n  // up making a `shortcut` reference, because then there is no brace output.\n  // Practically, in that case, there is no content, so it doesn’t matter that\n  // we’ve tracked one too many characters.\n  const reference = state.safe(state.associationId(node), {\n    before: value,\n    after: ']',\n    ...tracker.current()\n  })\n  subexit()\n  state.stack = stack\n  exit()\n\n  if (type === 'full' || !text || text !== reference) {\n    value += tracker.move(reference + ']')\n  } else if (type === 'shortcut') {\n    // Remove the unwanted `[`.\n    value = value.slice(0, -1)\n  } else {\n    value += tracker.move(']')\n  }\n\n  return value\n}\n\n/**\n * @returns {string}\n */\nfunction linkReferencePeek() {\n  return '['\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBullet} from './check-bullet.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bullet'], null | undefined>}\n */\nexport function checkBulletOther(state) {\n  const bullet = checkBullet(state)\n  const bulletOther = state.options.bulletOther\n\n  if (!bulletOther) {\n    return bullet === '*' ? '-' : '*'\n  }\n\n  if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOther +\n        '` for `options.bulletOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOther === bullet) {\n    throw new Error(\n      'Expected `bullet` (`' +\n        bullet +\n        '`) and `bulletOther` (`' +\n        bulletOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOther\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrdered(state) {\n  const marker = state.options.bulletOrdered || '.'\n\n  if (marker !== '.' && marker !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        marker +\n        '` for `options.bulletOrdered`, expected `.` or `)`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\nimport {checkBulletOrdered} from './check-bullet-ordered.js'\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['bulletOrdered'], null | undefined>}\n */\nexport function checkBulletOrderedOther(state) {\n  const bulletOrdered = checkBulletOrdered(state)\n  const bulletOrderedOther = state.options.bulletOrderedOther\n\n  if (!bulletOrderedOther) {\n    return bulletOrdered === '.' ? ')' : '.'\n  }\n\n  if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {\n    throw new Error(\n      'Cannot serialize items with `' +\n        bulletOrderedOther +\n        '` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'\n    )\n  }\n\n  if (bulletOrderedOther === bulletOrdered) {\n    throw new Error(\n      'Expected `bulletOrdered` (`' +\n        bulletOrdered +\n        '`) and `bulletOrderedOther` (`' +\n        bulletOrderedOther +\n        '`) to be different'\n    )\n  }\n\n  return bulletOrderedOther\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['rule'], null | undefined>}\n */\nexport function checkRule(state) {\n  const marker = state.options.rule || '*'\n\n  if (marker !== '*' && marker !== '-' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize rules with `' +\n        marker +\n        '` for `options.rule`, expected `*`, `-`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').List} List\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkBullet} from '../util/check-bullet.js'\nimport {checkBulletOther} from '../util/check-bullet-other.js'\nimport {checkBulletOrdered} from '../util/check-bullet-ordered.js'\nimport {checkBulletOrderedOther} from '../util/check-bullet-ordered-other.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {List} node\n * @param {Parent | undefined} parent\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function list(node, parent, state, info) {\n  const exit = state.enter('list')\n  const bulletCurrent = state.bulletCurrent\n  /** @type {string} */\n  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state)\n  /** @type {string} */\n  const bulletOther = node.ordered\n    ? checkBulletOrderedOther(state)\n    : checkBulletOther(state)\n  const bulletLastUsed = state.bulletLastUsed\n  let useDifferentMarker = false\n\n  if (\n    parent &&\n    // Explicit `other` set.\n    (node.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther) &&\n    bulletLastUsed &&\n    bullet === bulletLastUsed\n  ) {\n    useDifferentMarker = true\n  }\n\n  if (!node.ordered) {\n    const firstListItem = node.children ? node.children[0] : undefined\n\n    // If there’s an empty first list item directly in two list items,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * - *\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (\n      // Bullet could be used as a thematic break marker:\n      (bullet === '*' || bullet === '-') &&\n      // Empty first list item:\n      firstListItem &&\n      (!firstListItem.children || !firstListItem.children[0]) &&\n      // Directly in two other list items:\n      state.stack[state.stack.length - 1] === 'list' &&\n      state.stack[state.stack.length - 2] === 'listItem' &&\n      state.stack[state.stack.length - 3] === 'list' &&\n      state.stack[state.stack.length - 4] === 'listItem' &&\n      // That are each the first child.\n      state.indexStack[state.indexStack.length - 1] === 0 &&\n      state.indexStack[state.indexStack.length - 2] === 0 &&\n      state.indexStack[state.indexStack.length - 3] === 0\n    ) {\n      useDifferentMarker = true\n    }\n\n    // If there’s a thematic break at the start of the first list item,\n    // we have to use a different bullet:\n    //\n    // ```markdown\n    // * ---\n    // ```\n    //\n    // …because otherwise it would become one big thematic break.\n    if (checkRule(state) === bullet && firstListItem) {\n      let index = -1\n\n      while (++index < node.children.length) {\n        const item = node.children[index]\n\n        if (\n          item &&\n          item.type === 'listItem' &&\n          item.children &&\n          item.children[0] &&\n          item.children[0].type === 'thematicBreak'\n        ) {\n          useDifferentMarker = true\n          break\n        }\n      }\n    }\n  }\n\n  if (useDifferentMarker) {\n    bullet = bulletOther\n  }\n\n  state.bulletCurrent = bullet\n  const value = state.containerFlow(node, info)\n  state.bulletLastUsed = bullet\n  state.bulletCurrent = bulletCurrent\n  exit()\n  return value\n}\n", "/**\n * @typedef {import('mdast').Paragraph} Paragraph\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Paragraph} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function paragraph(node, _, state, info) {\n  const exit = state.enter('paragraph')\n  const subexit = state.enter('phrasing')\n  const value = state.containerPhrasing(node, info)\n  subexit()\n  exit()\n  return value\n}\n", "/**\n * @typedef {import('mdast').PhrasingContent} PhrasingContent\n * @typedef {import('unist-util-is').AssertPredicate<PhrasingContent>} AssertPredicatePhrasing\n */\n\nimport {convert} from 'unist-util-is'\n\n/**\n * Check if the given value is *phrasing content*.\n *\n * @param\n *   Thing to check, typically `Node`.\n * @returns\n *   Whether `value` is phrasing content.\n */\nexport const phrasing = /** @type {AssertPredicatePhrasing} */ (\n  convert([\n    'break',\n    'delete',\n    'emphasis',\n    'footnote',\n    'footnoteReference',\n    'image',\n    'imageReference',\n    'inlineCode',\n    'link',\n    'linkReference',\n    'strong',\n    'text'\n  ])\n)\n", "/**\n * @typedef {import('mdast').Root} Root\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {phrasing} from 'mdast-util-phrasing'\n\n/**\n * @param {Root} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function root(node, _, state, info) {\n  // Note: `html` nodes are ambiguous.\n  const hasPhrasing = node.children.some((d) => phrasing(d))\n  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow\n  // @ts-expect-error: `root`s are supposed to have one type of content\n  return fn.call(state, node, info)\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['strong'], null | undefined>}\n */\nexport function checkStrong(state) {\n  const marker = state.options.strong || '*'\n\n  if (marker !== '*' && marker !== '_') {\n    throw new Error(\n      'Cannot serialize strong with `' +\n        marker +\n        '` for `options.strong`, expected `*`, or `_`'\n    )\n  }\n\n  return marker\n}\n", "/**\n * @typedef {import('mdast').Strong} Strong\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\nimport {checkStrong} from '../util/check-strong.js'\n\nstrong.peek = strongPeek\n\n// To do: there are cases where emphasis cannot “form” depending on the\n// previous or next character of sequences.\n// There’s no way around that though, except for injecting zero-width stuff.\n// Do we need to safeguard against that?\n/**\n * @param {Strong} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function strong(node, _, state, info) {\n  const marker = checkStrong(state)\n  const exit = state.enter('strong')\n  const tracker = state.createTracker(info)\n  let value = tracker.move(marker + marker)\n  value += tracker.move(\n    state.containerPhrasing(node, {\n      before: value,\n      after: marker,\n      ...tracker.current()\n    })\n  )\n  value += tracker.move(marker + marker)\n  exit()\n  return value\n}\n\n/**\n * @param {Strong} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nfunction strongPeek(_, _1, state) {\n  return state.options.strong || '*'\n}\n", "/**\n * @typedef {import('mdast').Text} Text\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Info} Info\n */\n\n/**\n * @param {Text} node\n * @param {Parent | undefined} _\n * @param {State} state\n * @param {Info} info\n * @returns {string}\n */\nexport function text(node, _, state, info) {\n  return state.safe(node.value, info)\n}\n", "/**\n * @typedef {import('../types.js').State} State\n * @typedef {import('../types.js').Options} Options\n */\n\n/**\n * @param {State} state\n * @returns {Exclude<Options['ruleRepetition'], null | undefined>}\n */\nexport function checkRuleRepetition(state) {\n  const repetition = state.options.ruleRepetition || 3\n\n  if (repetition < 3) {\n    throw new Error(\n      'Cannot serialize rules with repetition `' +\n        repetition +\n        '` for `options.ruleRepetition`, expected `3` or more'\n    )\n  }\n\n  return repetition\n}\n", "/**\n * @typedef {import('mdast').ThematicBreak} ThematicBreak\n * @typedef {import('../types.js').Parent} Parent\n * @typedef {import('../types.js').State} State\n */\n\nimport {checkRuleRepetition} from '../util/check-rule-repetition.js'\nimport {checkRule} from '../util/check-rule.js'\n\n/**\n * @param {ThematicBreak} _\n * @param {Parent | undefined} _1\n * @param {State} state\n * @returns {string}\n */\nexport function thematicBreak(_, _1, state) {\n  const value = (\n    checkRule(state) + (state.options.ruleSpaces ? ' ' : '')\n  ).repeat(checkRuleRepetition(state))\n\n  return state.options.ruleSpaces ? value.slice(0, -1) : value\n}\n", "import {blockquote} from './blockquote.js'\nimport {hardBreak} from './break.js'\nimport {code} from './code.js'\nimport {definition} from './definition.js'\nimport {emphasis} from './emphasis.js'\nimport {heading} from './heading.js'\nimport {html} from './html.js'\nimport {image} from './image.js'\nimport {imageReference} from './image-reference.js'\nimport {inlineCode} from './inline-code.js'\nimport {link} from './link.js'\nimport {linkReference} from './link-reference.js'\nimport {list} from './list.js'\nimport {listItem} from './list-item.js'\nimport {paragraph} from './paragraph.js'\nimport {root} from './root.js'\nimport {strong} from './strong.js'\nimport {text} from './text.js'\nimport {thematicBreak} from './thematic-break.js'\n\n/**\n * Default (CommonMark) handlers.\n */\nexport const handle = {\n  blockquote,\n  break: hardBreak,\n  code,\n  definition,\n  emphasis,\n  hardBreak,\n  heading,\n  html,\n  image,\n  imageReference,\n  inlineCode,\n  link,\n  linkReference,\n  list,\n  listItem,\n  paragraph,\n  root,\n  strong,\n  text,\n  thematicBreak\n}\n", "/**\n * @typedef {import('./types.js').Join} Join\n */\n\nimport {formatCodeAsIndented} from './util/format-code-as-indented.js'\nimport {formatHeadingAsSetext} from './util/format-heading-as-setext.js'\n\n/** @type {Array<Join>} */\nexport const join = [joinDefaults]\n\n/** @type {Join} */\nfunction joinDefaults(left, right, parent, state) {\n  // Indented code after list or another indented code.\n  if (\n    right.type === 'code' &&\n    formatCodeAsIndented(right, state) &&\n    (left.type === 'list' ||\n      (left.type === right.type && formatCodeAsIndented(left, state)))\n  ) {\n    return false\n  }\n\n  // Two lists with the same marker.\n  if (\n    left.type === 'list' &&\n    left.type === right.type &&\n    Boolean(left.ordered) === Boolean(right.ordered) &&\n    !(left.ordered\n      ? state.options.bulletOrderedOther\n      : state.options.bulletOther)\n  ) {\n    return false\n  }\n\n  // Join children of a list or an item.\n  // In which case, `parent` has a `spread` field.\n  if ('spread' in parent && typeof parent.spread === 'boolean') {\n    if (\n      left.type === 'paragraph' &&\n      // Two paragraphs.\n      (left.type === right.type ||\n        right.type === 'definition' ||\n        // Paragraph followed by a setext heading.\n        (right.type === 'heading' && formatHeadingAsSetext(right, state)))\n    ) {\n      return\n    }\n\n    return parent.spread ? 1 : 0\n  }\n}\n", "/**\n * @typedef {import('./types.js').Unsafe} Unsafe\n * @typedef {import('./types.js').ConstructName} ConstructName\n */\n\n/**\n * List of constructs that occur in phrasing (paragraphs, headings), but cannot\n * contain things like attention (emphasis, strong), images, or links.\n * So they sort of cancel each other out.\n * Note: could use a better name.\n *\n * @type {Array<ConstructName>}\n */\nconst fullPhrasingSpans = [\n  'autolink',\n  'destinationLiteral',\n  'destinationRaw',\n  'reference',\n  'titleQuote',\n  'titleApostrophe'\n]\n\n/** @type {Array<Unsafe>} */\nexport const unsafe = [\n  {character: '\\t', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: '\\t', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: '\\t',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  {\n    character: '\\r',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {\n    character: '\\n',\n    inConstruct: [\n      'codeFencedLangGraveAccent',\n      'codeFencedLangTilde',\n      'codeFencedMetaGraveAccent',\n      'codeFencedMetaTilde',\n      'destinationLiteral',\n      'headingAtx'\n    ]\n  },\n  {character: ' ', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {character: ' ', before: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  {\n    character: ' ',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']\n  },\n  // An exclamation mark can start an image, if it is followed by a link or\n  // a link reference.\n  {\n    character: '!',\n    after: '\\\\[',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A quote can break out of a title.\n  {character: '\"', inConstruct: 'titleQuote'},\n  // A number sign could start an ATX heading if it starts a line.\n  {atBreak: true, character: '#'},\n  {character: '#', inConstruct: 'headingAtx', after: '(?:[\\r\\n]|$)'},\n  // Dollar sign and percentage are not used in markdown.\n  // An ampersand could start a character reference.\n  {character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing'},\n  // An apostrophe can break out of a title.\n  {character: \"'\", inConstruct: 'titleApostrophe'},\n  // A left paren could break out of a destination raw.\n  {character: '(', inConstruct: 'destinationRaw'},\n  // A left paren followed by `]` could make something into a link or image.\n  {\n    before: '\\\\]',\n    character: '(',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  // A right paren could start a list item or break out of a destination\n  // raw.\n  {atBreak: true, before: '\\\\d+', character: ')'},\n  {character: ')', inConstruct: 'destinationRaw'},\n  // An asterisk can start thematic breaks, list items, emphasis, strong.\n  {atBreak: true, character: '*', after: '(?:[ \\t\\r\\n*])'},\n  {character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A plus sign could start a list item.\n  {atBreak: true, character: '+', after: '(?:[ \\t\\r\\n])'},\n  // A dash can start thematic breaks, list items, and setext heading\n  // underlines.\n  {atBreak: true, character: '-', after: '(?:[ \\t\\r\\n-])'},\n  // A dot could start a list item.\n  {atBreak: true, before: '\\\\d+', character: '.', after: '(?:[ \\t\\r\\n]|$)'},\n  // Slash, colon, and semicolon are not used in markdown for constructs.\n  // A less than can start html (flow or text) or an autolink.\n  // HTML could start with an exclamation mark (declaration, cdata, comment),\n  // slash (closing tag), question mark (instruction), or a letter (tag).\n  // An autolink also starts with a letter.\n  // Finally, it could break out of a destination literal.\n  {atBreak: true, character: '<', after: '[!/?A-Za-z]'},\n  {\n    character: '<',\n    after: '[!/?A-Za-z]',\n    inConstruct: 'phrasing',\n    notInConstruct: fullPhrasingSpans\n  },\n  {character: '<', inConstruct: 'destinationLiteral'},\n  // An equals to can start setext heading underlines.\n  {atBreak: true, character: '='},\n  // A greater than can start block quotes and it can break out of a\n  // destination literal.\n  {atBreak: true, character: '>'},\n  {character: '>', inConstruct: 'destinationLiteral'},\n  // Question mark and at sign are not used in markdown for constructs.\n  // A left bracket can start definitions, references, labels,\n  {atBreak: true, character: '['},\n  {character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  {character: '[', inConstruct: ['label', 'reference']},\n  // A backslash can start an escape (when followed by punctuation) or a\n  // hard break (when followed by an eol).\n  // Note: typical escapes are handled in `safe`!\n  {character: '\\\\', after: '[\\\\r\\\\n]', inConstruct: 'phrasing'},\n  // A right bracket can exit labels.\n  {character: ']', inConstruct: ['label', 'reference']},\n  // Caret is not used in markdown for constructs.\n  // An underscore can start emphasis, strong, or a thematic break.\n  {atBreak: true, character: '_'},\n  {character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // A grave accent can start code (fenced or text), or it can break out of\n  // a grave accent code fence.\n  {atBreak: true, character: '`'},\n  {\n    character: '`',\n    inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']\n  },\n  {character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans},\n  // Left brace, vertical bar, right brace are not used in markdown for\n  // constructs.\n  // A tilde can start code (fenced).\n  {atBreak: true, character: '~'}\n]\n", "/**\n * @typedef {import('./types.js').Enter} Enter\n * @typedef {import('./types.js').Info} Info\n * @typedef {import('./types.js').Join} Join\n * @typedef {import('./types.js').FlowContent} FlowContent\n * @typedef {import('./types.js').Node} Node\n * @typedef {import('./types.js').Options} Options\n * @typedef {import('./types.js').Parent} Parent\n * @typedef {import('./types.js').PhrasingContent} PhrasingContent\n * @typedef {import('./types.js').SafeConfig} SafeConfig\n * @typedef {import('./types.js').State} State\n * @typedef {import('./types.js').TrackFields} TrackFields\n */\n\nimport {zwitch} from 'zwitch'\nimport {configure} from './configure.js'\nimport {handle as handlers} from './handle/index.js'\nimport {join} from './join.js'\nimport {unsafe} from './unsafe.js'\nimport {association} from './util/association.js'\nimport {containerPhrasing} from './util/container-phrasing.js'\nimport {containerFlow} from './util/container-flow.js'\nimport {indentLines} from './util/indent-lines.js'\nimport {safe} from './util/safe.js'\nimport {track} from './util/track.js'\n\n/**\n * Turn an mdast syntax tree into markdown.\n *\n * @param {Node} tree\n *   Tree to serialize.\n * @param {Options} [options]\n *   Configuration (optional).\n * @returns {string}\n *   Serialized markdown representing `tree`.\n */\nexport function toMarkdown(tree, options = {}) {\n  /** @type {State} */\n  const state = {\n    enter,\n    indentLines,\n    associationId: association,\n    containerPhrasing: containerPhrasingBound,\n    containerFlow: containerFlowBound,\n    createTracker: track,\n    safe: safeBound,\n    stack: [],\n    unsafe: [],\n    join: [],\n    // @ts-expect-error: we’ll fill it next.\n    handlers: {},\n    options: {},\n    indexStack: [],\n    // @ts-expect-error: we’ll add `handle` later.\n    handle: undefined\n  }\n\n  configure(state, {unsafe, join, handlers})\n  configure(state, options)\n\n  if (state.options.tightDefinitions) {\n    configure(state, {join: [joinDefinition]})\n  }\n\n  state.handle = zwitch('type', {\n    invalid,\n    unknown,\n    handlers: state.handlers\n  })\n\n  let result = state.handle(tree, undefined, state, {\n    before: '\\n',\n    after: '\\n',\n    now: {line: 1, column: 1},\n    lineShift: 0\n  })\n\n  if (\n    result &&\n    result.charCodeAt(result.length - 1) !== 10 &&\n    result.charCodeAt(result.length - 1) !== 13\n  ) {\n    result += '\\n'\n  }\n\n  return result\n\n  /** @type {Enter} */\n  function enter(name) {\n    state.stack.push(name)\n    return exit\n\n    function exit() {\n      state.stack.pop()\n    }\n  }\n}\n\n/**\n * @param {unknown} value\n * @returns {never}\n */\nfunction invalid(value) {\n  throw new Error('Cannot handle value `' + value + '`, expected node')\n}\n\n/**\n * @param {unknown} node\n * @returns {never}\n */\nfunction unknown(node) {\n  // @ts-expect-error: fine.\n  throw new Error('Cannot handle unknown node `' + node.type + '`')\n}\n\n/** @type {Join} */\nfunction joinDefinition(left, right) {\n  // No blank line between adjacent definitions.\n  if (left.type === 'definition' && left.type === right.type) {\n    return 0\n  }\n}\n\n/**\n * Serialize the children of a parent that contains phrasing children.\n *\n * These children will be joined flush together.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<PhrasingContent>}} parent\n *   Parent of flow nodes.\n * @param {Info} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined together.\n */\nfunction containerPhrasingBound(parent, info) {\n  return containerPhrasing(parent, this, info)\n}\n\n/**\n * Serialize the children of a parent that contains flow children.\n *\n * These children will typically be joined by blank lines.\n * What they are joined by exactly is defined by `Join` functions.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {Parent & {children: Array<FlowContent>}} parent\n *   Parent of flow nodes.\n * @param {TrackFields} info\n *   Info on where we are in the document we are generating.\n * @returns {string}\n *   Serialized children, joined by (blank) lines.\n */\nfunction containerFlowBound(parent, info) {\n  return containerFlow(parent, this, info)\n}\n\n/**\n * Make a string safe for embedding in markdown constructs.\n *\n * In markdown, almost all punctuation characters can, in certain cases,\n * result in something.\n * Whether they do is highly subjective to where they happen and in what\n * they happen.\n *\n * To solve this, `mdast-util-to-markdown` tracks:\n *\n * * Characters before and after something;\n * * What “constructs” we are in.\n *\n * This information is then used by this function to escape or encode\n * special characters.\n *\n * @this {State}\n *   Info passed around about the current state.\n * @param {string | null | undefined} value\n *   Raw value to make safe.\n * @param {SafeConfig} config\n *   Configuration.\n * @returns {string}\n *   Serialized markdown safe for embedding.\n */\nfunction safeBound(value, config) {\n  return safe(this, value, config)\n}\n", "import { fromMarkdown } from \"mdast-util-from-markdown\";\nfunction isParent(node) {\n  return node.children instanceof Array;\n}\nfunction importMarkdownToLexical({ root, markdown, visitors, syntaxExtensions, mdastExtensions }) {\n  var _a;\n  const mdastRoot = fromMarkdown(markdown, {\n    extensions: syntaxExtensions,\n    mdastExtensions\n  });\n  if (mdastRoot.children.length === 0) {\n    mdastRoot.children.push({ type: \"paragraph\", children: [] });\n  }\n  if (((_a = mdastRoot.children.at(-1)) == null ? void 0 : _a.type) !== \"paragraph\") {\n    mdastRoot.children.push({ type: \"paragraph\", children: [] });\n  }\n  importMdastTreeToLexical({ root, mdastRoot, visitors });\n}\nfunction importMdastTreeToLexical({ root, mdastRoot, visitors }) {\n  const formattingMap = /* @__PURE__ */ new WeakMap();\n  function visitChildren(mdastNode, lexicalParent) {\n    if (!isParent(mdastNode)) {\n      throw new Error(\"Attempting to visit children of a non-parent\");\n    }\n    mdastNode.children.forEach((child) => visit(child, lexicalParent, mdastNode));\n  }\n  function visit(mdastNode, lexicalParent, mdastParent) {\n    const visitor = visitors.find((visitor2) => {\n      if (typeof visitor2.testNode === \"string\") {\n        return visitor2.testNode === mdastNode.type;\n      }\n      return visitor2.testNode(mdastNode);\n    });\n    if (!visitor) {\n      throw new Error(`no MdastImportVisitor found for ${mdastNode.type} ${JSON.stringify(mdastNode)}`, {\n        cause: mdastNode\n      });\n    }\n    visitor.visitNode({\n      //@ts-expect-error root type is glitching\n      mdastNode,\n      lexicalParent,\n      mdastParent,\n      actions: {\n        visitChildren,\n        addAndStepInto(lexicalNode) {\n          lexicalParent.append(lexicalNode);\n          if (isParent(mdastNode)) {\n            visitChildren(mdastNode, lexicalNode);\n          }\n        },\n        addFormatting(format, node = mdastNode) {\n          formattingMap.set(node, format | (formattingMap.get(mdastParent) ?? 0));\n        },\n        removeFormatting(format, node = mdastNode) {\n          formattingMap.set(node, format ^ (formattingMap.get(mdastParent) ?? 0));\n        },\n        getParentFormatting() {\n          return formattingMap.get(mdastParent) ?? 0;\n        }\n      }\n    });\n  }\n  visit(mdastRoot, root, null);\n}\nexport {\n  importMarkdownToLexical,\n  importMdastTreeToLexical\n};\n", "import { $isLineBreakNode } from \"lexical\";\nconst LexicalLinebreakVisitor = {\n  testLexicalNode: $isLineBreakNode,\n  visitLexicalNode: ({ mdastParent, actions }) => {\n    actions.appendToParent(mdastParent, { type: \"text\", value: \"\\n\" });\n  }\n};\nexport {\n  LexicalLinebreakVisitor\n};\n", "import { $isParagraphNode } from \"lexical\";\nconst LexicalParagraphVisitor = {\n  testLexicalNode: $isParagraphNode,\n  visitLexicalNode: ({ actions }) => {\n    actions.addAndStepInto(\"paragraph\");\n  }\n};\nexport {\n  LexicalParagraphVisitor\n};\n", "import { $isRootNode } from \"lexical\";\nconst LexicalRootVisitor = {\n  testLexicalNode: $isRootNode,\n  visitLexicalNode: ({ actions }) => {\n    actions.addAndStepInto(\"root\");\n  }\n};\nexport {\n  LexicalRootVisitor\n};\n", "import { $isTextNode } from \"lexical\";\nimport { IS_CODE, IS_ITALIC, IS_BOLD, IS_UNDERLINE } from \"../../FormatConstants.js\";\nfunction isMdastText(mdastNode) {\n  return mdastNode.type === \"text\";\n}\nconst LexicalTextVisitor = {\n  shouldJoin: (prevNode, currentNode) => {\n    return [\"text\", \"emphasis\", \"strong\", \"mdxJsxTextElement\"].includes(prevNode.type) && prevNode.type === currentNode.type;\n  },\n  join(prevNode, currentNode) {\n    if (isMdastText(prevNode) && isMdastText(currentNode)) {\n      return {\n        type: \"text\",\n        value: prevNode.value + currentNode.value\n      };\n    } else {\n      return {\n        ...prevNode,\n        children: [...prevNode.children, ...currentNode.children]\n      };\n    }\n  },\n  testLexicalNode: $isTextNode,\n  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {\n    const previousSibling = lexicalNode.getPreviousSibling();\n    const prevFormat = $isTextNode(previousSibling) ? previousSibling.getFormat() : 0;\n    const textContent = lexicalNode.getTextContent();\n    const format = lexicalNode.getFormat() ?? 0;\n    if (format & IS_CODE) {\n      actions.addAndStepInto(\"inlineCode\", {\n        value: textContent\n      });\n      return;\n    }\n    let localParentNode = mdastParent;\n    if (prevFormat & format & IS_ITALIC) {\n      localParentNode = actions.appendToParent(localParentNode, {\n        type: \"emphasis\",\n        children: []\n      });\n    }\n    if (prevFormat & format & IS_BOLD) {\n      localParentNode = actions.appendToParent(localParentNode, {\n        type: \"strong\",\n        children: []\n      });\n    }\n    if (prevFormat & format & IS_UNDERLINE) {\n      localParentNode = actions.appendToParent(localParentNode, {\n        type: \"mdxJsxTextElement\",\n        name: \"u\",\n        children: [],\n        attributes: []\n      });\n    }\n    if (format & IS_ITALIC && !(prevFormat & IS_ITALIC)) {\n      localParentNode = actions.appendToParent(localParentNode, {\n        type: \"emphasis\",\n        children: []\n      });\n    }\n    if (format & IS_BOLD && !(prevFormat & IS_BOLD)) {\n      localParentNode = actions.appendToParent(localParentNode, {\n        type: \"strong\",\n        children: []\n      });\n    }\n    if (format & IS_UNDERLINE && !(prevFormat & IS_UNDERLINE)) {\n      localParentNode = actions.appendToParent(localParentNode, {\n        type: \"mdxJsxTextElement\",\n        name: \"u\",\n        children: [],\n        attributes: []\n      });\n    }\n    actions.appendToParent(localParentNode, {\n      type: \"text\",\n      value: textContent\n    });\n  }\n};\nexport {\n  LexicalTextVisitor,\n  isMdastText\n};\n", "import { IS_UNDERLINE, IS_ITALIC, IS_BOLD } from \"../../FormatConstants.js\";\nfunction isOpeningUnderlineNode(node) {\n  return node.type === \"html\" && node.value === \"<u>\";\n}\nfunction isClosingUnderlineNode(node) {\n  return node.type === \"html\" && node.value === \"</u>\";\n}\nfunction isJsxUnderlineNode(node) {\n  return node.type === \"mdxJsxTextElement\" && node.name === \"u\";\n}\nconst MdastFormattingVisitor = {\n  testNode(mdastNode) {\n    return mdastNode.type === \"emphasis\" || mdastNode.type === \"strong\" || isJsxUnderlineNode(mdastNode) || isOpeningUnderlineNode(mdastNode) || isClosingUnderlineNode(mdastNode);\n  },\n  visitNode({ mdastNode, lexicalParent, actions, mdastParent }) {\n    if (isOpeningUnderlineNode(mdastNode)) {\n      actions.addFormatting(IS_UNDERLINE, mdastParent);\n      return;\n    }\n    if (isClosingUnderlineNode(mdastNode)) {\n      actions.removeFormatting(IS_UNDERLINE, mdastParent);\n      return;\n    }\n    if (mdastNode.type === \"emphasis\") {\n      actions.addFormatting(IS_ITALIC);\n    } else if (mdastNode.type === \"strong\") {\n      actions.addFormatting(IS_BOLD);\n    } else if (isJsxUnderlineNode(mdastNode)) {\n      actions.addFormatting(IS_UNDERLINE);\n    }\n    actions.visitChildren(mdastNode, lexicalParent);\n  }\n};\nexport {\n  MdastFormattingVisitor\n};\n", "import { $createTextNode } from \"lexical\";\nimport { IS_CODE } from \"../../FormatConstants.js\";\nfunction isOpeningCodeNode(node) {\n  return node.type === \"html\" && node.value === \"<code>\";\n}\nfunction isClosingCodeNode(node) {\n  return node.type === \"html\" && node.value === \"</code>\";\n}\nconst MdastInlineCodeVisitor = {\n  testNode: (node) => {\n    return node.type === \"inlineCode\" || isOpeningCodeNode(node) || isClosingCodeNode(node);\n  },\n  visitNode({ mdastNode, actions, mdastParent }) {\n    if (isOpeningCodeNode(mdastNode)) {\n      actions.addFormatting(IS_CODE, mdastParent);\n      return;\n    }\n    if (isClosingCodeNode(mdastNode)) {\n      actions.removeFormatting(IS_CODE, mdastParent);\n      return;\n    }\n    actions.addAndStepInto($createTextNode(mdastNode.value).setFormat(IS_CODE));\n  }\n};\nexport {\n  MdastInlineCodeVisitor\n};\n", "import { $createParagraphNode } from \"lexical\";\nconst lexicalTypesThatShouldSkipParagraphs = [\"listitem\", \"quote\", \"admonition\"];\nconst MdastParagraphVisitor = {\n  testNode: \"paragraph\",\n  visitNode: function({ mdastNode, lexicalParent, actions }) {\n    if (lexicalTypesThatShouldSkipParagraphs.includes(lexicalParent.getType())) {\n      actions.visitChildren(mdastNode, lexicalParent);\n    } else {\n      actions.addAndStepInto($createParagraphNode());\n    }\n  }\n};\nexport {\n  MdastParagraphVisitor\n};\n", "const MdastRootVisitor = {\n  testNode: \"root\",\n  visitNode({ actions, mdastNode, lexicalParent }) {\n    actions.visitChildren(mdastNode, lexicalParent);\n  }\n};\nexport {\n  MdastRootVisitor\n};\n", "import { $createTextNode } from \"lexical\";\nconst MdastTextVisitor = {\n  testNode: \"text\",\n  visitNode({ mdastNode, actions }) {\n    actions.addAndStepInto($createTextNode(mdastNode.value).setFormat(actions.getParentFormatting()));\n  }\n};\nexport {\n  MdastTextVisitor\n};\n", "import { HistoryPlugin } from \"@lexical/react/LexicalHistoryPlugin.js\";\nimport React__default from \"react\";\nimport { corePluginHooks } from \"./index.js\";\nconst SharedHistoryPlugin = () => {\n  const [historyState] = corePluginHooks.useEmitterValues(\"historyState\");\n  return /* @__PURE__ */ React__default.createElement(HistoryPlugin, { externalHistoryState: historyState });\n};\nexport {\n  SharedHistoryPlugin\n};\n", "import { $createLineBreakNode } from \"lexical\";\nconst MdastBreakVisitor = {\n  testNode: \"break\",\n  visitNode: function({ lexicalParent }) {\n    lexicalParent.append($createLineBreakNode());\n  }\n};\nexport {\n  MdastBreakVisitor\n};\n"],
  "mappings": "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",
  "names": ["createCommand", "SELECTION_CHANGE_COMMAND", "FORMAT_TEXT_COMMAND", "KEY_DOWN_COMMAND", "BLUR_COMMAND", "CAN_USE_DOM", "IS_APPLE", "IS_BOLD", "IS_ITALIC", "IS_UNDERLINE", "IS_CODE", "$getSelection", "text", "$isRangeSelection", "$isDecoratorNode", "$isTextNode", "$isElementNode", "$setSelection", "$isLineBreakNode", "$getRoot", "$createTextNode", "controlOrMeta", "root", "mutatedNodes", "$isRootNode", "$isRootOrShadowRoot", "leftTree", "rightTree", "$findMatchingParent", "anchorNode", "$createParagraphNode", "$createLineBreakNode", "TextNode", "map", "paragraph", "newElement", "$insertNodes", "dirtyElements", "dirtyLeaves", "resolvedNode", "ParagraphNode", "$isParagraphNode", "COMMAND_PRIORITY_CRITICAL", "activeEditor", "text", "$setBlocksType", "root", "$findMatchingParent", "$insertNodeToNearestRoot", "selection", "root", "$wrapNodeInElement", "selection", "root", "html", "CAN_USE_DOM", "selection", "text", "root", "CAN_USE_DOM", "paragraph", "selection", "$isHeadingNode", "createEmptyHistoryState", "HistoryPlugin", "map", "visit", "map2", "link", "React__default", "realm", "React__default", "realm2", "import_LexicalHistoryPlugin", "import_lexical", "exit", "value", "map", "node", "exit", "subexit", "value", "value", "text", "root", "visit", "isParent", "root", "visit", "import_lexical", "import_lexical", "import_lexical", "import_lexical", "import_lexical", "import_lexical", "import_lexical", "import_react", "React__default", "import_lexical", "realm"]
}
