import {
  EXIT,
  association,
  checkBullet,
  containerFlow,
  containerPhrasing,
  convert,
  fromMarkdown,
  indentLines,
  inlineCode,
  listItem,
  patternInScope,
  safe,
  toString,
  track,
  visit,
  zwitch
} from "./chunk-4YQ2LHX3.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/lexical/Lexical.dev.js
var require_Lexical_dev = __commonJS({
  "node_modules/lexical/Lexical.dev.js"(exports) {
    "use strict";
    function createCommand2(type) {
      return {
        type
      };
    }
    var SELECTION_CHANGE_COMMAND2 = createCommand2("SELECTION_CHANGE_COMMAND");
    var CLICK_COMMAND = createCommand2("CLICK_COMMAND");
    var DELETE_CHARACTER_COMMAND = createCommand2("DELETE_CHARACTER_COMMAND");
    var INSERT_LINE_BREAK_COMMAND = createCommand2("INSERT_LINE_BREAK_COMMAND");
    var INSERT_PARAGRAPH_COMMAND = createCommand2("INSERT_PARAGRAPH_COMMAND");
    var CONTROLLED_TEXT_INSERTION_COMMAND = createCommand2("CONTROLLED_TEXT_INSERTION_COMMAND");
    var PASTE_COMMAND = createCommand2("PASTE_COMMAND");
    var REMOVE_TEXT_COMMAND = createCommand2("REMOVE_TEXT_COMMAND");
    var DELETE_WORD_COMMAND = createCommand2("DELETE_WORD_COMMAND");
    var DELETE_LINE_COMMAND = createCommand2("DELETE_LINE_COMMAND");
    var FORMAT_TEXT_COMMAND2 = createCommand2("FORMAT_TEXT_COMMAND");
    var UNDO_COMMAND = createCommand2("UNDO_COMMAND");
    var REDO_COMMAND = createCommand2("REDO_COMMAND");
    var KEY_DOWN_COMMAND2 = createCommand2("KEYDOWN_COMMAND");
    var KEY_ARROW_RIGHT_COMMAND = createCommand2("KEY_ARROW_RIGHT_COMMAND");
    var MOVE_TO_END = createCommand2("MOVE_TO_END");
    var KEY_ARROW_LEFT_COMMAND = createCommand2("KEY_ARROW_LEFT_COMMAND");
    var MOVE_TO_START = createCommand2("MOVE_TO_START");
    var KEY_ARROW_UP_COMMAND = createCommand2("KEY_ARROW_UP_COMMAND");
    var KEY_ARROW_DOWN_COMMAND = createCommand2("KEY_ARROW_DOWN_COMMAND");
    var KEY_ENTER_COMMAND = createCommand2("KEY_ENTER_COMMAND");
    var KEY_SPACE_COMMAND = createCommand2("KEY_SPACE_COMMAND");
    var KEY_BACKSPACE_COMMAND = createCommand2("KEY_BACKSPACE_COMMAND");
    var KEY_ESCAPE_COMMAND = createCommand2("KEY_ESCAPE_COMMAND");
    var KEY_DELETE_COMMAND = createCommand2("KEY_DELETE_COMMAND");
    var KEY_TAB_COMMAND = createCommand2("KEY_TAB_COMMAND");
    var INSERT_TAB_COMMAND = createCommand2("INSERT_TAB_COMMAND");
    var INDENT_CONTENT_COMMAND = createCommand2("INDENT_CONTENT_COMMAND");
    var OUTDENT_CONTENT_COMMAND = createCommand2("OUTDENT_CONTENT_COMMAND");
    var DROP_COMMAND = createCommand2("DROP_COMMAND");
    var FORMAT_ELEMENT_COMMAND = createCommand2("FORMAT_ELEMENT_COMMAND");
    var DRAGSTART_COMMAND = createCommand2("DRAGSTART_COMMAND");
    var DRAGOVER_COMMAND = createCommand2("DRAGOVER_COMMAND");
    var DRAGEND_COMMAND = createCommand2("DRAGEND_COMMAND");
    var COPY_COMMAND = createCommand2("COPY_COMMAND");
    var CUT_COMMAND = createCommand2("CUT_COMMAND");
    var SELECT_ALL_COMMAND = createCommand2("SELECT_ALL_COMMAND");
    var CLEAR_EDITOR_COMMAND = createCommand2("CLEAR_EDITOR_COMMAND");
    var CLEAR_HISTORY_COMMAND = createCommand2("CLEAR_HISTORY_COMMAND");
    var CAN_REDO_COMMAND = createCommand2("CAN_REDO_COMMAND");
    var CAN_UNDO_COMMAND = createCommand2("CAN_UNDO_COMMAND");
    var FOCUS_COMMAND = createCommand2("FOCUS_COMMAND");
    var BLUR_COMMAND2 = createCommand2("BLUR_COMMAND");
    var KEY_MODIFIER_COMMAND = createCommand2("KEY_MODIFIER_COMMAND");
    var CAN_USE_DOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var documentMode = CAN_USE_DOM2 && "documentMode" in document ? document.documentMode : null;
    var IS_APPLE2 = CAN_USE_DOM2 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    var IS_FIREFOX = CAN_USE_DOM2 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    var CAN_USE_BEFORE_INPUT = CAN_USE_DOM2 && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    var IS_SAFARI = CAN_USE_DOM2 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    var IS_IOS = CAN_USE_DOM2 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    var IS_CHROME = CAN_USE_DOM2 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    var IS_APPLE_WEBKIT = CAN_USE_DOM2 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    var DOM_ELEMENT_TYPE = 1;
    var DOM_TEXT_TYPE = 3;
    var NO_DIRTY_NODES = 0;
    var HAS_DIRTY_NODES = 1;
    var FULL_RECONCILE = 2;
    var IS_NORMAL = 0;
    var IS_TOKEN = 1;
    var IS_SEGMENTED = 2;
    var IS_BOLD2 = 1;
    var IS_ITALIC2 = 1 << 1;
    var IS_STRIKETHROUGH = 1 << 2;
    var IS_UNDERLINE2 = 1 << 3;
    var IS_CODE2 = 1 << 4;
    var IS_SUBSCRIPT = 1 << 5;
    var IS_SUPERSCRIPT = 1 << 6;
    var IS_HIGHLIGHT = 1 << 7;
    var IS_ALL_FORMATTING = IS_BOLD2 | IS_ITALIC2 | IS_STRIKETHROUGH | IS_UNDERLINE2 | IS_CODE2 | IS_SUBSCRIPT | IS_SUPERSCRIPT | IS_HIGHLIGHT;
    var IS_DIRECTIONLESS = 1;
    var IS_UNMERGEABLE = 1 << 1;
    var IS_ALIGN_LEFT = 1;
    var IS_ALIGN_CENTER = 2;
    var IS_ALIGN_RIGHT = 3;
    var IS_ALIGN_JUSTIFY = 4;
    var IS_ALIGN_START = 5;
    var IS_ALIGN_END = 6;
    var NON_BREAKING_SPACE = " ";
    var ZERO_WIDTH_SPACE = "​";
    var COMPOSITION_SUFFIX = IS_SAFARI || IS_IOS || IS_APPLE_WEBKIT ? NON_BREAKING_SPACE : ZERO_WIDTH_SPACE;
    var DOUBLE_LINE_BREAK = "\n\n";
    var COMPOSITION_START_CHAR = IS_FIREFOX ? NON_BREAKING_SPACE : COMPOSITION_SUFFIX;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var RTL_REGEX = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var LTR_REGEX = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    var TEXT_TYPE_TO_FORMAT = {
      bold: IS_BOLD2,
      code: IS_CODE2,
      highlight: IS_HIGHLIGHT,
      italic: IS_ITALIC2,
      strikethrough: IS_STRIKETHROUGH,
      subscript: IS_SUBSCRIPT,
      superscript: IS_SUPERSCRIPT,
      underline: IS_UNDERLINE2
    };
    var DETAIL_TYPE_TO_DETAIL = {
      directionless: IS_DIRECTIONLESS,
      unmergeable: IS_UNMERGEABLE
    };
    var ELEMENT_TYPE_TO_FORMAT = {
      center: IS_ALIGN_CENTER,
      end: IS_ALIGN_END,
      justify: IS_ALIGN_JUSTIFY,
      left: IS_ALIGN_LEFT,
      right: IS_ALIGN_RIGHT,
      start: IS_ALIGN_START
    };
    var ELEMENT_FORMAT_TO_TYPE = {
      [IS_ALIGN_CENTER]: "center",
      [IS_ALIGN_END]: "end",
      [IS_ALIGN_JUSTIFY]: "justify",
      [IS_ALIGN_LEFT]: "left",
      [IS_ALIGN_RIGHT]: "right",
      [IS_ALIGN_START]: "start"
    };
    var TEXT_MODE_TO_TYPE = {
      normal: IS_NORMAL,
      segmented: IS_SEGMENTED,
      token: IS_TOKEN
    };
    var TEXT_TYPE_TO_MODE = {
      [IS_NORMAL]: "normal",
      [IS_SEGMENTED]: "segmented",
      [IS_TOKEN]: "token"
    };
    var TEXT_MUTATION_VARIANCE = 100;
    var isProcessingMutations = false;
    var lastTextEntryTimeStamp = 0;
    function getIsProcesssingMutations() {
      return isProcessingMutations;
    }
    function updateTimeStamp(event) {
      lastTextEntryTimeStamp = event.timeStamp;
    }
    function initTextEntryListener(editor) {
      if (lastTextEntryTimeStamp === 0) {
        getWindow(editor).addEventListener("textInput", updateTimeStamp, true);
      }
    }
    function isManagedLineBreak(dom, target, editor) {
      return (
        // @ts-expect-error: internal field
        target.__lexicalLineBreak === dom || // @ts-ignore We intentionally add this to the Node.
        dom[`__lexicalKey_${editor._key}`] !== void 0
      );
    }
    function getLastSelection(editor) {
      return editor.getEditorState().read(() => {
        const selection = $getSelection2();
        return selection !== null ? selection.clone() : null;
      });
    }
    function handleTextMutation(target, node, editor) {
      const domSelection = getDOMSelection(editor._window);
      let anchorOffset = null;
      let focusOffset = null;
      if (domSelection !== null && domSelection.anchorNode === target) {
        anchorOffset = domSelection.anchorOffset;
        focusOffset = domSelection.focusOffset;
      }
      const text2 = target.nodeValue;
      if (text2 !== null) {
        $updateTextNodeFromDOMContent(node, text2, anchorOffset, focusOffset, false);
      }
    }
    function shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode) {
      if ($isRangeSelection2(selection)) {
        const anchorNode = selection.anchor.getNode();
        if (anchorNode.is(targetNode) && selection.format !== anchorNode.getFormat()) {
          return false;
        }
      }
      return targetDOM.nodeType === DOM_TEXT_TYPE && targetNode.isAttached();
    }
    function $flushMutations$1(editor, mutations, observer) {
      isProcessingMutations = true;
      const shouldFlushTextMutations = performance.now() - lastTextEntryTimeStamp > TEXT_MUTATION_VARIANCE;
      try {
        updateEditor(editor, () => {
          const selection = $getSelection2() || getLastSelection(editor);
          const badDOMTargets = /* @__PURE__ */ new Map();
          const rootElement = editor.getRootElement();
          const currentEditorState = editor._editorState;
          const blockCursorElement = editor._blockCursorElement;
          let shouldRevertSelection = false;
          let possibleTextForFirefoxPaste = "";
          for (let i = 0; i < mutations.length; i++) {
            const mutation = mutations[i];
            const type = mutation.type;
            const targetDOM = mutation.target;
            let targetNode = $getNearestNodeFromDOMNode(targetDOM, currentEditorState);
            if (targetNode === null && targetDOM !== rootElement || $isDecoratorNode2(targetNode)) {
              continue;
            }
            if (type === "characterData") {
              if (shouldFlushTextMutations && $isTextNode2(targetNode) && shouldUpdateTextNodeFromMutation(selection, targetDOM, targetNode)) {
                handleTextMutation(
                  // nodeType === DOM_TEXT_TYPE is a Text DOM node
                  targetDOM,
                  targetNode,
                  editor
                );
              }
            } else if (type === "childList") {
              shouldRevertSelection = true;
              const addedDOMs = mutation.addedNodes;
              for (let s = 0; s < addedDOMs.length; s++) {
                const addedDOM = addedDOMs[s];
                const node = getNodeFromDOMNode(addedDOM);
                const parentDOM = addedDOM.parentNode;
                if (parentDOM != null && addedDOM !== blockCursorElement && node === null && (addedDOM.nodeName !== "BR" || !isManagedLineBreak(addedDOM, parentDOM, editor))) {
                  if (IS_FIREFOX) {
                    const possibleText = addedDOM.innerText || addedDOM.nodeValue;
                    if (possibleText) {
                      possibleTextForFirefoxPaste += possibleText;
                    }
                  }
                  parentDOM.removeChild(addedDOM);
                }
              }
              const removedDOMs = mutation.removedNodes;
              const removedDOMsLength = removedDOMs.length;
              if (removedDOMsLength > 0) {
                let unremovedBRs = 0;
                for (let s = 0; s < removedDOMsLength; s++) {
                  const removedDOM = removedDOMs[s];
                  if (removedDOM.nodeName === "BR" && isManagedLineBreak(removedDOM, targetDOM, editor) || blockCursorElement === removedDOM) {
                    targetDOM.appendChild(removedDOM);
                    unremovedBRs++;
                  }
                }
                if (removedDOMsLength !== unremovedBRs) {
                  if (targetDOM === rootElement) {
                    targetNode = internalGetRoot(currentEditorState);
                  }
                  badDOMTargets.set(targetDOM, targetNode);
                }
              }
            }
          }
          if (badDOMTargets.size > 0) {
            for (const [targetDOM, targetNode] of badDOMTargets) {
              if ($isElementNode2(targetNode)) {
                const childKeys = targetNode.getChildrenKeys();
                let currentDOM = targetDOM.firstChild;
                for (let s = 0; s < childKeys.length; s++) {
                  const key = childKeys[s];
                  const correctDOM = editor.getElementByKey(key);
                  if (correctDOM === null) {
                    continue;
                  }
                  if (currentDOM == null) {
                    targetDOM.appendChild(correctDOM);
                    currentDOM = correctDOM;
                  } else if (currentDOM !== correctDOM) {
                    targetDOM.replaceChild(correctDOM, currentDOM);
                  }
                  currentDOM = currentDOM.nextSibling;
                }
              } else if ($isTextNode2(targetNode)) {
                targetNode.markDirty();
              }
            }
          }
          const records = observer.takeRecords();
          if (records.length > 0) {
            for (let i = 0; i < records.length; i++) {
              const record = records[i];
              const addedNodes = record.addedNodes;
              const target = record.target;
              for (let s = 0; s < addedNodes.length; s++) {
                const addedDOM = addedNodes[s];
                const parentDOM = addedDOM.parentNode;
                if (parentDOM != null && addedDOM.nodeName === "BR" && !isManagedLineBreak(addedDOM, target, editor)) {
                  parentDOM.removeChild(addedDOM);
                }
              }
            }
            observer.takeRecords();
          }
          if (selection !== null) {
            if (shouldRevertSelection) {
              selection.dirty = true;
              $setSelection2(selection);
            }
            if (IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
              selection.insertRawText(possibleTextForFirefoxPaste);
            }
          }
        });
      } finally {
        isProcessingMutations = false;
      }
    }
    function flushRootMutations(editor) {
      const observer = editor._observer;
      if (observer !== null) {
        const mutations = observer.takeRecords();
        $flushMutations$1(editor, mutations, observer);
      }
    }
    function initMutationObserver(editor) {
      initTextEntryListener(editor);
      editor._observer = new MutationObserver((mutations, observer) => {
        $flushMutations$1(editor, mutations, observer);
      });
    }
    function $canSimpleTextNodesBeMerged(node1, node2) {
      const node1Mode = node1.__mode;
      const node1Format = node1.__format;
      const node1Style = node1.__style;
      const node2Mode = node2.__mode;
      const node2Format = node2.__format;
      const node2Style = node2.__style;
      return (node1Mode === null || node1Mode === node2Mode) && (node1Format === null || node1Format === node2Format) && (node1Style === null || node1Style === node2Style);
    }
    function $mergeTextNodes(node1, node2) {
      const writableNode1 = node1.mergeWithSibling(node2);
      const normalizedNodes = getActiveEditor()._normalizedNodes;
      normalizedNodes.add(node1.__key);
      normalizedNodes.add(node2.__key);
      return writableNode1;
    }
    function $normalizeTextNode(textNode) {
      let node = textNode;
      if (node.__text === "" && node.isSimpleText() && !node.isUnmergeable()) {
        node.remove();
        return;
      }
      let previousNode;
      while ((previousNode = node.getPreviousSibling()) !== null && $isTextNode2(previousNode) && previousNode.isSimpleText() && !previousNode.isUnmergeable()) {
        if (previousNode.__text === "") {
          previousNode.remove();
        } else if ($canSimpleTextNodesBeMerged(previousNode, node)) {
          node = $mergeTextNodes(previousNode, node);
          break;
        } else {
          break;
        }
      }
      let nextNode;
      while ((nextNode = node.getNextSibling()) !== null && $isTextNode2(nextNode) && nextNode.isSimpleText() && !nextNode.isUnmergeable()) {
        if (nextNode.__text === "") {
          nextNode.remove();
        } else if ($canSimpleTextNodesBeMerged(node, nextNode)) {
          node = $mergeTextNodes(node, nextNode);
          break;
        } else {
          break;
        }
      }
    }
    function $normalizeSelection(selection) {
      $normalizePoint(selection.anchor);
      $normalizePoint(selection.focus);
      return selection;
    }
    function $normalizePoint(point) {
      while (point.type === "element") {
        const node = point.getNode();
        const offset = point.offset;
        let nextNode;
        let nextOffsetAtEnd;
        if (offset === node.getChildrenSize()) {
          nextNode = node.getChildAtIndex(offset - 1);
          nextOffsetAtEnd = true;
        } else {
          nextNode = node.getChildAtIndex(offset);
          nextOffsetAtEnd = false;
        }
        if ($isTextNode2(nextNode)) {
          point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getTextContentSize() : 0, "text");
          break;
        } else if (!$isElementNode2(nextNode)) {
          break;
        }
        point.set(nextNode.__key, nextOffsetAtEnd ? nextNode.getChildrenSize() : 0, "element");
      }
    }
    var keyCounter = 1;
    function generateRandomKey() {
      return "" + keyCounter++;
    }
    function getRegisteredNodeOrThrow(editor, nodeType) {
      const registeredNode = editor._nodes.get(nodeType);
      if (registeredNode === void 0) {
        {
          throw Error(`registeredNode: Type ${nodeType} not found`);
        }
      }
      return registeredNode;
    }
    var scheduleMicroTask = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => {
      Promise.resolve().then(fn);
    };
    function $isSelectionCapturedInDecorator(node) {
      return $isDecoratorNode2($getNearestNodeFromDOMNode(node));
    }
    function isSelectionCapturedInDecoratorInput(anchorDOM) {
      const activeElement = document.activeElement;
      if (activeElement === null) {
        return false;
      }
      const nodeName = activeElement.nodeName;
      return $isDecoratorNode2($getNearestNodeFromDOMNode(anchorDOM)) && (nodeName === "INPUT" || nodeName === "TEXTAREA" || activeElement.contentEditable === "true" && // @ts-ignore iternal field
      activeElement.__lexicalEditor == null);
    }
    function isSelectionWithinEditor(editor, anchorDOM, focusDOM) {
      const rootElement = editor.getRootElement();
      try {
        return rootElement !== null && rootElement.contains(anchorDOM) && rootElement.contains(focusDOM) && // Ignore if selection is within nested editor
        anchorDOM !== null && !isSelectionCapturedInDecoratorInput(anchorDOM) && getNearestEditorFromDOMNode(anchorDOM) === editor;
      } catch (error) {
        return false;
      }
    }
    function getNearestEditorFromDOMNode(node) {
      let currentNode = node;
      while (currentNode != null) {
        const editor = currentNode.__lexicalEditor;
        if (editor != null) {
          return editor;
        }
        currentNode = getParentElement(currentNode);
      }
      return null;
    }
    function getTextDirection(text2) {
      if (RTL_REGEX.test(text2)) {
        return "rtl";
      }
      if (LTR_REGEX.test(text2)) {
        return "ltr";
      }
      return null;
    }
    function $isTokenOrSegmented(node) {
      return node.isToken() || node.isSegmented();
    }
    function isDOMNodeLexicalTextNode(node) {
      return node.nodeType === DOM_TEXT_TYPE;
    }
    function getDOMTextNode(element) {
      let node = element;
      while (node != null) {
        if (isDOMNodeLexicalTextNode(node)) {
          return node;
        }
        node = node.firstChild;
      }
      return null;
    }
    function toggleTextFormatType(format, type, alignWithFormat) {
      const activeFormat = TEXT_TYPE_TO_FORMAT[type];
      const isStateFlagPresent = format & activeFormat;
      if (isStateFlagPresent && (alignWithFormat === null || (alignWithFormat & activeFormat) === 0)) {
        return format ^ activeFormat;
      }
      if (alignWithFormat === null || alignWithFormat & activeFormat) {
        return format | activeFormat;
      }
      return format;
    }
    function $isLeafNode(node) {
      return $isTextNode2(node) || $isLineBreakNode2(node) || $isDecoratorNode2(node);
    }
    function $setNodeKey(node, existingKey) {
      if (existingKey != null) {
        node.__key = existingKey;
        return;
      }
      errorOnReadOnly();
      errorOnInfiniteTransforms();
      const editor = getActiveEditor();
      const editorState = getActiveEditorState();
      const key = generateRandomKey();
      editorState._nodeMap.set(key, node);
      if ($isElementNode2(node)) {
        editor._dirtyElements.set(key, true);
      } else {
        editor._dirtyLeaves.add(key);
      }
      editor._cloneNotNeeded.add(key);
      editor._dirtyType = HAS_DIRTY_NODES;
      node.__key = key;
    }
    function internalMarkParentElementsAsDirty(parentKey, nodeMap, dirtyElements) {
      let nextParentKey = parentKey;
      while (nextParentKey !== null) {
        if (dirtyElements.has(nextParentKey)) {
          return;
        }
        const node = nodeMap.get(nextParentKey);
        if (node === void 0) {
          break;
        }
        dirtyElements.set(nextParentKey, false);
        nextParentKey = node.__parent;
      }
    }
    function removeFromParent(node) {
      const oldParent = node.getParent();
      if (oldParent !== null) {
        const writableNode = node.getWritable();
        const writableParent = oldParent.getWritable();
        const prevSibling = node.getPreviousSibling();
        const nextSibling = node.getNextSibling();
        if (prevSibling === null) {
          if (nextSibling !== null) {
            const writableNextSibling = nextSibling.getWritable();
            writableParent.__first = nextSibling.__key;
            writableNextSibling.__prev = null;
          } else {
            writableParent.__first = null;
          }
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          if (nextSibling !== null) {
            const writableNextSibling = nextSibling.getWritable();
            writableNextSibling.__prev = writablePrevSibling.__key;
            writablePrevSibling.__next = writableNextSibling.__key;
          } else {
            writablePrevSibling.__next = null;
          }
          writableNode.__prev = null;
        }
        if (nextSibling === null) {
          if (prevSibling !== null) {
            const writablePrevSibling = prevSibling.getWritable();
            writableParent.__last = prevSibling.__key;
            writablePrevSibling.__next = null;
          } else {
            writableParent.__last = null;
          }
        } else {
          const writableNextSibling = nextSibling.getWritable();
          if (prevSibling !== null) {
            const writablePrevSibling = prevSibling.getWritable();
            writablePrevSibling.__next = writableNextSibling.__key;
            writableNextSibling.__prev = writablePrevSibling.__key;
          } else {
            writableNextSibling.__prev = null;
          }
          writableNode.__next = null;
        }
        writableParent.__size--;
        writableNode.__parent = null;
      }
    }
    function internalMarkNodeAsDirty(node) {
      errorOnInfiniteTransforms();
      const latest = node.getLatest();
      const parent = latest.__parent;
      const editorState = getActiveEditorState();
      const editor = getActiveEditor();
      const nodeMap = editorState._nodeMap;
      const dirtyElements = editor._dirtyElements;
      if (parent !== null) {
        internalMarkParentElementsAsDirty(parent, nodeMap, dirtyElements);
      }
      const key = latest.__key;
      editor._dirtyType = HAS_DIRTY_NODES;
      if ($isElementNode2(node)) {
        dirtyElements.set(key, true);
      } else {
        editor._dirtyLeaves.add(key);
      }
    }
    function internalMarkSiblingsAsDirty(node) {
      const previousNode = node.getPreviousSibling();
      const nextNode = node.getNextSibling();
      if (previousNode !== null) {
        internalMarkNodeAsDirty(previousNode);
      }
      if (nextNode !== null) {
        internalMarkNodeAsDirty(nextNode);
      }
    }
    function $setCompositionKey(compositionKey) {
      errorOnReadOnly();
      const editor = getActiveEditor();
      const previousCompositionKey = editor._compositionKey;
      if (compositionKey !== previousCompositionKey) {
        editor._compositionKey = compositionKey;
        if (previousCompositionKey !== null) {
          const node = $getNodeByKey(previousCompositionKey);
          if (node !== null) {
            node.getWritable();
          }
        }
        if (compositionKey !== null) {
          const node = $getNodeByKey(compositionKey);
          if (node !== null) {
            node.getWritable();
          }
        }
      }
    }
    function $getCompositionKey() {
      if (isCurrentlyReadOnlyMode()) {
        return null;
      }
      const editor = getActiveEditor();
      return editor._compositionKey;
    }
    function $getNodeByKey(key, _editorState) {
      const editorState = _editorState || getActiveEditorState();
      const node = editorState._nodeMap.get(key);
      if (node === void 0) {
        return null;
      }
      return node;
    }
    function getNodeFromDOMNode(dom, editorState) {
      const editor = getActiveEditor();
      const key = dom[`__lexicalKey_${editor._key}`];
      if (key !== void 0) {
        return $getNodeByKey(key, editorState);
      }
      return null;
    }
    function $getNearestNodeFromDOMNode(startingDOM, editorState) {
      let dom = startingDOM;
      while (dom != null) {
        const node = getNodeFromDOMNode(dom, editorState);
        if (node !== null) {
          return node;
        }
        dom = getParentElement(dom);
      }
      return null;
    }
    function cloneDecorators(editor) {
      const currentDecorators = editor._decorators;
      const pendingDecorators = Object.assign({}, currentDecorators);
      editor._pendingDecorators = pendingDecorators;
      return pendingDecorators;
    }
    function getEditorStateTextContent(editorState) {
      return editorState.read(() => $getRoot2().getTextContent());
    }
    function markAllNodesAsDirty(editor, type) {
      updateEditor(editor, () => {
        const editorState = getActiveEditorState();
        if (editorState.isEmpty()) {
          return;
        }
        if (type === "root") {
          $getRoot2().markDirty();
          return;
        }
        const nodeMap = editorState._nodeMap;
        for (const [, node] of nodeMap) {
          node.markDirty();
        }
      }, editor._pendingEditorState === null ? {
        tag: "history-merge"
      } : void 0);
    }
    function $getRoot2() {
      return internalGetRoot(getActiveEditorState());
    }
    function internalGetRoot(editorState) {
      return editorState._nodeMap.get("root");
    }
    function $setSelection2(selection) {
      errorOnReadOnly();
      const editorState = getActiveEditorState();
      if (selection !== null) {
        {
          if (Object.isFrozen(selection)) {
            {
              throw Error(`$setSelection called on frozen selection object. Ensure selection is cloned before passing in.`);
            }
          }
        }
        selection.dirty = true;
        selection._cachedNodes = null;
      }
      editorState._selection = selection;
    }
    function $flushMutations() {
      errorOnReadOnly();
      const editor = getActiveEditor();
      flushRootMutations(editor);
    }
    function getNodeFromDOM(dom) {
      const editor = getActiveEditor();
      const nodeKey = getNodeKeyFromDOM(dom, editor);
      if (nodeKey === null) {
        const rootElement = editor.getRootElement();
        if (dom === rootElement) {
          return $getNodeByKey("root");
        }
        return null;
      }
      return $getNodeByKey(nodeKey);
    }
    function getTextNodeOffset(node, moveSelectionToEnd) {
      return moveSelectionToEnd ? node.getTextContentSize() : 0;
    }
    function getNodeKeyFromDOM(dom, editor) {
      let node = dom;
      while (node != null) {
        const key = node[`__lexicalKey_${editor._key}`];
        if (key !== void 0) {
          return key;
        }
        node = getParentElement(node);
      }
      return null;
    }
    function doesContainGrapheme(str) {
      return /[\uD800-\uDBFF][\uDC00-\uDFFF]/g.test(str);
    }
    function getEditorsToPropagate(editor) {
      const editorsToPropagate = [];
      let currentEditor = editor;
      while (currentEditor !== null) {
        editorsToPropagate.push(currentEditor);
        currentEditor = currentEditor._parentEditor;
      }
      return editorsToPropagate;
    }
    function createUID() {
      return Math.random().toString(36).replace(/[^a-z]+/g, "").substr(0, 5);
    }
    function getAnchorTextFromDOM(anchorNode) {
      if (anchorNode.nodeType === DOM_TEXT_TYPE) {
        return anchorNode.nodeValue;
      }
      return null;
    }
    function $updateSelectedTextFromDOM(isCompositionEnd, editor, data) {
      const domSelection = getDOMSelection(editor._window);
      if (domSelection === null) {
        return;
      }
      const anchorNode = domSelection.anchorNode;
      let {
        anchorOffset,
        focusOffset
      } = domSelection;
      if (anchorNode !== null) {
        let textContent = getAnchorTextFromDOM(anchorNode);
        const node = $getNearestNodeFromDOMNode(anchorNode);
        if (textContent !== null && $isTextNode2(node)) {
          if (textContent === COMPOSITION_SUFFIX && data) {
            const offset = data.length;
            textContent = data;
            anchorOffset = offset;
            focusOffset = offset;
          }
          if (textContent !== null) {
            $updateTextNodeFromDOMContent(node, textContent, anchorOffset, focusOffset, isCompositionEnd);
          }
        }
      }
    }
    function $updateTextNodeFromDOMContent(textNode, textContent, anchorOffset, focusOffset, compositionEnd) {
      let node = textNode;
      if (node.isAttached() && (compositionEnd || !node.isDirty())) {
        const isComposing = node.isComposing();
        let normalizedTextContent = textContent;
        if ((isComposing || compositionEnd) && textContent[textContent.length - 1] === COMPOSITION_SUFFIX) {
          normalizedTextContent = textContent.slice(0, -1);
        }
        const prevTextContent = node.getTextContent();
        if (compositionEnd || normalizedTextContent !== prevTextContent) {
          if (normalizedTextContent === "") {
            $setCompositionKey(null);
            if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT) {
              const editor = getActiveEditor();
              setTimeout(() => {
                editor.update(() => {
                  if (node.isAttached()) {
                    node.remove();
                  }
                });
              }, 20);
            } else {
              node.remove();
            }
            return;
          }
          const parent = node.getParent();
          const prevSelection = $getPreviousSelection();
          const prevTextContentSize = node.getTextContentSize();
          const compositionKey = $getCompositionKey();
          const nodeKey = node.getKey();
          if (node.isToken() || compositionKey !== null && nodeKey === compositionKey && !isComposing || // Check if character was added at the start or boundaries when not insertable, and we need
          // to clear this input from occurring as that action wasn't permitted.
          $isRangeSelection2(prevSelection) && (parent !== null && !parent.canInsertTextBefore() && prevSelection.anchor.offset === 0 || prevSelection.anchor.key === textNode.__key && prevSelection.anchor.offset === 0 && !node.canInsertTextBefore() || prevSelection.focus.key === textNode.__key && prevSelection.focus.offset === prevTextContentSize && !node.canInsertTextAfter())) {
            node.markDirty();
            return;
          }
          const selection = $getSelection2();
          if (!$isRangeSelection2(selection) || anchorOffset === null || focusOffset === null) {
            node.setTextContent(normalizedTextContent);
            return;
          }
          selection.setTextNodeRange(node, anchorOffset, node, focusOffset);
          if (node.isSegmented()) {
            const originalTextContent = node.getTextContent();
            const replacement = $createTextNode3(originalTextContent);
            node.replace(replacement);
            node = replacement;
          }
          node.setTextContent(normalizedTextContent);
        }
      }
    }
    function $previousSiblingDoesNotAcceptText(node) {
      const previousSibling = node.getPreviousSibling();
      return ($isTextNode2(previousSibling) || $isElementNode2(previousSibling) && previousSibling.isInline()) && !previousSibling.canInsertTextAfter();
    }
    function $shouldInsertTextAfterOrBeforeTextNode(selection, node) {
      if (node.isSegmented()) {
        return true;
      }
      if (!selection.isCollapsed()) {
        return false;
      }
      const offset = selection.anchor.offset;
      const parent = node.getParentOrThrow();
      const isToken = node.isToken();
      if (offset === 0) {
        return !node.canInsertTextBefore() || !parent.canInsertTextBefore() || isToken || $previousSiblingDoesNotAcceptText(node);
      } else if (offset === node.getTextContentSize()) {
        return !node.canInsertTextAfter() || !parent.canInsertTextAfter() || isToken;
      } else {
        return false;
      }
    }
    function isTab(keyCode, altKey, ctrlKey, metaKey) {
      return keyCode === 9 && !altKey && !ctrlKey && !metaKey;
    }
    function isBold(keyCode, altKey, metaKey, ctrlKey) {
      return keyCode === 66 && !altKey && controlOrMeta2(metaKey, ctrlKey);
    }
    function isItalic(keyCode, altKey, metaKey, ctrlKey) {
      return keyCode === 73 && !altKey && controlOrMeta2(metaKey, ctrlKey);
    }
    function isUnderline(keyCode, altKey, metaKey, ctrlKey) {
      return keyCode === 85 && !altKey && controlOrMeta2(metaKey, ctrlKey);
    }
    function isParagraph(keyCode, shiftKey) {
      return isReturn(keyCode) && !shiftKey;
    }
    function isLineBreak(keyCode, shiftKey) {
      return isReturn(keyCode) && shiftKey;
    }
    function isOpenLineBreak(keyCode, ctrlKey) {
      return IS_APPLE2 && ctrlKey && keyCode === 79;
    }
    function isDeleteWordBackward(keyCode, altKey, ctrlKey) {
      return isBackspace(keyCode) && (IS_APPLE2 ? altKey : ctrlKey);
    }
    function isDeleteWordForward(keyCode, altKey, ctrlKey) {
      return isDelete(keyCode) && (IS_APPLE2 ? altKey : ctrlKey);
    }
    function isDeleteLineBackward(keyCode, metaKey) {
      return IS_APPLE2 && metaKey && isBackspace(keyCode);
    }
    function isDeleteLineForward(keyCode, metaKey) {
      return IS_APPLE2 && metaKey && isDelete(keyCode);
    }
    function isDeleteBackward(keyCode, altKey, metaKey, ctrlKey) {
      if (IS_APPLE2) {
        if (altKey || metaKey) {
          return false;
        }
        return isBackspace(keyCode) || keyCode === 72 && ctrlKey;
      }
      if (ctrlKey || altKey || metaKey) {
        return false;
      }
      return isBackspace(keyCode);
    }
    function isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
      if (IS_APPLE2) {
        if (shiftKey || altKey || metaKey) {
          return false;
        }
        return isDelete(keyCode) || keyCode === 68 && ctrlKey;
      }
      if (ctrlKey || altKey || metaKey) {
        return false;
      }
      return isDelete(keyCode);
    }
    function isUndo(keyCode, shiftKey, metaKey, ctrlKey) {
      return keyCode === 90 && !shiftKey && controlOrMeta2(metaKey, ctrlKey);
    }
    function isRedo(keyCode, shiftKey, metaKey, ctrlKey) {
      if (IS_APPLE2) {
        return keyCode === 90 && metaKey && shiftKey;
      }
      return keyCode === 89 && ctrlKey || keyCode === 90 && ctrlKey && shiftKey;
    }
    function isCopy(keyCode, shiftKey, metaKey, ctrlKey) {
      if (shiftKey) {
        return false;
      }
      if (keyCode === 67) {
        return IS_APPLE2 ? metaKey : ctrlKey;
      }
      return false;
    }
    function isCut(keyCode, shiftKey, metaKey, ctrlKey) {
      if (shiftKey) {
        return false;
      }
      if (keyCode === 88) {
        return IS_APPLE2 ? metaKey : ctrlKey;
      }
      return false;
    }
    function isArrowLeft(keyCode) {
      return keyCode === 37;
    }
    function isArrowRight(keyCode) {
      return keyCode === 39;
    }
    function isArrowUp(keyCode) {
      return keyCode === 38;
    }
    function isArrowDown(keyCode) {
      return keyCode === 40;
    }
    function isMoveBackward(keyCode, ctrlKey, altKey, metaKey) {
      return isArrowLeft(keyCode) && !ctrlKey && !metaKey && !altKey;
    }
    function isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
      return isArrowLeft(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
    }
    function isMoveForward(keyCode, ctrlKey, altKey, metaKey) {
      return isArrowRight(keyCode) && !ctrlKey && !metaKey && !altKey;
    }
    function isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey) {
      return isArrowRight(keyCode) && !altKey && !shiftKey && (ctrlKey || metaKey);
    }
    function isMoveUp(keyCode, ctrlKey, metaKey) {
      return isArrowUp(keyCode) && !ctrlKey && !metaKey;
    }
    function isMoveDown(keyCode, ctrlKey, metaKey) {
      return isArrowDown(keyCode) && !ctrlKey && !metaKey;
    }
    function isModifier(ctrlKey, shiftKey, altKey, metaKey) {
      return ctrlKey || shiftKey || altKey || metaKey;
    }
    function isSpace(keyCode) {
      return keyCode === 32;
    }
    function controlOrMeta2(metaKey, ctrlKey) {
      if (IS_APPLE2) {
        return metaKey;
      }
      return ctrlKey;
    }
    function isReturn(keyCode) {
      return keyCode === 13;
    }
    function isBackspace(keyCode) {
      return keyCode === 8;
    }
    function isEscape(keyCode) {
      return keyCode === 27;
    }
    function isDelete(keyCode) {
      return keyCode === 46;
    }
    function isSelectAll(keyCode, metaKey, ctrlKey) {
      return keyCode === 65 && controlOrMeta2(metaKey, ctrlKey);
    }
    function $selectAll() {
      const root2 = $getRoot2();
      const selection = root2.select(0, root2.getChildrenSize());
      $setSelection2($normalizeSelection(selection));
    }
    function getCachedClassNameArray(classNamesTheme, classNameThemeType) {
      if (classNamesTheme.__lexicalClassNameCache === void 0) {
        classNamesTheme.__lexicalClassNameCache = {};
      }
      const classNamesCache = classNamesTheme.__lexicalClassNameCache;
      const cachedClassNames = classNamesCache[classNameThemeType];
      if (cachedClassNames !== void 0) {
        return cachedClassNames;
      }
      const classNames = classNamesTheme[classNameThemeType];
      if (typeof classNames === "string") {
        const classNamesArr = classNames.split(" ");
        classNamesCache[classNameThemeType] = classNamesArr;
        return classNamesArr;
      }
      return classNames;
    }
    function setMutatedNode(mutatedNodes2, registeredNodes, mutationListeners, node, mutation) {
      if (mutationListeners.size === 0) {
        return;
      }
      const nodeType = node.__type;
      const nodeKey = node.__key;
      const registeredNode = registeredNodes.get(nodeType);
      if (registeredNode === void 0) {
        {
          throw Error(`Type ${nodeType} not in registeredNodes`);
        }
      }
      const klass = registeredNode.klass;
      let mutatedNodesByType = mutatedNodes2.get(klass);
      if (mutatedNodesByType === void 0) {
        mutatedNodesByType = /* @__PURE__ */ new Map();
        mutatedNodes2.set(klass, mutatedNodesByType);
      }
      const prevMutation = mutatedNodesByType.get(nodeKey);
      const isMove = prevMutation === "destroyed" && mutation === "created";
      if (prevMutation === void 0 || isMove) {
        mutatedNodesByType.set(nodeKey, isMove ? "updated" : mutation);
      }
    }
    function $nodesOfType(klass) {
      const editorState = getActiveEditorState();
      const readOnly = editorState._readOnly;
      const klassType = klass.getType();
      const nodes = editorState._nodeMap;
      const nodesOfType = [];
      for (const [, node] of nodes) {
        if (node instanceof klass && node.__type === klassType && (readOnly || node.isAttached())) {
          nodesOfType.push(node);
        }
      }
      return nodesOfType;
    }
    function resolveElement(element, isBackward, focusOffset) {
      const parent = element.getParent();
      let offset = focusOffset;
      let block = element;
      if (parent !== null) {
        if (isBackward && focusOffset === 0) {
          offset = block.getIndexWithinParent();
          block = parent;
        } else if (!isBackward && focusOffset === block.getChildrenSize()) {
          offset = block.getIndexWithinParent() + 1;
          block = parent;
        }
      }
      return block.getChildAtIndex(isBackward ? offset - 1 : offset);
    }
    function $getAdjacentNode(focus, isBackward) {
      const focusOffset = focus.offset;
      if (focus.type === "element") {
        const block = focus.getNode();
        return resolveElement(block, isBackward, focusOffset);
      } else {
        const focusNode = focus.getNode();
        if (isBackward && focusOffset === 0 || !isBackward && focusOffset === focusNode.getTextContentSize()) {
          const possibleNode = isBackward ? focusNode.getPreviousSibling() : focusNode.getNextSibling();
          if (possibleNode === null) {
            return resolveElement(focusNode.getParentOrThrow(), isBackward, focusNode.getIndexWithinParent() + (isBackward ? 0 : 1));
          }
          return possibleNode;
        }
      }
      return null;
    }
    function isFirefoxClipboardEvents(editor) {
      const event = getWindow(editor).event;
      const inputType = event && event.inputType;
      return inputType === "insertFromPaste" || inputType === "insertFromPasteAsQuotation";
    }
    function dispatchCommand(editor, command, payload) {
      return triggerCommandListeners(editor, command, payload);
    }
    function $textContentRequiresDoubleLinebreakAtEnd(node) {
      return !$isRootNode2(node) && !node.isLastChild() && !node.isInline();
    }
    function getElementByKeyOrThrow(editor, key) {
      const element = editor._keyToDOMMap.get(key);
      if (element === void 0) {
        {
          throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
        }
      }
      return element;
    }
    function getParentElement(node) {
      const parentElement = node.assignedSlot || node.parentElement;
      return parentElement !== null && parentElement.nodeType === 11 ? parentElement.host : parentElement;
    }
    function scrollIntoViewIfNeeded(editor, selectionRect, rootElement) {
      const doc = rootElement.ownerDocument;
      const defaultView = doc.defaultView;
      if (defaultView === null) {
        return;
      }
      let {
        top: currentTop,
        bottom: currentBottom
      } = selectionRect;
      let targetTop = 0;
      let targetBottom = 0;
      let element = rootElement;
      while (element !== null) {
        const isBodyElement = element === doc.body;
        if (isBodyElement) {
          targetTop = 0;
          targetBottom = getWindow(editor).innerHeight;
        } else {
          const targetRect = element.getBoundingClientRect();
          targetTop = targetRect.top;
          targetBottom = targetRect.bottom;
        }
        let diff = 0;
        if (currentTop < targetTop) {
          diff = -(targetTop - currentTop);
        } else if (currentBottom > targetBottom) {
          diff = currentBottom - targetBottom;
        }
        if (diff !== 0) {
          if (isBodyElement) {
            defaultView.scrollBy(0, diff);
          } else {
            const scrollTop = element.scrollTop;
            element.scrollTop += diff;
            const yOffset = element.scrollTop - scrollTop;
            currentTop -= yOffset;
            currentBottom -= yOffset;
          }
        }
        if (isBodyElement) {
          break;
        }
        element = getParentElement(element);
      }
    }
    function $hasUpdateTag(tag) {
      const editor = getActiveEditor();
      return editor._updateTags.has(tag);
    }
    function $addUpdateTag(tag) {
      errorOnReadOnly();
      const editor = getActiveEditor();
      editor._updateTags.add(tag);
    }
    function $maybeMoveChildrenSelectionToParent(parentNode) {
      const selection = $getSelection2();
      if (!$isRangeSelection2(selection) || !$isElementNode2(parentNode)) {
        return selection;
      }
      const {
        anchor,
        focus
      } = selection;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if ($hasAncestor(anchorNode, parentNode)) {
        anchor.set(parentNode.__key, 0, "element");
      }
      if ($hasAncestor(focusNode, parentNode)) {
        focus.set(parentNode.__key, 0, "element");
      }
      return selection;
    }
    function $hasAncestor(child, targetNode) {
      let parent = child.getParent();
      while (parent !== null) {
        if (parent.is(targetNode)) {
          return true;
        }
        parent = parent.getParent();
      }
      return false;
    }
    function getDefaultView(domElem) {
      const ownerDoc = domElem.ownerDocument;
      return ownerDoc && ownerDoc.defaultView || null;
    }
    function getWindow(editor) {
      const windowObj = editor._window;
      if (windowObj === null) {
        {
          throw Error(`window object not found`);
        }
      }
      return windowObj;
    }
    function $isInlineElementOrDecoratorNode(node) {
      return $isElementNode2(node) && node.isInline() || $isDecoratorNode2(node) && node.isInline();
    }
    function $getNearestRootOrShadowRoot(node) {
      let parent = node.getParentOrThrow();
      while (parent !== null) {
        if ($isRootOrShadowRoot2(parent)) {
          return parent;
        }
        parent = parent.getParentOrThrow();
      }
      return parent;
    }
    function $isRootOrShadowRoot2(node) {
      return $isRootNode2(node) || $isElementNode2(node) && node.isShadowRoot();
    }
    function $copyNode(node) {
      const copy = node.constructor.clone(node);
      $setNodeKey(copy, null);
      return copy;
    }
    function $applyNodeReplacement(node) {
      const editor = getActiveEditor();
      const nodeType = node.constructor.getType();
      const registeredNode = editor._nodes.get(nodeType);
      if (registeredNode === void 0) {
        {
          throw Error(`$initializeNode failed. Ensure node has been registered to the editor. You can do this by passing the node class via the "nodes" array in the editor config.`);
        }
      }
      const replaceFunc = registeredNode.replace;
      if (replaceFunc !== null) {
        const replacementNode = replaceFunc(node);
        if (!(replacementNode instanceof node.constructor)) {
          {
            throw Error(`$initializeNode failed. Ensure replacement node is a subclass of the original node.`);
          }
        }
        return replacementNode;
      }
      return node;
    }
    function errorOnInsertTextNodeOnRoot(node, insertNode) {
      const parentNode = node.getParent();
      if ($isRootNode2(parentNode) && !$isElementNode2(insertNode) && !$isDecoratorNode2(insertNode)) {
        {
          throw Error(`Only element or decorator nodes can be inserted in to the root node`);
        }
      }
    }
    function createBlockCursorElement(editorConfig) {
      const theme = editorConfig.theme;
      const element = document.createElement("div");
      element.contentEditable = "false";
      element.setAttribute("data-lexical-cursor", "true");
      let blockCursorTheme = theme.blockCursor;
      if (blockCursorTheme !== void 0) {
        if (typeof blockCursorTheme === "string") {
          const classNamesArr = blockCursorTheme.split(" ");
          blockCursorTheme = theme.blockCursor = classNamesArr;
        }
        if (blockCursorTheme !== void 0) {
          element.classList.add(...blockCursorTheme);
        }
      }
      return element;
    }
    function needsBlockCursor(node) {
      return ($isDecoratorNode2(node) || $isElementNode2(node) && !node.canBeEmpty()) && !node.isInline();
    }
    function removeDOMBlockCursorElement(blockCursorElement, editor, rootElement) {
      rootElement.style.removeProperty("caret-color");
      editor._blockCursorElement = null;
      const parentElement = blockCursorElement.parentElement;
      if (parentElement !== null) {
        parentElement.removeChild(blockCursorElement);
      }
    }
    function updateDOMBlockCursorElement(editor, rootElement, nextSelection) {
      let blockCursorElement = editor._blockCursorElement;
      if ($isRangeSelection2(nextSelection) && nextSelection.isCollapsed() && nextSelection.anchor.type === "element" && rootElement.contains(document.activeElement)) {
        const anchor = nextSelection.anchor;
        const elementNode = anchor.getNode();
        const offset = anchor.offset;
        const elementNodeSize = elementNode.getChildrenSize();
        let isBlockCursor = false;
        let insertBeforeElement = null;
        if (offset === elementNodeSize) {
          const child = elementNode.getChildAtIndex(offset - 1);
          if (needsBlockCursor(child)) {
            isBlockCursor = true;
          }
        } else {
          const child = elementNode.getChildAtIndex(offset);
          if (needsBlockCursor(child)) {
            const sibling = child.getPreviousSibling();
            if (sibling === null || needsBlockCursor(sibling)) {
              isBlockCursor = true;
              insertBeforeElement = editor.getElementByKey(child.__key);
            }
          }
        }
        if (isBlockCursor) {
          const elementDOM = editor.getElementByKey(elementNode.__key);
          if (blockCursorElement === null) {
            editor._blockCursorElement = blockCursorElement = createBlockCursorElement(editor._config);
          }
          rootElement.style.caretColor = "transparent";
          if (insertBeforeElement === null) {
            elementDOM.appendChild(blockCursorElement);
          } else {
            elementDOM.insertBefore(blockCursorElement, insertBeforeElement);
          }
          return;
        }
      }
      if (blockCursorElement !== null) {
        removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
      }
    }
    function getDOMSelection(targetWindow) {
      return !CAN_USE_DOM2 ? null : (targetWindow || window).getSelection();
    }
    function $splitNode(node, offset) {
      let startNode = node.getChildAtIndex(offset);
      if (startNode == null) {
        startNode = node;
      }
      if (!!$isRootOrShadowRoot2(node)) {
        throw Error(`Can not call $splitNode() on root element`);
      }
      const recurse = (currentNode) => {
        const parent = currentNode.getParentOrThrow();
        const isParentRoot = $isRootOrShadowRoot2(parent);
        const nodeToMove = currentNode === startNode && !isParentRoot ? currentNode : $copyNode(currentNode);
        if (isParentRoot) {
          currentNode.insertAfter(nodeToMove);
          return [currentNode, nodeToMove, nodeToMove];
        } else {
          const [leftTree2, rightTree2, newParent] = recurse(parent);
          const nextSiblings = currentNode.getNextSiblings();
          newParent.append(nodeToMove, ...nextSiblings);
          return [leftTree2, rightTree2, nodeToMove];
        }
      };
      const [leftTree, rightTree] = recurse(startNode);
      return [leftTree, rightTree];
    }
    function $findMatchingParent2(startingNode, findFn) {
      let curr = startingNode;
      while (curr !== $getRoot2() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    }
    function $getChildrenRecursively(node) {
      const nodes = [];
      const stack = [node];
      while (stack.length > 0) {
        const currentNode = stack.pop();
        if (!(currentNode !== void 0)) {
          throw Error(`Stack.length > 0; can't be undefined`);
        }
        if ($isElementNode2(currentNode)) {
          stack.unshift(...currentNode.getChildren());
        }
        if (currentNode !== node) {
          nodes.push(currentNode);
        }
      }
      return nodes;
    }
    function isHTMLAnchorElement(x) {
      return isHTMLElement(x) && x.tagName === "A";
    }
    function isHTMLElement(x) {
      return x.nodeType === 1;
    }
    function $garbageCollectDetachedDecorators(editor, pendingEditorState) {
      const currentDecorators = editor._decorators;
      const pendingDecorators = editor._pendingDecorators;
      let decorators = pendingDecorators || currentDecorators;
      const nodeMap = pendingEditorState._nodeMap;
      let key;
      for (key in decorators) {
        if (!nodeMap.has(key)) {
          if (decorators === currentDecorators) {
            decorators = cloneDecorators(editor);
          }
          delete decorators[key];
        }
      }
    }
    function $garbageCollectDetachedDeepChildNodes(node, parentKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes) {
      let child = node.getFirstChild();
      while (child !== null) {
        const childKey = child.__key;
        if (child.__parent === parentKey) {
          if ($isElementNode2(child)) {
            $garbageCollectDetachedDeepChildNodes(child, childKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyNodes);
          }
          if (!prevNodeMap.has(childKey)) {
            dirtyNodes.delete(childKey);
          }
          nodeMapDelete.push(childKey);
        }
        child = child.getNextSibling();
      }
    }
    function $garbageCollectDetachedNodes(prevEditorState, editorState, dirtyLeaves, dirtyElements) {
      const prevNodeMap = prevEditorState._nodeMap;
      const nodeMap = editorState._nodeMap;
      const nodeMapDelete = [];
      for (const [nodeKey] of dirtyElements) {
        const node = nodeMap.get(nodeKey);
        if (node !== void 0) {
          if (!node.isAttached()) {
            if ($isElementNode2(node)) {
              $garbageCollectDetachedDeepChildNodes(node, nodeKey, prevNodeMap, nodeMap, nodeMapDelete, dirtyElements);
            }
            if (!prevNodeMap.has(nodeKey)) {
              dirtyElements.delete(nodeKey);
            }
            nodeMapDelete.push(nodeKey);
          }
        }
      }
      for (const nodeKey of nodeMapDelete) {
        nodeMap.delete(nodeKey);
      }
      for (const nodeKey of dirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if (node !== void 0 && !node.isAttached()) {
          if (!prevNodeMap.has(nodeKey)) {
            dirtyLeaves.delete(nodeKey);
          }
          nodeMap.delete(nodeKey);
        }
      }
    }
    var subTreeTextContent = "";
    var subTreeDirectionedTextContent = "";
    var editorTextContent = "";
    var activeEditorConfig;
    var activeEditor$1;
    var activeEditorNodes;
    var treatAllNodesAsDirty = false;
    var activeEditorStateReadOnly = false;
    var activeMutationListeners;
    var activeTextDirection = null;
    var activeDirtyElements;
    var activeDirtyLeaves;
    var activePrevNodeMap;
    var activeNextNodeMap;
    var activePrevKeyToDOMMap;
    var mutatedNodes;
    function destroyNode(key, parentDOM) {
      const node = activePrevNodeMap.get(key);
      if (parentDOM !== null) {
        const dom = getPrevElementByKeyOrThrow(key);
        if (dom.parentNode === parentDOM) {
          parentDOM.removeChild(dom);
        }
      }
      if (!activeNextNodeMap.has(key)) {
        activeEditor$1._keyToDOMMap.delete(key);
      }
      if ($isElementNode2(node)) {
        const children = createChildrenArray(node, activePrevNodeMap);
        destroyChildren(children, 0, children.length - 1, null);
      }
      if (node !== void 0) {
        setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "destroyed");
      }
    }
    function destroyChildren(children, _startIndex, endIndex, dom) {
      let startIndex = _startIndex;
      for (; startIndex <= endIndex; ++startIndex) {
        const child = children[startIndex];
        if (child !== void 0) {
          destroyNode(child, dom);
        }
      }
    }
    function setTextAlign(domStyle, value) {
      domStyle.setProperty("text-align", value);
    }
    var DEFAULT_INDENT_VALUE = "40px";
    function setElementIndent(dom, indent) {
      const indentClassName = activeEditorConfig.theme.indent;
      if (typeof indentClassName === "string") {
        const elementHasClassName = dom.classList.contains(indentClassName);
        if (indent > 0 && !elementHasClassName) {
          dom.classList.add(indentClassName);
        } else if (indent < 1 && elementHasClassName) {
          dom.classList.remove(indentClassName);
        }
      }
      const indentationBaseValue = getComputedStyle(dom).getPropertyValue("--lexical-indent-base-value") || DEFAULT_INDENT_VALUE;
      dom.style.setProperty("padding-inline-start", indent === 0 ? "" : `calc(${indent} * ${indentationBaseValue})`);
    }
    function setElementFormat(dom, format) {
      const domStyle = dom.style;
      if (format === 0) {
        setTextAlign(domStyle, "");
      } else if (format === IS_ALIGN_LEFT) {
        setTextAlign(domStyle, "left");
      } else if (format === IS_ALIGN_CENTER) {
        setTextAlign(domStyle, "center");
      } else if (format === IS_ALIGN_RIGHT) {
        setTextAlign(domStyle, "right");
      } else if (format === IS_ALIGN_JUSTIFY) {
        setTextAlign(domStyle, "justify");
      } else if (format === IS_ALIGN_START) {
        setTextAlign(domStyle, "start");
      } else if (format === IS_ALIGN_END) {
        setTextAlign(domStyle, "end");
      }
    }
    function createNode(key, parentDOM, insertDOM) {
      const node = activeNextNodeMap.get(key);
      if (node === void 0) {
        {
          throw Error(`createNode: node does not exist in nodeMap`);
        }
      }
      const dom = node.createDOM(activeEditorConfig, activeEditor$1);
      storeDOMWithKey(key, dom, activeEditor$1);
      if ($isTextNode2(node)) {
        dom.setAttribute("data-lexical-text", "true");
      } else if ($isDecoratorNode2(node)) {
        dom.setAttribute("data-lexical-decorator", "true");
      }
      if ($isElementNode2(node)) {
        const indent = node.__indent;
        const childrenSize = node.__size;
        if (indent !== 0) {
          setElementIndent(dom, indent);
        }
        if (childrenSize !== 0) {
          const endIndex = childrenSize - 1;
          const children = createChildrenArray(node, activeNextNodeMap);
          createChildrenWithDirection(children, endIndex, node, dom);
        }
        const format = node.__format;
        if (format !== 0) {
          setElementFormat(dom, format);
        }
        if (!node.isInline()) {
          reconcileElementTerminatingLineBreak(null, node, dom);
        }
        if ($textContentRequiresDoubleLinebreakAtEnd(node)) {
          subTreeTextContent += DOUBLE_LINE_BREAK;
          editorTextContent += DOUBLE_LINE_BREAK;
        }
      } else {
        const text2 = node.getTextContent();
        if ($isDecoratorNode2(node)) {
          const decorator = node.decorate(activeEditor$1, activeEditorConfig);
          if (decorator !== null) {
            reconcileDecorator(key, decorator);
          }
          dom.contentEditable = "false";
        } else if ($isTextNode2(node)) {
          if (!node.isDirectionless()) {
            subTreeDirectionedTextContent += text2;
          }
        }
        subTreeTextContent += text2;
        editorTextContent += text2;
      }
      if (parentDOM !== null) {
        if (insertDOM != null) {
          parentDOM.insertBefore(dom, insertDOM);
        } else {
          const possibleLineBreak = parentDOM.__lexicalLineBreak;
          if (possibleLineBreak != null) {
            parentDOM.insertBefore(dom, possibleLineBreak);
          } else {
            parentDOM.appendChild(dom);
          }
        }
      }
      {
        Object.freeze(node);
      }
      setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, node, "created");
      return dom;
    }
    function createChildrenWithDirection(children, endIndex, element, dom) {
      const previousSubTreeDirectionedTextContent = subTreeDirectionedTextContent;
      subTreeDirectionedTextContent = "";
      createChildren(children, element, 0, endIndex, dom, null);
      reconcileBlockDirection(element, dom);
      subTreeDirectionedTextContent = previousSubTreeDirectionedTextContent;
    }
    function createChildren(children, element, _startIndex, endIndex, dom, insertDOM) {
      const previousSubTreeTextContent = subTreeTextContent;
      subTreeTextContent = "";
      let startIndex = _startIndex;
      for (; startIndex <= endIndex; ++startIndex) {
        createNode(children[startIndex], dom, insertDOM);
      }
      if ($textContentRequiresDoubleLinebreakAtEnd(element)) {
        subTreeTextContent += DOUBLE_LINE_BREAK;
      }
      dom.__lexicalTextContent = subTreeTextContent;
      subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
    }
    function isLastChildLineBreakOrDecorator(childKey, nodeMap) {
      const node = nodeMap.get(childKey);
      return $isLineBreakNode2(node) || $isDecoratorNode2(node) && node.isInline();
    }
    function reconcileElementTerminatingLineBreak(prevElement, nextElement, dom) {
      const prevLineBreak = prevElement !== null && (prevElement.__size === 0 || isLastChildLineBreakOrDecorator(prevElement.__last, activePrevNodeMap));
      const nextLineBreak = nextElement.__size === 0 || isLastChildLineBreakOrDecorator(nextElement.__last, activeNextNodeMap);
      if (prevLineBreak) {
        if (!nextLineBreak) {
          const element = dom.__lexicalLineBreak;
          if (element != null) {
            dom.removeChild(element);
          }
          dom.__lexicalLineBreak = null;
        }
      } else if (nextLineBreak) {
        const element = document.createElement("br");
        dom.__lexicalLineBreak = element;
        dom.appendChild(element);
      }
    }
    function reconcileBlockDirection(element, dom) {
      const previousSubTreeDirectionTextContent = (
        // @ts-expect-error: internal field
        dom.__lexicalDirTextContent
      );
      const previousDirection = dom.__lexicalDir;
      if (previousSubTreeDirectionTextContent !== subTreeDirectionedTextContent || previousDirection !== activeTextDirection) {
        const hasEmptyDirectionedTextContent = subTreeDirectionedTextContent === "";
        const direction = hasEmptyDirectionedTextContent ? activeTextDirection : getTextDirection(subTreeDirectionedTextContent);
        if (direction !== previousDirection) {
          const classList = dom.classList;
          const theme = activeEditorConfig.theme;
          let previousDirectionTheme = previousDirection !== null ? theme[previousDirection] : void 0;
          let nextDirectionTheme = direction !== null ? theme[direction] : void 0;
          if (previousDirectionTheme !== void 0) {
            if (typeof previousDirectionTheme === "string") {
              const classNamesArr = previousDirectionTheme.split(" ");
              previousDirectionTheme = theme[previousDirection] = classNamesArr;
            }
            classList.remove(...previousDirectionTheme);
          }
          if (direction === null || hasEmptyDirectionedTextContent && direction === "ltr") {
            dom.removeAttribute("dir");
          } else {
            if (nextDirectionTheme !== void 0) {
              if (typeof nextDirectionTheme === "string") {
                const classNamesArr = nextDirectionTheme.split(" ");
                nextDirectionTheme = theme[direction] = classNamesArr;
              }
              if (nextDirectionTheme !== void 0) {
                classList.add(...nextDirectionTheme);
              }
            }
            dom.dir = direction;
          }
          if (!activeEditorStateReadOnly) {
            const writableNode = element.getWritable();
            writableNode.__dir = direction;
          }
        }
        activeTextDirection = direction;
        dom.__lexicalDirTextContent = subTreeDirectionedTextContent;
        dom.__lexicalDir = direction;
      }
    }
    function reconcileChildrenWithDirection(prevElement, nextElement, dom) {
      const previousSubTreeDirectionTextContent = subTreeDirectionedTextContent;
      subTreeDirectionedTextContent = "";
      reconcileChildren(prevElement, nextElement, dom);
      reconcileBlockDirection(nextElement, dom);
      subTreeDirectionedTextContent = previousSubTreeDirectionTextContent;
    }
    function createChildrenArray(element, nodeMap) {
      const children = [];
      let nodeKey = element.__first;
      while (nodeKey !== null) {
        const node = nodeMap.get(nodeKey);
        if (node === void 0) {
          {
            throw Error(`createChildrenArray: node does not exist in nodeMap`);
          }
        }
        children.push(nodeKey);
        nodeKey = node.__next;
      }
      return children;
    }
    function reconcileChildren(prevElement, nextElement, dom) {
      const previousSubTreeTextContent = subTreeTextContent;
      const prevChildrenSize = prevElement.__size;
      const nextChildrenSize = nextElement.__size;
      subTreeTextContent = "";
      if (prevChildrenSize === 1 && nextChildrenSize === 1) {
        const prevFirstChildKey = prevElement.__first;
        const nextFrstChildKey = nextElement.__first;
        if (prevFirstChildKey === nextFrstChildKey) {
          reconcileNode(prevFirstChildKey, dom);
        } else {
          const lastDOM = getPrevElementByKeyOrThrow(prevFirstChildKey);
          const replacementDOM = createNode(nextFrstChildKey, null, null);
          dom.replaceChild(replacementDOM, lastDOM);
          destroyNode(prevFirstChildKey, null);
        }
      } else {
        const prevChildren = createChildrenArray(prevElement, activePrevNodeMap);
        const nextChildren = createChildrenArray(nextElement, activeNextNodeMap);
        if (prevChildrenSize === 0) {
          if (nextChildrenSize !== 0) {
            createChildren(nextChildren, nextElement, 0, nextChildrenSize - 1, dom, null);
          }
        } else if (nextChildrenSize === 0) {
          if (prevChildrenSize !== 0) {
            const lexicalLineBreak = dom.__lexicalLineBreak;
            const canUseFastPath = lexicalLineBreak == null;
            destroyChildren(prevChildren, 0, prevChildrenSize - 1, canUseFastPath ? null : dom);
            if (canUseFastPath) {
              dom.textContent = "";
            }
          }
        } else {
          reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenSize, nextChildrenSize, dom);
        }
      }
      if ($textContentRequiresDoubleLinebreakAtEnd(nextElement)) {
        subTreeTextContent += DOUBLE_LINE_BREAK;
      }
      dom.__lexicalTextContent = subTreeTextContent;
      subTreeTextContent = previousSubTreeTextContent + subTreeTextContent;
    }
    function reconcileNode(key, parentDOM) {
      const prevNode = activePrevNodeMap.get(key);
      let nextNode = activeNextNodeMap.get(key);
      if (prevNode === void 0 || nextNode === void 0) {
        {
          throw Error(`reconcileNode: prevNode or nextNode does not exist in nodeMap`);
        }
      }
      const isDirty = treatAllNodesAsDirty || activeDirtyLeaves.has(key) || activeDirtyElements.has(key);
      const dom = getElementByKeyOrThrow(activeEditor$1, key);
      if (prevNode === nextNode && !isDirty) {
        if ($isElementNode2(prevNode)) {
          const previousSubTreeTextContent = dom.__lexicalTextContent;
          if (previousSubTreeTextContent !== void 0) {
            subTreeTextContent += previousSubTreeTextContent;
            editorTextContent += previousSubTreeTextContent;
          }
          const previousSubTreeDirectionTextContent = dom.__lexicalDirTextContent;
          if (previousSubTreeDirectionTextContent !== void 0) {
            subTreeDirectionedTextContent += previousSubTreeDirectionTextContent;
          }
        } else {
          const text2 = prevNode.getTextContent();
          if ($isTextNode2(prevNode) && !prevNode.isDirectionless()) {
            subTreeDirectionedTextContent += text2;
          }
          editorTextContent += text2;
          subTreeTextContent += text2;
        }
        return dom;
      }
      if (prevNode !== nextNode && isDirty) {
        setMutatedNode(mutatedNodes, activeEditorNodes, activeMutationListeners, nextNode, "updated");
      }
      if (nextNode.updateDOM(prevNode, dom, activeEditorConfig)) {
        const replacementDOM = createNode(key, null, null);
        if (parentDOM === null) {
          {
            throw Error(`reconcileNode: parentDOM is null`);
          }
        }
        parentDOM.replaceChild(replacementDOM, dom);
        destroyNode(key, null);
        return replacementDOM;
      }
      if ($isElementNode2(prevNode) && $isElementNode2(nextNode)) {
        const nextIndent = nextNode.__indent;
        if (nextIndent !== prevNode.__indent) {
          setElementIndent(dom, nextIndent);
        }
        const nextFormat = nextNode.__format;
        if (nextFormat !== prevNode.__format) {
          setElementFormat(dom, nextFormat);
        }
        if (isDirty) {
          reconcileChildrenWithDirection(prevNode, nextNode, dom);
          if (!$isRootNode2(nextNode) && !nextNode.isInline()) {
            reconcileElementTerminatingLineBreak(prevNode, nextNode, dom);
          }
        }
        if ($textContentRequiresDoubleLinebreakAtEnd(nextNode)) {
          subTreeTextContent += DOUBLE_LINE_BREAK;
          editorTextContent += DOUBLE_LINE_BREAK;
        }
      } else {
        const text2 = nextNode.getTextContent();
        if ($isDecoratorNode2(nextNode)) {
          const decorator = nextNode.decorate(activeEditor$1, activeEditorConfig);
          if (decorator !== null) {
            reconcileDecorator(key, decorator);
          }
        } else if ($isTextNode2(nextNode) && !nextNode.isDirectionless()) {
          subTreeDirectionedTextContent += text2;
        }
        subTreeTextContent += text2;
        editorTextContent += text2;
      }
      if (!activeEditorStateReadOnly && $isRootNode2(nextNode) && nextNode.__cachedText !== editorTextContent) {
        nextNode = nextNode.getWritable();
        nextNode.__cachedText = editorTextContent;
      }
      {
        Object.freeze(nextNode);
      }
      return dom;
    }
    function reconcileDecorator(key, decorator) {
      let pendingDecorators = activeEditor$1._pendingDecorators;
      const currentDecorators = activeEditor$1._decorators;
      if (pendingDecorators === null) {
        if (currentDecorators[key] === decorator) {
          return;
        }
        pendingDecorators = cloneDecorators(activeEditor$1);
      }
      pendingDecorators[key] = decorator;
    }
    function getFirstChild(element) {
      return element.firstChild;
    }
    function getNextSibling(element) {
      let nextSibling = element.nextSibling;
      if (nextSibling !== null && nextSibling === activeEditor$1._blockCursorElement) {
        nextSibling = nextSibling.nextSibling;
      }
      return nextSibling;
    }
    function reconcileNodeChildren(nextElement, prevChildren, nextChildren, prevChildrenLength, nextChildrenLength, dom) {
      const prevEndIndex = prevChildrenLength - 1;
      const nextEndIndex = nextChildrenLength - 1;
      let prevChildrenSet;
      let nextChildrenSet;
      let siblingDOM = getFirstChild(dom);
      let prevIndex = 0;
      let nextIndex = 0;
      while (prevIndex <= prevEndIndex && nextIndex <= nextEndIndex) {
        const prevKey = prevChildren[prevIndex];
        const nextKey = nextChildren[nextIndex];
        if (prevKey === nextKey) {
          siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
          prevIndex++;
          nextIndex++;
        } else {
          if (prevChildrenSet === void 0) {
            prevChildrenSet = new Set(prevChildren);
          }
          if (nextChildrenSet === void 0) {
            nextChildrenSet = new Set(nextChildren);
          }
          const nextHasPrevKey = nextChildrenSet.has(prevKey);
          const prevHasNextKey = prevChildrenSet.has(nextKey);
          if (!nextHasPrevKey) {
            siblingDOM = getNextSibling(getPrevElementByKeyOrThrow(prevKey));
            destroyNode(prevKey, dom);
            prevIndex++;
          } else if (!prevHasNextKey) {
            createNode(nextKey, dom, siblingDOM);
            nextIndex++;
          } else {
            const childDOM = getElementByKeyOrThrow(activeEditor$1, nextKey);
            if (childDOM === siblingDOM) {
              siblingDOM = getNextSibling(reconcileNode(nextKey, dom));
            } else {
              if (siblingDOM != null) {
                dom.insertBefore(childDOM, siblingDOM);
              } else {
                dom.appendChild(childDOM);
              }
              reconcileNode(nextKey, dom);
            }
            prevIndex++;
            nextIndex++;
          }
        }
      }
      const appendNewChildren = prevIndex > prevEndIndex;
      const removeOldChildren = nextIndex > nextEndIndex;
      if (appendNewChildren && !removeOldChildren) {
        const previousNode = nextChildren[nextEndIndex + 1];
        const insertDOM = previousNode === void 0 ? null : activeEditor$1.getElementByKey(previousNode);
        createChildren(nextChildren, nextElement, nextIndex, nextEndIndex, dom, insertDOM);
      } else if (removeOldChildren && !appendNewChildren) {
        destroyChildren(prevChildren, prevIndex, prevEndIndex, dom);
      }
    }
    function reconcileRoot(prevEditorState, nextEditorState, editor, dirtyType, dirtyElements, dirtyLeaves) {
      subTreeTextContent = "";
      editorTextContent = "";
      subTreeDirectionedTextContent = "";
      treatAllNodesAsDirty = dirtyType === FULL_RECONCILE;
      activeTextDirection = null;
      activeEditor$1 = editor;
      activeEditorConfig = editor._config;
      activeEditorNodes = editor._nodes;
      activeMutationListeners = activeEditor$1._listeners.mutation;
      activeDirtyElements = dirtyElements;
      activeDirtyLeaves = dirtyLeaves;
      activePrevNodeMap = prevEditorState._nodeMap;
      activeNextNodeMap = nextEditorState._nodeMap;
      activeEditorStateReadOnly = nextEditorState._readOnly;
      activePrevKeyToDOMMap = new Map(editor._keyToDOMMap);
      const currentMutatedNodes = /* @__PURE__ */ new Map();
      mutatedNodes = currentMutatedNodes;
      reconcileNode("root", null);
      activeEditor$1 = void 0;
      activeEditorNodes = void 0;
      activeDirtyElements = void 0;
      activeDirtyLeaves = void 0;
      activePrevNodeMap = void 0;
      activeNextNodeMap = void 0;
      activeEditorConfig = void 0;
      activePrevKeyToDOMMap = void 0;
      mutatedNodes = void 0;
      return currentMutatedNodes;
    }
    function storeDOMWithKey(key, dom, editor) {
      const keyToDOMMap = editor._keyToDOMMap;
      dom["__lexicalKey_" + editor._key] = key;
      keyToDOMMap.set(key, dom);
    }
    function getPrevElementByKeyOrThrow(key) {
      const element = activePrevKeyToDOMMap.get(key);
      if (element === void 0) {
        {
          throw Error(`Reconciliation: could not find DOM element for node key ${key}`);
        }
      }
      return element;
    }
    var PASS_THROUGH_COMMAND = Object.freeze({});
    var ANDROID_COMPOSITION_LATENCY = 30;
    var rootElementEvents = [["keydown", onKeyDown], ["pointerdown", onPointerDown], ["compositionstart", onCompositionStart], ["compositionend", onCompositionEnd], ["input", onInput], ["click", onClick], ["cut", PASS_THROUGH_COMMAND], ["copy", PASS_THROUGH_COMMAND], ["dragstart", PASS_THROUGH_COMMAND], ["dragover", PASS_THROUGH_COMMAND], ["dragend", PASS_THROUGH_COMMAND], ["paste", PASS_THROUGH_COMMAND], ["focus", PASS_THROUGH_COMMAND], ["blur", PASS_THROUGH_COMMAND], ["drop", PASS_THROUGH_COMMAND]];
    if (CAN_USE_BEFORE_INPUT) {
      rootElementEvents.push(["beforeinput", (event, editor) => onBeforeInput(event, editor)]);
    }
    var lastKeyDownTimeStamp = 0;
    var lastKeyCode = 0;
    var lastBeforeInputInsertTextTimeStamp = 0;
    var unprocessedBeforeInputData = null;
    var rootElementsRegistered = 0;
    var isSelectionChangeFromDOMUpdate = false;
    var isSelectionChangeFromMouseDown = false;
    var isInsertLineBreak = false;
    var isFirefoxEndingComposition = false;
    var collapsedSelectionFormat = [0, "", 0, "root", 0];
    function $shouldPreventDefaultAndInsertText(selection, domTargetRange, text2, timeStamp, isBeforeInput) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const editor = getActiveEditor();
      const domSelection = getDOMSelection(editor._window);
      const domAnchorNode = domSelection !== null ? domSelection.anchorNode : null;
      const anchorKey = anchor.key;
      const backingAnchorElement = editor.getElementByKey(anchorKey);
      const textLength = text2.length;
      return anchorKey !== focus.key || // If we're working with a non-text node.
      !$isTextNode2(anchorNode) || // If we are replacing a range with a single character or grapheme, and not composing.
      (!isBeforeInput && (!CAN_USE_BEFORE_INPUT || // We check to see if there has been
      // a recent beforeinput event for "textInput". If there has been one in the last
      // 50ms then we proceed as normal. However, if there is not, then this is likely
      // a dangling `input` event caused by execCommand('insertText').
      lastBeforeInputInsertTextTimeStamp < timeStamp + 50) || anchorNode.isDirty() && textLength < 2 || doesContainGrapheme(text2)) && anchor.offset !== focus.offset && !anchorNode.isComposing() || // Any non standard text node.
      $isTokenOrSegmented(anchorNode) || // If the text length is more than a single character and we're either
      // dealing with this in "beforeinput" or where the node has already recently
      // been changed (thus is dirty).
      anchorNode.isDirty() && textLength > 1 || // If the DOM selection element is not the same as the backing node during beforeinput.
      (isBeforeInput || !CAN_USE_BEFORE_INPUT) && backingAnchorElement !== null && !anchorNode.isComposing() && domAnchorNode !== getDOMTextNode(backingAnchorElement) || // If TargetRange is not the same as the DOM selection; browser trying to edit random parts
      // of the editor.
      domSelection !== null && domTargetRange !== null && (!domTargetRange.collapsed || domTargetRange.startContainer !== domSelection.anchorNode || domTargetRange.startOffset !== domSelection.anchorOffset) || // Check if we're changing from bold to italics, or some other format.
      anchorNode.getFormat() !== selection.format || anchorNode.getStyle() !== selection.style || // One last set of heuristics to check against.
      $shouldInsertTextAfterOrBeforeTextNode(selection, anchorNode);
    }
    function shouldSkipSelectionChange(domNode, offset) {
      return domNode !== null && domNode.nodeValue !== null && domNode.nodeType === DOM_TEXT_TYPE && offset !== 0 && offset !== domNode.nodeValue.length;
    }
    function onSelectionChange(domSelection, editor, isActive) {
      const {
        anchorNode: anchorDOM,
        anchorOffset,
        focusNode: focusDOM,
        focusOffset
      } = domSelection;
      if (isSelectionChangeFromDOMUpdate) {
        isSelectionChangeFromDOMUpdate = false;
        if (shouldSkipSelectionChange(anchorDOM, anchorOffset) && shouldSkipSelectionChange(focusDOM, focusOffset)) {
          return;
        }
      }
      updateEditor(editor, () => {
        if (!isActive) {
          $setSelection2(null);
          return;
        }
        if (!isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
          return;
        }
        const selection = $getSelection2();
        if ($isRangeSelection2(selection)) {
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          if (selection.isCollapsed()) {
            if (domSelection.type === "Range" && domSelection.anchorNode === domSelection.focusNode) {
              selection.dirty = true;
            }
            const windowEvent = getWindow(editor).event;
            const currentTimeStamp = windowEvent ? windowEvent.timeStamp : performance.now();
            const [lastFormat, lastStyle, lastOffset, lastKey, timeStamp] = collapsedSelectionFormat;
            if (currentTimeStamp < timeStamp + 200 && anchor.offset === lastOffset && anchor.key === lastKey) {
              selection.format = lastFormat;
              selection.style = lastStyle;
            } else {
              if (anchor.type === "text") {
                selection.format = anchorNode.getFormat();
                selection.style = anchorNode.getStyle();
              } else if (anchor.type === "element") {
                selection.format = 0;
                selection.style = "";
              }
            }
          } else {
            let combinedFormat = IS_ALL_FORMATTING;
            let hasTextNodes = false;
            const nodes = selection.getNodes();
            const nodesLength = nodes.length;
            for (let i = 0; i < nodesLength; i++) {
              const node = nodes[i];
              if ($isTextNode2(node)) {
                hasTextNodes = true;
                combinedFormat &= node.getFormat();
                if (combinedFormat === 0) {
                  break;
                }
              }
            }
            selection.format = hasTextNodes ? combinedFormat : 0;
          }
        }
        dispatchCommand(editor, SELECTION_CHANGE_COMMAND2, void 0);
      });
    }
    function onClick(event, editor) {
      updateEditor(editor, () => {
        const selection = $getSelection2();
        const domSelection = getDOMSelection(editor._window);
        const lastSelection = $getPreviousSelection();
        if (domSelection) {
          if ($isRangeSelection2(selection)) {
            const anchor = selection.anchor;
            const anchorNode = anchor.getNode();
            if (anchor.type === "element" && anchor.offset === 0 && selection.isCollapsed() && !$isRootNode2(anchorNode) && $getRoot2().getChildrenSize() === 1 && anchorNode.getTopLevelElementOrThrow().isEmpty() && lastSelection !== null && selection.is(lastSelection)) {
              domSelection.removeAllRanges();
              selection.dirty = true;
            } else if (event.detail === 3 && !selection.isCollapsed()) {
              const focus = selection.focus;
              const focusNode = focus.getNode();
              if (anchorNode !== focusNode) {
                if ($isElementNode2(anchorNode)) {
                  anchorNode.select(0);
                } else {
                  anchorNode.getParentOrThrow().select(0);
                }
              }
            }
          } else if (event.pointerType === "touch") {
            const domAnchorNode = domSelection.anchorNode;
            if (domAnchorNode !== null) {
              const nodeType = domAnchorNode.nodeType;
              if (nodeType === DOM_ELEMENT_TYPE || nodeType === DOM_TEXT_TYPE) {
                const newSelection = internalCreateRangeSelection(lastSelection, domSelection, editor);
                $setSelection2(newSelection);
              }
            }
          }
        }
        dispatchCommand(editor, CLICK_COMMAND, event);
      });
    }
    function onPointerDown(event, editor) {
      const target = event.target;
      const pointerType = event.pointerType;
      if (target instanceof Node && pointerType !== "touch") {
        updateEditor(editor, () => {
          if (!$isSelectionCapturedInDecorator(target)) {
            isSelectionChangeFromMouseDown = true;
          }
        });
      }
    }
    function getTargetRange(event) {
      if (!event.getTargetRanges) {
        return null;
      }
      const targetRanges = event.getTargetRanges();
      if (targetRanges.length === 0) {
        return null;
      }
      return targetRanges[0];
    }
    function $canRemoveText(anchorNode, focusNode) {
      return anchorNode !== focusNode || $isElementNode2(anchorNode) || $isElementNode2(focusNode) || !anchorNode.isToken() || !focusNode.isToken();
    }
    function isPossiblyAndroidKeyPress(timeStamp) {
      return lastKeyCode === 229 && timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY;
    }
    function onBeforeInput(event, editor) {
      const inputType = event.inputType;
      const targetRange = getTargetRange(event);
      if (inputType === "deleteCompositionText" || // If we're pasting in FF, we shouldn't get this event
      // as the `paste` event should have triggered, unless the
      // user has dom.event.clipboardevents.enabled disabled in
      // about:config. In that case, we need to process the
      // pasted content in the DOM mutation phase.
      IS_FIREFOX && isFirefoxClipboardEvents(editor)) {
        return;
      } else if (inputType === "insertCompositionText") {
        return;
      }
      updateEditor(editor, () => {
        const selection = $getSelection2();
        if (inputType === "deleteContentBackward") {
          if (selection === null) {
            const prevSelection = $getPreviousSelection();
            if (!$isRangeSelection2(prevSelection)) {
              return;
            }
            $setSelection2(prevSelection.clone());
          }
          if ($isRangeSelection2(selection)) {
            if (isPossiblyAndroidKeyPress(event.timeStamp) && editor.isComposing() && selection.anchor.key === selection.focus.key) {
              $setCompositionKey(null);
              lastKeyDownTimeStamp = 0;
              setTimeout(() => {
                updateEditor(editor, () => {
                  $setCompositionKey(null);
                });
              }, ANDROID_COMPOSITION_LATENCY);
              if ($isRangeSelection2(selection)) {
                const anchorNode2 = selection.anchor.getNode();
                anchorNode2.markDirty();
                selection.format = anchorNode2.getFormat();
                selection.style = anchorNode2.getStyle();
              }
            } else {
              event.preventDefault();
              dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
            }
            return;
          }
        }
        if (!$isRangeSelection2(selection)) {
          return;
        }
        const data = event.data;
        if (unprocessedBeforeInputData !== null) {
          $updateSelectedTextFromDOM(false, editor, unprocessedBeforeInputData);
        }
        if ((!selection.dirty || unprocessedBeforeInputData !== null) && selection.isCollapsed() && !$isRootNode2(selection.anchor.getNode()) && targetRange !== null) {
          selection.applyDOMRange(targetRange);
        }
        unprocessedBeforeInputData = null;
        const anchor = selection.anchor;
        const focus = selection.focus;
        const anchorNode = anchor.getNode();
        const focusNode = focus.getNode();
        if (inputType === "insertText" || inputType === "insertTranspose") {
          if (data === "\n") {
            event.preventDefault();
            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
          } else if (data === DOUBLE_LINE_BREAK) {
            event.preventDefault();
            dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
          } else if (data == null && event.dataTransfer) {
            const text2 = event.dataTransfer.getData("text/plain");
            event.preventDefault();
            selection.insertRawText(text2);
          } else if (data != null && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, true)) {
            event.preventDefault();
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
          } else {
            unprocessedBeforeInputData = data;
          }
          lastBeforeInputInsertTextTimeStamp = event.timeStamp;
          return;
        }
        event.preventDefault();
        switch (inputType) {
          case "insertFromYank":
          case "insertFromDrop":
          case "insertReplacementText": {
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
            break;
          }
          case "insertFromComposition": {
            $setCompositionKey(null);
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, event);
            break;
          }
          case "insertLineBreak": {
            $setCompositionKey(null);
            dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
            break;
          }
          case "insertParagraph": {
            $setCompositionKey(null);
            if (isInsertLineBreak && !IS_IOS) {
              isInsertLineBreak = false;
              dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, false);
            } else {
              dispatchCommand(editor, INSERT_PARAGRAPH_COMMAND, void 0);
            }
            break;
          }
          case "insertFromPaste":
          case "insertFromPasteAsQuotation": {
            dispatchCommand(editor, PASTE_COMMAND, event);
            break;
          }
          case "deleteByComposition": {
            if ($canRemoveText(anchorNode, focusNode)) {
              dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
            }
            break;
          }
          case "deleteByDrag":
          case "deleteByCut": {
            dispatchCommand(editor, REMOVE_TEXT_COMMAND, event);
            break;
          }
          case "deleteContent": {
            dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
            break;
          }
          case "deleteWordBackward": {
            dispatchCommand(editor, DELETE_WORD_COMMAND, true);
            break;
          }
          case "deleteWordForward": {
            dispatchCommand(editor, DELETE_WORD_COMMAND, false);
            break;
          }
          case "deleteHardLineBackward":
          case "deleteSoftLineBackward": {
            dispatchCommand(editor, DELETE_LINE_COMMAND, true);
            break;
          }
          case "deleteContentForward":
          case "deleteHardLineForward":
          case "deleteSoftLineForward": {
            dispatchCommand(editor, DELETE_LINE_COMMAND, false);
            break;
          }
          case "formatStrikeThrough": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "strikethrough");
            break;
          }
          case "formatBold": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "bold");
            break;
          }
          case "formatItalic": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "italic");
            break;
          }
          case "formatUnderline": {
            dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "underline");
            break;
          }
          case "historyUndo": {
            dispatchCommand(editor, UNDO_COMMAND, void 0);
            break;
          }
          case "historyRedo": {
            dispatchCommand(editor, REDO_COMMAND, void 0);
            break;
          }
        }
      });
    }
    function onInput(event, editor) {
      event.stopPropagation();
      updateEditor(editor, () => {
        const selection = $getSelection2();
        const data = event.data;
        const targetRange = getTargetRange(event);
        if (data != null && $isRangeSelection2(selection) && $shouldPreventDefaultAndInsertText(selection, targetRange, data, event.timeStamp, false)) {
          if (isFirefoxEndingComposition) {
            onCompositionEndImpl(editor, data);
            isFirefoxEndingComposition = false;
          }
          const anchor = selection.anchor;
          const anchorNode = anchor.getNode();
          const domSelection = getDOMSelection(editor._window);
          if (domSelection === null) {
            return;
          }
          const offset = anchor.offset;
          if (!CAN_USE_BEFORE_INPUT || selection.isCollapsed() || !$isTextNode2(anchorNode) || domSelection.anchorNode === null || anchorNode.getTextContent().slice(0, offset) + data + anchorNode.getTextContent().slice(offset + selection.focus.offset) !== getAnchorTextFromDOM(domSelection.anchorNode)) {
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, data);
          }
          const textLength = data.length;
          if (IS_FIREFOX && textLength > 1 && event.inputType === "insertCompositionText" && !editor.isComposing()) {
            selection.anchor.offset -= textLength;
          }
          if (!IS_SAFARI && !IS_IOS && !IS_APPLE_WEBKIT && editor.isComposing()) {
            lastKeyDownTimeStamp = 0;
            $setCompositionKey(null);
          }
        } else {
          const characterData = data !== null ? data : void 0;
          $updateSelectedTextFromDOM(false, editor, characterData);
          if (isFirefoxEndingComposition) {
            onCompositionEndImpl(editor, data || void 0);
            isFirefoxEndingComposition = false;
          }
        }
        $flushMutations();
      });
      unprocessedBeforeInputData = null;
    }
    function onCompositionStart(event, editor) {
      updateEditor(editor, () => {
        const selection = $getSelection2();
        if ($isRangeSelection2(selection) && !editor.isComposing()) {
          const anchor = selection.anchor;
          const node = selection.anchor.getNode();
          $setCompositionKey(anchor.key);
          if (
            // If it has been 30ms since the last keydown, then we should
            // apply the empty space heuristic. We can't do this for Safari,
            // as the keydown fires after composition start.
            event.timeStamp < lastKeyDownTimeStamp + ANDROID_COMPOSITION_LATENCY || // FF has issues around composing multibyte characters, so we also
            // need to invoke the empty space heuristic below.
            anchor.type === "element" || !selection.isCollapsed() || node.getFormat() !== selection.format || node.getStyle() !== selection.style
          ) {
            dispatchCommand(editor, CONTROLLED_TEXT_INSERTION_COMMAND, COMPOSITION_START_CHAR);
          }
        }
      });
    }
    function onCompositionEndImpl(editor, data) {
      const compositionKey = editor._compositionKey;
      $setCompositionKey(null);
      if (compositionKey !== null && data != null) {
        if (data === "") {
          const node = $getNodeByKey(compositionKey);
          const textNode = getDOMTextNode(editor.getElementByKey(compositionKey));
          if (textNode !== null && textNode.nodeValue !== null && $isTextNode2(node)) {
            $updateTextNodeFromDOMContent(node, textNode.nodeValue, null, null, true);
          }
          return;
        }
        if (data[data.length - 1] === "\n") {
          const selection = $getSelection2();
          if ($isRangeSelection2(selection)) {
            const focus = selection.focus;
            selection.anchor.set(focus.key, focus.offset, focus.type);
            dispatchCommand(editor, KEY_ENTER_COMMAND, null);
            return;
          }
        }
      }
      $updateSelectedTextFromDOM(true, editor, data);
    }
    function onCompositionEnd(event, editor) {
      if (IS_FIREFOX) {
        isFirefoxEndingComposition = true;
      } else {
        updateEditor(editor, () => {
          onCompositionEndImpl(editor, event.data);
        });
      }
    }
    function onKeyDown(event, editor) {
      lastKeyDownTimeStamp = event.timeStamp;
      lastKeyCode = event.keyCode;
      if (editor.isComposing()) {
        return;
      }
      const {
        keyCode,
        shiftKey,
        ctrlKey,
        metaKey,
        altKey
      } = event;
      if (dispatchCommand(editor, KEY_DOWN_COMMAND2, event)) {
        return;
      }
      if (isMoveForward(keyCode, ctrlKey, altKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_RIGHT_COMMAND, event);
      } else if (isMoveToEnd(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
        dispatchCommand(editor, MOVE_TO_END, event);
      } else if (isMoveBackward(keyCode, ctrlKey, altKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_LEFT_COMMAND, event);
      } else if (isMoveToStart(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
        dispatchCommand(editor, MOVE_TO_START, event);
      } else if (isMoveUp(keyCode, ctrlKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_UP_COMMAND, event);
      } else if (isMoveDown(keyCode, ctrlKey, metaKey)) {
        dispatchCommand(editor, KEY_ARROW_DOWN_COMMAND, event);
      } else if (isLineBreak(keyCode, shiftKey)) {
        isInsertLineBreak = true;
        dispatchCommand(editor, KEY_ENTER_COMMAND, event);
      } else if (isSpace(keyCode)) {
        dispatchCommand(editor, KEY_SPACE_COMMAND, event);
      } else if (isOpenLineBreak(keyCode, ctrlKey)) {
        event.preventDefault();
        isInsertLineBreak = true;
        dispatchCommand(editor, INSERT_LINE_BREAK_COMMAND, true);
      } else if (isParagraph(keyCode, shiftKey)) {
        isInsertLineBreak = false;
        dispatchCommand(editor, KEY_ENTER_COMMAND, event);
      } else if (isDeleteBackward(keyCode, altKey, metaKey, ctrlKey)) {
        if (isBackspace(keyCode)) {
          dispatchCommand(editor, KEY_BACKSPACE_COMMAND, event);
        } else {
          event.preventDefault();
          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, true);
        }
      } else if (isEscape(keyCode)) {
        dispatchCommand(editor, KEY_ESCAPE_COMMAND, event);
      } else if (isDeleteForward(keyCode, ctrlKey, shiftKey, altKey, metaKey)) {
        if (isDelete(keyCode)) {
          dispatchCommand(editor, KEY_DELETE_COMMAND, event);
        } else {
          event.preventDefault();
          dispatchCommand(editor, DELETE_CHARACTER_COMMAND, false);
        }
      } else if (isDeleteWordBackward(keyCode, altKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_WORD_COMMAND, true);
      } else if (isDeleteWordForward(keyCode, altKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_WORD_COMMAND, false);
      } else if (isDeleteLineBackward(keyCode, metaKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_LINE_COMMAND, true);
      } else if (isDeleteLineForward(keyCode, metaKey)) {
        event.preventDefault();
        dispatchCommand(editor, DELETE_LINE_COMMAND, false);
      } else if (isBold(keyCode, altKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "bold");
      } else if (isUnderline(keyCode, altKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "underline");
      } else if (isItalic(keyCode, altKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, FORMAT_TEXT_COMMAND2, "italic");
      } else if (isTab(keyCode, altKey, ctrlKey, metaKey)) {
        dispatchCommand(editor, KEY_TAB_COMMAND, event);
      } else if (isUndo(keyCode, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, UNDO_COMMAND, void 0);
      } else if (isRedo(keyCode, shiftKey, metaKey, ctrlKey)) {
        event.preventDefault();
        dispatchCommand(editor, REDO_COMMAND, void 0);
      } else {
        const prevSelection = editor._editorState._selection;
        if ($isNodeSelection(prevSelection)) {
          if (isCopy(keyCode, shiftKey, metaKey, ctrlKey)) {
            event.preventDefault();
            dispatchCommand(editor, COPY_COMMAND, event);
          } else if (isCut(keyCode, shiftKey, metaKey, ctrlKey)) {
            event.preventDefault();
            dispatchCommand(editor, CUT_COMMAND, event);
          } else if (isSelectAll(keyCode, metaKey, ctrlKey)) {
            event.preventDefault();
            dispatchCommand(editor, SELECT_ALL_COMMAND, event);
          }
        } else if (!IS_FIREFOX && isSelectAll(keyCode, metaKey, ctrlKey)) {
          event.preventDefault();
          dispatchCommand(editor, SELECT_ALL_COMMAND, event);
        }
      }
      if (isModifier(ctrlKey, shiftKey, altKey, metaKey)) {
        dispatchCommand(editor, KEY_MODIFIER_COMMAND, event);
      }
    }
    function getRootElementRemoveHandles(rootElement) {
      let eventHandles = rootElement.__lexicalEventHandles;
      if (eventHandles === void 0) {
        eventHandles = [];
        rootElement.__lexicalEventHandles = eventHandles;
      }
      return eventHandles;
    }
    var activeNestedEditorsMap = /* @__PURE__ */ new Map();
    function onDocumentSelectionChange(event) {
      const target = event.target;
      const targetWindow = target == null ? null : target.nodeType === 9 ? target.defaultView : target.ownerDocument.defaultView;
      const domSelection = getDOMSelection(targetWindow);
      if (domSelection === null) {
        return;
      }
      const nextActiveEditor = getNearestEditorFromDOMNode(domSelection.anchorNode);
      if (nextActiveEditor === null) {
        return;
      }
      if (isSelectionChangeFromMouseDown) {
        isSelectionChangeFromMouseDown = false;
        updateEditor(nextActiveEditor, () => {
          const lastSelection = $getPreviousSelection();
          const domAnchorNode = domSelection.anchorNode;
          if (domAnchorNode === null) {
            return;
          }
          const nodeType = domAnchorNode.nodeType;
          if (nodeType !== DOM_ELEMENT_TYPE && nodeType !== DOM_TEXT_TYPE) {
            return;
          }
          const newSelection = internalCreateRangeSelection(lastSelection, domSelection, nextActiveEditor);
          $setSelection2(newSelection);
        });
      }
      const editors = getEditorsToPropagate(nextActiveEditor);
      const rootEditor = editors[editors.length - 1];
      const rootEditorKey = rootEditor._key;
      const activeNestedEditor = activeNestedEditorsMap.get(rootEditorKey);
      const prevActiveEditor = activeNestedEditor || rootEditor;
      if (prevActiveEditor !== nextActiveEditor) {
        onSelectionChange(domSelection, prevActiveEditor, false);
      }
      onSelectionChange(domSelection, nextActiveEditor, true);
      if (nextActiveEditor !== rootEditor) {
        activeNestedEditorsMap.set(rootEditorKey, nextActiveEditor);
      } else if (activeNestedEditor) {
        activeNestedEditorsMap.delete(rootEditorKey);
      }
    }
    function stopLexicalPropagation(event) {
      event._lexicalHandled = true;
    }
    function hasStoppedLexicalPropagation(event) {
      const stopped = event._lexicalHandled === true;
      return stopped;
    }
    function addRootElementEvents(rootElement, editor) {
      if (rootElementsRegistered === 0) {
        const doc = rootElement.ownerDocument;
        doc.addEventListener("selectionchange", onDocumentSelectionChange);
      }
      rootElementsRegistered++;
      rootElement.__lexicalEditor = editor;
      const removeHandles = getRootElementRemoveHandles(rootElement);
      for (let i = 0; i < rootElementEvents.length; i++) {
        const [eventName, onEvent] = rootElementEvents[i];
        const eventHandler = typeof onEvent === "function" ? (event) => {
          if (hasStoppedLexicalPropagation(event)) {
            return;
          }
          stopLexicalPropagation(event);
          if (editor.isEditable()) {
            onEvent(event, editor);
          }
        } : (event) => {
          if (hasStoppedLexicalPropagation(event)) {
            return;
          }
          stopLexicalPropagation(event);
          if (editor.isEditable()) {
            switch (eventName) {
              case "cut":
                return dispatchCommand(editor, CUT_COMMAND, event);
              case "copy":
                return dispatchCommand(editor, COPY_COMMAND, event);
              case "paste":
                return dispatchCommand(editor, PASTE_COMMAND, event);
              case "dragstart":
                return dispatchCommand(editor, DRAGSTART_COMMAND, event);
              case "dragover":
                return dispatchCommand(editor, DRAGOVER_COMMAND, event);
              case "dragend":
                return dispatchCommand(editor, DRAGEND_COMMAND, event);
              case "focus":
                return dispatchCommand(editor, FOCUS_COMMAND, event);
              case "blur": {
                return dispatchCommand(editor, BLUR_COMMAND2, event);
              }
              case "drop":
                return dispatchCommand(editor, DROP_COMMAND, event);
            }
          }
        };
        rootElement.addEventListener(eventName, eventHandler);
        removeHandles.push(() => {
          rootElement.removeEventListener(eventName, eventHandler);
        });
      }
    }
    function removeRootElementEvents(rootElement) {
      if (rootElementsRegistered !== 0) {
        rootElementsRegistered--;
        if (rootElementsRegistered === 0) {
          const doc = rootElement.ownerDocument;
          doc.removeEventListener("selectionchange", onDocumentSelectionChange);
        }
      }
      const editor = rootElement.__lexicalEditor;
      if (editor !== null && editor !== void 0) {
        cleanActiveNestedEditorsMap(editor);
        rootElement.__lexicalEditor = null;
      }
      const removeHandles = getRootElementRemoveHandles(rootElement);
      for (let i = 0; i < removeHandles.length; i++) {
        removeHandles[i]();
      }
      rootElement.__lexicalEventHandles = [];
    }
    function cleanActiveNestedEditorsMap(editor) {
      if (editor._parentEditor !== null) {
        const editors = getEditorsToPropagate(editor);
        const rootEditor = editors[editors.length - 1];
        const rootEditorKey = rootEditor._key;
        if (activeNestedEditorsMap.get(rootEditorKey) === editor) {
          activeNestedEditorsMap.delete(rootEditorKey);
        }
      } else {
        activeNestedEditorsMap.delete(editor._key);
      }
    }
    function markSelectionChangeFromDOMUpdate() {
      isSelectionChangeFromDOMUpdate = true;
    }
    function markCollapsedSelectionFormat(format, style, offset, key, timeStamp) {
      collapsedSelectionFormat = [format, style, offset, key, timeStamp];
    }
    function removeNode(nodeToRemove, restoreSelection, preserveEmptyParent) {
      errorOnReadOnly();
      const key = nodeToRemove.__key;
      const parent = nodeToRemove.getParent();
      if (parent === null) {
        return;
      }
      const selection = $maybeMoveChildrenSelectionToParent(nodeToRemove);
      let selectionMoved = false;
      if ($isRangeSelection2(selection) && restoreSelection) {
        const anchor = selection.anchor;
        const focus = selection.focus;
        if (anchor.key === key) {
          moveSelectionPointToSibling(anchor, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
          selectionMoved = true;
        }
        if (focus.key === key) {
          moveSelectionPointToSibling(focus, nodeToRemove, parent, nodeToRemove.getPreviousSibling(), nodeToRemove.getNextSibling());
          selectionMoved = true;
        }
      } else if ($isNodeSelection(selection) && restoreSelection && nodeToRemove.isSelected()) {
        nodeToRemove.selectPrevious();
      }
      if ($isRangeSelection2(selection) && restoreSelection && !selectionMoved) {
        const index = nodeToRemove.getIndexWithinParent();
        removeFromParent(nodeToRemove);
        $updateElementSelectionOnCreateDeleteNode(selection, parent, index, -1);
      } else {
        removeFromParent(nodeToRemove);
      }
      if (!preserveEmptyParent && !$isRootOrShadowRoot2(parent) && !parent.canBeEmpty() && parent.isEmpty()) {
        removeNode(parent, restoreSelection);
      }
      if (restoreSelection && $isRootNode2(parent) && parent.isEmpty()) {
        parent.selectEnd();
      }
    }
    var LexicalNode = class {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      // Flow doesn't support abstract classes unfortunately, so we can't _force_
      // subclasses of Node to implement statics. All subclasses of Node should have
      // a static getType and clone method though. We define getType and clone here so we can call it
      // on any  Node, and we throw this error by default since the subclass should provide
      // their own implementation.
      /**
       * Returns the string type of this node. Every node must
       * implement this and it MUST BE UNIQUE amongst nodes registered
       * on the editor.
       *
       */
      static getType() {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .getType().`);
        }
      }
      /**
       * Clones this node, creating a new node with a different key
       * and adding it to the EditorState (but not attaching it anywhere!). All nodes must
       * implement this method.
       *
       */
      static clone(_data) {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .clone().`);
        }
      }
      constructor(key) {
        this.__type = this.constructor.getType();
        this.__parent = null;
        this.__prev = null;
        this.__next = null;
        $setNodeKey(this, key);
        {
          if (this.__type !== "root") {
            errorOnReadOnly();
            errorOnTypeKlassMismatch(
              this.__type,
              // @ts-expect-error
              this.constructor
            );
          }
        }
      }
      // Getters and Traversers
      /**
       * Returns the string type of this node.
       */
      getType() {
        return this.__type;
      }
      /**
       * Returns true if there is a path between this node and the RootNode, false otherwise.
       * This is a way of determining if the node is "attached" EditorState. Unattached nodes
       * won't be reconciled and will ultimatelt be cleaned up by the Lexical GC.
       */
      isAttached() {
        let nodeKey = this.__key;
        while (nodeKey !== null) {
          if (nodeKey === "root") {
            return true;
          }
          const node = $getNodeByKey(nodeKey);
          if (node === null) {
            break;
          }
          nodeKey = node.__parent;
        }
        return false;
      }
      /**
       * Returns true if this node is contained within the provided Selection., false otherwise.
       * Relies on the algorithms implemented in {@link BaseSelection.getNodes} to determine
       * what's included.
       *
       * @param selection - The selection that we want to determine if the node is in.
       */
      isSelected(selection) {
        const targetSelection = selection || $getSelection2();
        if (targetSelection == null) {
          return false;
        }
        const isSelected = targetSelection.getNodes().some((n) => n.__key === this.__key);
        if ($isTextNode2(this)) {
          return isSelected;
        }
        if ($isRangeSelection2(targetSelection) && targetSelection.anchor.type === "element" && targetSelection.focus.type === "element" && targetSelection.anchor.key === targetSelection.focus.key && targetSelection.anchor.offset === targetSelection.focus.offset) {
          return false;
        }
        return isSelected;
      }
      /**
       * Returns this nodes key.
       */
      getKey() {
        return this.__key;
      }
      /**
       * Returns the zero-based index of this node within the parent.
       */
      getIndexWithinParent() {
        const parent = this.getParent();
        if (parent === null) {
          return -1;
        }
        let node = parent.getFirstChild();
        let index = 0;
        while (node !== null) {
          if (this.is(node)) {
            return index;
          }
          index++;
          node = node.getNextSibling();
        }
        return -1;
      }
      /**
       * Returns the parent of this node, or null if none is found.
       */
      getParent() {
        const parent = this.getLatest().__parent;
        if (parent === null) {
          return null;
        }
        return $getNodeByKey(parent);
      }
      /**
       * Returns the parent of this node, or throws if none is found.
       */
      getParentOrThrow() {
        const parent = this.getParent();
        if (parent === null) {
          {
            throw Error(`Expected node ${this.__key} to have a parent.`);
          }
        }
        return parent;
      }
      /**
       * Returns the highest (in the EditorState tree)
       * non-root ancestor of this node, or null if none is found. See {@link lexical!$isRootOrShadowRoot}
       * for more information on which Elements comprise "roots".
       */
      getTopLevelElement() {
        let node = this;
        while (node !== null) {
          const parent = node.getParent();
          if ($isRootOrShadowRoot2(parent)) {
            return node;
          }
          node = parent;
        }
        return null;
      }
      /**
       * Returns the highest (in the EditorState tree)
       * non-root ancestor of this node, or throws if none is found. See {@link lexical!$isRootOrShadowRoot}
       * for more information on which Elements comprise "roots".
       */
      getTopLevelElementOrThrow() {
        const parent = this.getTopLevelElement();
        if (parent === null) {
          {
            throw Error(`Expected node ${this.__key} to have a top parent element.`);
          }
        }
        return parent;
      }
      /**
       * Returns a list of the every ancestor of this node,
       * all the way up to the RootNode.
       *
       */
      getParents() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node);
          node = node.getParent();
        }
        return parents;
      }
      /**
       * Returns a list of the keys of every ancestor of this node,
       * all the way up to the RootNode.
       *
       */
      getParentKeys() {
        const parents = [];
        let node = this.getParent();
        while (node !== null) {
          parents.push(node.__key);
          node = node.getParent();
        }
        return parents;
      }
      /**
       * Returns the "previous" siblings - that is, the node that comes
       * before this one in the same parent.
       *
       */
      getPreviousSibling() {
        const self = this.getLatest();
        const prevKey = self.__prev;
        return prevKey === null ? null : $getNodeByKey(prevKey);
      }
      /**
       * Returns the "previous" siblings - that is, the nodes that come between
       * this one and the first child of it's parent, inclusive.
       *
       */
      getPreviousSiblings() {
        const siblings = [];
        const parent = this.getParent();
        if (parent === null) {
          return siblings;
        }
        let node = parent.getFirstChild();
        while (node !== null) {
          if (node.is(this)) {
            break;
          }
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      /**
       * Returns the "next" siblings - that is, the node that comes
       * after this one in the same parent
       *
       */
      getNextSibling() {
        const self = this.getLatest();
        const nextKey = self.__next;
        return nextKey === null ? null : $getNodeByKey(nextKey);
      }
      /**
       * Returns all "next" siblings - that is, the nodes that come between this
       * one and the last child of it's parent, inclusive.
       *
       */
      getNextSiblings() {
        const siblings = [];
        let node = this.getNextSibling();
        while (node !== null) {
          siblings.push(node);
          node = node.getNextSibling();
        }
        return siblings;
      }
      /**
       * Returns the closest common ancestor of this node and the provided one or null
       * if one cannot be found.
       *
       * @param node - the other node to find the common ancestor of.
       */
      getCommonAncestor(node) {
        const a = this.getParents();
        const b = node.getParents();
        if ($isElementNode2(this)) {
          a.unshift(this);
        }
        if ($isElementNode2(node)) {
          b.unshift(node);
        }
        const aLength = a.length;
        const bLength = b.length;
        if (aLength === 0 || bLength === 0 || a[aLength - 1] !== b[bLength - 1]) {
          return null;
        }
        const bSet = new Set(b);
        for (let i = 0; i < aLength; i++) {
          const ancestor = a[i];
          if (bSet.has(ancestor)) {
            return ancestor;
          }
        }
        return null;
      }
      /**
       * Returns true if the provided node is the exact same one as this node, from Lexical's perspective.
       * Always use this instead of referential equality.
       *
       * @param object - the node to perform the equality comparison on.
       */
      is(object) {
        if (object == null) {
          return false;
        }
        return this.__key === object.__key;
      }
      /**
       * Returns true if this node logical precedes the target node in the editor state.
       *
       * @param targetNode - the node we're testing to see if it's after this one.
       */
      isBefore(targetNode) {
        if (this === targetNode) {
          return false;
        }
        if (targetNode.isParentOf(this)) {
          return true;
        }
        if (this.isParentOf(targetNode)) {
          return false;
        }
        const commonAncestor = this.getCommonAncestor(targetNode);
        let indexA = 0;
        let indexB = 0;
        let node = this;
        while (true) {
          const parent = node.getParentOrThrow();
          if (parent === commonAncestor) {
            indexA = node.getIndexWithinParent();
            break;
          }
          node = parent;
        }
        node = targetNode;
        while (true) {
          const parent = node.getParentOrThrow();
          if (parent === commonAncestor) {
            indexB = node.getIndexWithinParent();
            break;
          }
          node = parent;
        }
        return indexA < indexB;
      }
      /**
       * Returns true if this node is the parent of the target node, false otherwise.
       *
       * @param targetNode - the would-be child node.
       */
      isParentOf(targetNode) {
        const key = this.__key;
        if (key === targetNode.__key) {
          return false;
        }
        let node = targetNode;
        while (node !== null) {
          if (node.__key === key) {
            return true;
          }
          node = node.getParent();
        }
        return false;
      }
      // TO-DO: this function can be simplified a lot
      /**
       * Returns a list of nodes that are between this node and
       * the target node in the EditorState.
       *
       * @param targetNode - the node that marks the other end of the range of nodes to be returned.
       */
      getNodesBetween(targetNode) {
        const isBefore = this.isBefore(targetNode);
        const nodes = [];
        const visited = /* @__PURE__ */ new Set();
        let node = this;
        while (true) {
          const key = node.__key;
          if (!visited.has(key)) {
            visited.add(key);
            nodes.push(node);
          }
          if (node === targetNode) {
            break;
          }
          const child = $isElementNode2(node) ? isBefore ? node.getFirstChild() : node.getLastChild() : null;
          if (child !== null) {
            node = child;
            continue;
          }
          const nextSibling = isBefore ? node.getNextSibling() : node.getPreviousSibling();
          if (nextSibling !== null) {
            node = nextSibling;
            continue;
          }
          const parent = node.getParentOrThrow();
          if (!visited.has(parent.__key)) {
            nodes.push(parent);
          }
          if (parent === targetNode) {
            break;
          }
          let parentSibling = null;
          let ancestor = parent;
          do {
            if (ancestor === null) {
              {
                throw Error(`getNodesBetween: ancestor is null`);
              }
            }
            parentSibling = isBefore ? ancestor.getNextSibling() : ancestor.getPreviousSibling();
            ancestor = ancestor.getParent();
            if (ancestor !== null) {
              if (parentSibling === null && !visited.has(ancestor.__key)) {
                nodes.push(ancestor);
              }
            }
          } while (parentSibling === null);
          node = parentSibling;
        }
        if (!isBefore) {
          nodes.reverse();
        }
        return nodes;
      }
      /**
       * Returns true if this node has been marked dirty during this update cycle.
       *
       */
      isDirty() {
        const editor = getActiveEditor();
        const dirtyLeaves = editor._dirtyLeaves;
        return dirtyLeaves !== null && dirtyLeaves.has(this.__key);
      }
      /**
       * Returns the latest version of the node from the active EditorState.
       * This is used to avoid getting values from stale node references.
       *
       */
      getLatest() {
        const latest = $getNodeByKey(this.__key);
        if (latest === null) {
          {
            throw Error(`Lexical node does not exist in active editor state. Avoid using the same node references between nested closures from editorState.read/editor.update.`);
          }
        }
        return latest;
      }
      /**
       * Returns a mutable version of the node. Will throw an error if
       * called outside of a Lexical Editor {@link LexicalEditor.update} callback.
       *
       */
      getWritable() {
        errorOnReadOnly();
        const editorState = getActiveEditorState();
        const editor = getActiveEditor();
        const nodeMap = editorState._nodeMap;
        const key = this.__key;
        const latestNode = this.getLatest();
        const parent = latestNode.__parent;
        const cloneNotNeeded = editor._cloneNotNeeded;
        const selection = $getSelection2();
        if (selection !== null) {
          selection._cachedNodes = null;
        }
        if (cloneNotNeeded.has(key)) {
          internalMarkNodeAsDirty(latestNode);
          return latestNode;
        }
        const constructor = latestNode.constructor;
        const mutableNode = constructor.clone(latestNode);
        mutableNode.__parent = parent;
        mutableNode.__next = latestNode.__next;
        mutableNode.__prev = latestNode.__prev;
        if ($isElementNode2(latestNode) && $isElementNode2(mutableNode)) {
          mutableNode.__first = latestNode.__first;
          mutableNode.__last = latestNode.__last;
          mutableNode.__size = latestNode.__size;
          mutableNode.__indent = latestNode.__indent;
          mutableNode.__format = latestNode.__format;
          mutableNode.__dir = latestNode.__dir;
        } else if ($isTextNode2(latestNode) && $isTextNode2(mutableNode)) {
          mutableNode.__format = latestNode.__format;
          mutableNode.__style = latestNode.__style;
          mutableNode.__mode = latestNode.__mode;
          mutableNode.__detail = latestNode.__detail;
        }
        cloneNotNeeded.add(key);
        mutableNode.__key = key;
        internalMarkNodeAsDirty(mutableNode);
        nodeMap.set(key, mutableNode);
        return mutableNode;
      }
      /**
       * Returns the text content of the node. Override this for
       * custom nodes that should have a representation in plain text
       * format (for copy + paste, for example)
       *
       */
      getTextContent() {
        return "";
      }
      /**
       * Returns the length of the string produced by calling getTextContent on this node.
       *
       */
      getTextContentSize() {
        return this.getTextContent().length;
      }
      // View
      /**
       * Called during the reconciliation process to determine which nodes
       * to insert into the DOM for this Lexical Node.
       *
       * This method must return exactly one HTMLElement. Nested elements are not supported.
       *
       * Do not attempt to update the Lexical EditorState during this phase of the update lifecyle.
       *
       * @param _config - allows access to things like the EditorTheme (to apply classes) during reconciliation.
       * @param _editor - allows access to the editor for context during reconciliation.
       *
       * */
      createDOM(_config, _editor) {
        {
          throw Error(`createDOM: base method not extended`);
        }
      }
      /**
       * Called when a node changes and should update the DOM
       * in whatever way is necessary to make it align with any changes that might
       * have happened during the update.
       *
       * Returning "true" here will cause lexical to unmount and recreate the DOM node
       * (by calling createDOM). You would need to do this if the element tag changes,
       * for instance.
       *
       * */
      updateDOM(_prevNode, _dom, _config) {
        {
          throw Error(`updateDOM: base method not extended`);
        }
      }
      /**
       * Controls how the this node is serialized to HTML. This is important for
       * copy and paste between Lexical and non-Lexical editors, or Lexical editors with different namespaces,
       * in which case the primary transfer format is HTML. It's also important if you're serializing
       * to HTML for any other reason via {@link @lexical/html!$generateHtmlFromNodes}. You could
       * also use this method to build your own HTML renderer.
       *
       * */
      exportDOM(editor) {
        const element = this.createDOM(editor._config, editor);
        return {
          element
        };
      }
      /**
       * Controls how the this node is serialized to JSON. This is important for
       * copy and paste between Lexical editors sharing the same namespace. It's also important
       * if you're serializing to JSON for persistent storage somewhere.
       * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
       *
       * */
      exportJSON() {
        {
          throw Error(`exportJSON: base method not extended`);
        }
      }
      /**
       * Controls how the this node is deserialized from JSON. This is usually boilerplate,
       * but provides an abstraction between the node implementation and serialized interface that can
       * be important if you ever make breaking changes to a node schema (by adding or removing properties).
       * See [Serialization & Deserialization](https://lexical.dev/docs/concepts/serialization#lexical---html).
       *
       * */
      static importJSON(_serializedNode) {
        {
          throw Error(`LexicalNode: Node ${this.name} does not implement .importJSON().`);
        }
      }
      /**
       * @experimental
       *
       * Registers the returned function as a transform on the node during
       * Editor initialization. Most such use cases should be addressed via
       * the {@link LexicalEditor.registerNodeTransform} API.
       *
       * Experimental - use at your own risk.
       */
      static transform() {
        return null;
      }
      // Setters and mutators
      /**
       * Removes this LexicalNode from the EditorState. If the node isn't re-inserted
       * somewhere, the Lexical garbage collector will eventually clean it up.
       *
       * @param preserveEmptyParent - If falsy, the node's parent will be removed if
       * it's empty after the removal operation. This is the default behavior, subject to
       * other node heuristics such as {@link ElementNode#canBeEmpty}
       * */
      remove(preserveEmptyParent) {
        removeNode(this, true, preserveEmptyParent);
      }
      /**
       * Replaces this LexicalNode with the provided node, optionally transferring the children
       * of the replaced node to the replacing node.
       *
       * @param replaceWith - The node to replace this one with.
       * @param includeChildren - Whether or not to transfer the children of this node to the replacing node.
       * */
      replace(replaceWith, includeChildren) {
        errorOnReadOnly();
        let selection = $getSelection2();
        if (selection !== null)
          selection = selection.clone();
        errorOnInsertTextNodeOnRoot(this, replaceWith);
        const self = this.getLatest();
        const toReplaceKey = this.__key;
        const key = replaceWith.__key;
        const writableReplaceWith = replaceWith.getWritable();
        const writableParent = this.getParentOrThrow().getWritable();
        const size = writableParent.__size;
        removeFromParent(writableReplaceWith);
        const prevSibling = self.getPreviousSibling();
        const nextSibling = self.getNextSibling();
        const prevKey = self.__prev;
        const nextKey = self.__next;
        const parentKey = self.__parent;
        removeNode(self, false, true);
        if (prevSibling === null) {
          writableParent.__first = key;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = key;
        }
        writableReplaceWith.__prev = prevKey;
        if (nextSibling === null) {
          writableParent.__last = key;
        } else {
          const writableNextSibling = nextSibling.getWritable();
          writableNextSibling.__prev = key;
        }
        writableReplaceWith.__next = nextKey;
        writableReplaceWith.__parent = parentKey;
        writableParent.__size = size;
        if (includeChildren) {
          this.getChildren().forEach((child) => {
            writableReplaceWith.append(child);
          });
        }
        if ($isRangeSelection2(selection)) {
          $setSelection2(selection);
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor.key === toReplaceKey) {
            $moveSelectionPointToEnd(anchor, writableReplaceWith);
          }
          if (focus.key === toReplaceKey) {
            $moveSelectionPointToEnd(focus, writableReplaceWith);
          }
        }
        if ($getCompositionKey() === toReplaceKey) {
          $setCompositionKey(key);
        }
        return writableReplaceWith;
      }
      /**
       * Inserts a node after this LexicalNode (as the next sibling).
       *
       * @param nodeToInsert - The node to insert after this one.
       * @param restoreSelection - Whether or not to attempt to resolve the
       * selection to the appropriate place after the operation is complete.
       * */
      insertAfter(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const oldParent = writableNodeToInsert.getParent();
        const selection = $getSelection2();
        let elementAnchorSelectionOnNode = false;
        let elementFocusSelectionOnNode = false;
        if (oldParent !== null) {
          const oldIndex = nodeToInsert.getIndexWithinParent();
          removeFromParent(writableNodeToInsert);
          if ($isRangeSelection2(selection)) {
            const oldParentKey = oldParent.__key;
            const anchor = selection.anchor;
            const focus = selection.focus;
            elementAnchorSelectionOnNode = anchor.type === "element" && anchor.key === oldParentKey && anchor.offset === oldIndex + 1;
            elementFocusSelectionOnNode = focus.type === "element" && focus.key === oldParentKey && focus.offset === oldIndex + 1;
          }
        }
        const nextSibling = this.getNextSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const insertKey = writableNodeToInsert.__key;
        const nextKey = writableSelf.__next;
        if (nextSibling === null) {
          writableParent.__last = insertKey;
        } else {
          const writableNextSibling = nextSibling.getWritable();
          writableNextSibling.__prev = insertKey;
        }
        writableParent.__size++;
        writableSelf.__next = insertKey;
        writableNodeToInsert.__next = nextKey;
        writableNodeToInsert.__prev = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        if (restoreSelection && $isRangeSelection2(selection)) {
          const index = this.getIndexWithinParent();
          $updateElementSelectionOnCreateDeleteNode(selection, writableParent, index + 1);
          const writableParentKey = writableParent.__key;
          if (elementAnchorSelectionOnNode) {
            selection.anchor.set(writableParentKey, index + 2, "element");
          }
          if (elementFocusSelectionOnNode) {
            selection.focus.set(writableParentKey, index + 2, "element");
          }
        }
        return nodeToInsert;
      }
      /**
       * Inserts a node before this LexicalNode (as the previous sibling).
       *
       * @param nodeToInsert - The node to insert after this one.
       * @param restoreSelection - Whether or not to attempt to resolve the
       * selection to the appropriate place after the operation is complete.
       * */
      insertBefore(nodeToInsert, restoreSelection = true) {
        errorOnReadOnly();
        errorOnInsertTextNodeOnRoot(this, nodeToInsert);
        const writableSelf = this.getWritable();
        const writableNodeToInsert = nodeToInsert.getWritable();
        const insertKey = writableNodeToInsert.__key;
        removeFromParent(writableNodeToInsert);
        const prevSibling = this.getPreviousSibling();
        const writableParent = this.getParentOrThrow().getWritable();
        const prevKey = writableSelf.__prev;
        const index = this.getIndexWithinParent();
        if (prevSibling === null) {
          writableParent.__first = insertKey;
        } else {
          const writablePrevSibling = prevSibling.getWritable();
          writablePrevSibling.__next = insertKey;
        }
        writableParent.__size++;
        writableSelf.__prev = insertKey;
        writableNodeToInsert.__prev = prevKey;
        writableNodeToInsert.__next = writableSelf.__key;
        writableNodeToInsert.__parent = writableSelf.__parent;
        const selection = $getSelection2();
        if (restoreSelection && $isRangeSelection2(selection)) {
          const parent = this.getParentOrThrow();
          $updateElementSelectionOnCreateDeleteNode(selection, parent, index);
        }
        return nodeToInsert;
      }
      /**
       * Whether or not this node has a required parent. Used during copy + paste operations
       * to normalize nodes that would otherwise be orphaned. For example, ListItemNodes without
       * a ListNode parent or TextNodes with a ParagraphNode parent.
       *
       * */
      isParentRequired() {
        return false;
      }
      /**
       * The creation logic for any required parent. Should be implemented if {@link isParentRequired} returns true.
       *
       * */
      createParentElementNode() {
        return $createParagraphNode3();
      }
      /**
       * Moves selection to the previous sibling of this node, at the specified offsets.
       *
       * @param anchorOffset - The anchor offset for selection.
       * @param focusOffset -  The focus offset for selection
       * */
      selectPrevious(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const prevSibling = this.getPreviousSibling();
        const parent = this.getParentOrThrow();
        if (prevSibling === null) {
          return parent.select(0, 0);
        }
        if ($isElementNode2(prevSibling)) {
          return prevSibling.select();
        } else if (!$isTextNode2(prevSibling)) {
          const index = prevSibling.getIndexWithinParent() + 1;
          return parent.select(index, index);
        }
        return prevSibling.select(anchorOffset, focusOffset);
      }
      /**
       * Moves selection to the next sibling of this node, at the specified offsets.
       *
       * @param anchorOffset - The anchor offset for selection.
       * @param focusOffset -  The focus offset for selection
       * */
      selectNext(anchorOffset, focusOffset) {
        errorOnReadOnly();
        const nextSibling = this.getNextSibling();
        const parent = this.getParentOrThrow();
        if (nextSibling === null) {
          return parent.select();
        }
        if ($isElementNode2(nextSibling)) {
          return nextSibling.select(0, 0);
        } else if (!$isTextNode2(nextSibling)) {
          const index = nextSibling.getIndexWithinParent();
          return parent.select(index, index);
        }
        return nextSibling.select(anchorOffset, focusOffset);
      }
      /**
       * Marks a node dirty, triggering transforms and
       * forcing it to be reconciled during the update cycle.
       *
       * */
      markDirty() {
        this.getWritable();
      }
    };
    function errorOnTypeKlassMismatch(type, klass) {
      const registeredNode = getActiveEditor()._nodes.get(type);
      if (registeredNode === void 0) {
        {
          throw Error(`Create node: Attempted to create node ${klass.name} that was not configured to be used on the editor.`);
        }
      }
      const editorKlass = registeredNode.klass;
      if (editorKlass !== klass) {
        {
          throw Error(`Create node: Type ${type} in node ${klass.name} does not match registered node ${editorKlass.name} with the same type`);
        }
      }
    }
    var LineBreakNode = class _LineBreakNode extends LexicalNode {
      static getType() {
        return "linebreak";
      }
      static clone(node) {
        return new _LineBreakNode(node.__key);
      }
      constructor(key) {
        super(key);
      }
      getTextContent() {
        return "\n";
      }
      createDOM() {
        return document.createElement("br");
      }
      updateDOM() {
        return false;
      }
      static importDOM() {
        return {
          br: (node) => {
            const parentElement = node.parentElement;
            let firstChild;
            let lastChild;
            if (parentElement !== null && ((firstChild = parentElement.firstChild) === node || firstChild.nextSibling === node && firstChild.nodeType === DOM_TEXT_TYPE && (firstChild.textContent || "").match(/^( |\t|\r?\n)+$/) !== null) && ((lastChild = parentElement.lastChild) === node || lastChild.previousSibling === node && lastChild.nodeType === DOM_TEXT_TYPE && (lastChild.textContent || "").match(/^( |\t|\r?\n)+$/) !== null)) {
              return null;
            }
            return {
              conversion: convertLineBreakElement,
              priority: 0
            };
          }
        };
      }
      static importJSON(serializedLineBreakNode) {
        return $createLineBreakNode2();
      }
      exportJSON() {
        return {
          type: "linebreak",
          version: 1
        };
      }
    };
    function convertLineBreakElement(node) {
      return {
        node: $createLineBreakNode2()
      };
    }
    function $createLineBreakNode2() {
      return $applyNodeReplacement(new LineBreakNode());
    }
    function $isLineBreakNode2(node) {
      return node instanceof LineBreakNode;
    }
    function getElementOuterTag(node, format) {
      if (format & IS_CODE2) {
        return "code";
      }
      if (format & IS_HIGHLIGHT) {
        return "mark";
      }
      if (format & IS_SUBSCRIPT) {
        return "sub";
      }
      if (format & IS_SUPERSCRIPT) {
        return "sup";
      }
      return null;
    }
    function getElementInnerTag(node, format) {
      if (format & IS_BOLD2) {
        return "strong";
      }
      if (format & IS_ITALIC2) {
        return "em";
      }
      return "span";
    }
    function setTextThemeClassNames(tag, prevFormat, nextFormat, dom, textClassNames) {
      const domClassList = dom.classList;
      let classNames = getCachedClassNameArray(textClassNames, "base");
      if (classNames !== void 0) {
        domClassList.add(...classNames);
      }
      classNames = getCachedClassNameArray(textClassNames, "underlineStrikethrough");
      let hasUnderlineStrikethrough = false;
      const prevUnderlineStrikethrough = prevFormat & IS_UNDERLINE2 && prevFormat & IS_STRIKETHROUGH;
      const nextUnderlineStrikethrough = nextFormat & IS_UNDERLINE2 && nextFormat & IS_STRIKETHROUGH;
      if (classNames !== void 0) {
        if (nextUnderlineStrikethrough) {
          hasUnderlineStrikethrough = true;
          if (!prevUnderlineStrikethrough) {
            domClassList.add(...classNames);
          }
        } else if (prevUnderlineStrikethrough) {
          domClassList.remove(...classNames);
        }
      }
      for (const key in TEXT_TYPE_TO_FORMAT) {
        const format = key;
        const flag = TEXT_TYPE_TO_FORMAT[format];
        classNames = getCachedClassNameArray(textClassNames, key);
        if (classNames !== void 0) {
          if (nextFormat & flag) {
            if (hasUnderlineStrikethrough && (key === "underline" || key === "strikethrough")) {
              if (prevFormat & flag) {
                domClassList.remove(...classNames);
              }
              continue;
            }
            if ((prevFormat & flag) === 0 || prevUnderlineStrikethrough && key === "underline" || key === "strikethrough") {
              domClassList.add(...classNames);
            }
          } else if (prevFormat & flag) {
            domClassList.remove(...classNames);
          }
        }
      }
    }
    function diffComposedText(a, b) {
      const aLength = a.length;
      const bLength = b.length;
      let left = 0;
      let right = 0;
      while (left < aLength && left < bLength && a[left] === b[left]) {
        left++;
      }
      while (right + left < aLength && right + left < bLength && a[aLength - right - 1] === b[bLength - right - 1]) {
        right++;
      }
      return [left, aLength - left - right, b.slice(left, bLength - right)];
    }
    function setTextContent(nextText, dom, node) {
      const firstChild = dom.firstChild;
      const isComposing = node.isComposing();
      const suffix = isComposing ? COMPOSITION_SUFFIX : "";
      const text2 = nextText + suffix;
      if (firstChild == null) {
        dom.textContent = text2;
      } else {
        const nodeValue = firstChild.nodeValue;
        if (nodeValue !== text2) {
          if (isComposing || IS_FIREFOX) {
            const [index, remove, insert] = diffComposedText(nodeValue, text2);
            if (remove !== 0) {
              firstChild.deleteData(index, remove);
            }
            firstChild.insertData(index, insert);
          } else {
            firstChild.nodeValue = text2;
          }
        }
      }
    }
    function createTextInnerDOM(innerDOM, node, innerTag, format, text2, config) {
      setTextContent(text2, innerDOM, node);
      const theme = config.theme;
      const textClassNames = theme.text;
      if (textClassNames !== void 0) {
        setTextThemeClassNames(innerTag, 0, format, innerDOM, textClassNames);
      }
    }
    function wrapElementWith(element, tag) {
      const el = document.createElement(tag);
      el.appendChild(element);
      return el;
    }
    var TextNode2 = class _TextNode extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      static getType() {
        return "text";
      }
      static clone(node) {
        return new _TextNode(node.__text, node.__key);
      }
      constructor(text2, key) {
        super(key);
        this.__text = text2;
        this.__format = 0;
        this.__style = "";
        this.__mode = 0;
        this.__detail = 0;
      }
      /**
       * Returns a 32-bit integer that represents the TextFormatTypes currently applied to the
       * TextNode. You probably don't want to use this method directly - consider using TextNode.hasFormat instead.
       *
       * @returns a number representing the format of the text node.
       */
      getFormat() {
        const self = this.getLatest();
        return self.__format;
      }
      /**
       * Returns a 32-bit integer that represents the TextDetailTypes currently applied to the
       * TextNode. You probably don't want to use this method directly - consider using TextNode.isDirectionless
       * or TextNode.isUnmergeable instead.
       *
       * @returns a number representing the detail of the text node.
       */
      getDetail() {
        const self = this.getLatest();
        return self.__detail;
      }
      /**
       * Returns the mode (TextModeType) of the TextNode, which may be "normal", "token", or "segmented"
       *
       * @returns TextModeType.
       */
      getMode() {
        const self = this.getLatest();
        return TEXT_TYPE_TO_MODE[self.__mode];
      }
      /**
       * Returns the styles currently applied to the node. This is analogous to CSSText in the DOM.
       *
       * @returns CSSText-like string of styles applied to the underlying DOM node.
       */
      getStyle() {
        const self = this.getLatest();
        return self.__style;
      }
      /**
       * Returns whether or not the node is in "token" mode. TextNodes in token mode can be navigated through character-by-character
       * with a RangeSelection, but are deleted as a single entity (not invdividually by character).
       *
       * @returns true if the node is in token mode, false otherwise.
       */
      isToken() {
        const self = this.getLatest();
        return self.__mode === IS_TOKEN;
      }
      /**
       *
       * @returns true if Lexical detects that an IME or other 3rd-party script is attempting to
       * mutate the TextNode, false otherwise.
       */
      isComposing() {
        return this.__key === $getCompositionKey();
      }
      /**
       * Returns whether or not the node is in "segemented" mode. TextNodes in segemented mode can be navigated through character-by-character
       * with a RangeSelection, but are deleted in space-delimited "segments".
       *
       * @returns true if the node is in segmented mode, false otherwise.
       */
      isSegmented() {
        const self = this.getLatest();
        return self.__mode === IS_SEGMENTED;
      }
      /**
       * Returns whether or not the node is "directionless". Directionless nodes don't respect changes between RTL and LTR modes.
       *
       * @returns true if the node is directionless, false otherwise.
       */
      isDirectionless() {
        const self = this.getLatest();
        return (self.__detail & IS_DIRECTIONLESS) !== 0;
      }
      /**
       * Returns whether or not the node is unmergeable. In some scenarios, Lexical tries to merge
       * adjacent TextNodes into a single TextNode. If a TextNode is unmergeable, this won't happen.
       *
       * @returns true if the node is unmergeable, false otherwise.
       */
      isUnmergeable() {
        const self = this.getLatest();
        return (self.__detail & IS_UNMERGEABLE) !== 0;
      }
      /**
       * Returns whether or not the node has the provided format applied. Use this with the human-readable TextFormatType
       * string values to get the format of a TextNode.
       *
       * @param type - the TextFormatType to check for.
       *
       * @returns true if the node has the provided format, false otherwise.
       */
      hasFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.getFormat() & formatFlag) !== 0;
      }
      /**
       * Returns whether or not the node is simple text. Simple text is defined as a TextNode that has the string type "text"
       * (i.e., not a subclass) and has no mode applied to it (i.e., not segmented or token).
       *
       * @returns true if the node is simple text, false otherwise.
       */
      isSimpleText() {
        return this.__type === "text" && this.__mode === 0;
      }
      /**
       * Returns the text content of the node as a string.
       *
       * @returns a string representing the text content of the node.
       */
      getTextContent() {
        const self = this.getLatest();
        return self.__text;
      }
      /**
       * Returns the format flags applied to the node as a 32-bit integer.
       *
       * @returns a number representing the TextFormatTypes applied to the node.
       */
      getFormatFlags(type, alignWithFormat) {
        const self = this.getLatest();
        const format = self.__format;
        return toggleTextFormatType(format, type, alignWithFormat);
      }
      // View
      createDOM(config) {
        const format = this.__format;
        const outerTag = getElementOuterTag(this, format);
        const innerTag = getElementInnerTag(this, format);
        const tag = outerTag === null ? innerTag : outerTag;
        const dom = document.createElement(tag);
        let innerDOM = dom;
        if (this.hasFormat("code")) {
          dom.setAttribute("spellcheck", "false");
        }
        if (outerTag !== null) {
          innerDOM = document.createElement(innerTag);
          dom.appendChild(innerDOM);
        }
        const text2 = this.__text;
        createTextInnerDOM(innerDOM, this, innerTag, format, text2, config);
        const style = this.__style;
        if (style !== "") {
          dom.style.cssText = style;
        }
        return dom;
      }
      updateDOM(prevNode, dom, config) {
        const nextText = this.__text;
        const prevFormat = prevNode.__format;
        const nextFormat = this.__format;
        const prevOuterTag = getElementOuterTag(this, prevFormat);
        const nextOuterTag = getElementOuterTag(this, nextFormat);
        const prevInnerTag = getElementInnerTag(this, prevFormat);
        const nextInnerTag = getElementInnerTag(this, nextFormat);
        const prevTag = prevOuterTag === null ? prevInnerTag : prevOuterTag;
        const nextTag = nextOuterTag === null ? nextInnerTag : nextOuterTag;
        if (prevTag !== nextTag) {
          return true;
        }
        if (prevOuterTag === nextOuterTag && prevInnerTag !== nextInnerTag) {
          const prevInnerDOM = dom.firstChild;
          if (prevInnerDOM == null) {
            {
              throw Error(`updateDOM: prevInnerDOM is null or undefined`);
            }
          }
          const nextInnerDOM = document.createElement(nextInnerTag);
          createTextInnerDOM(nextInnerDOM, this, nextInnerTag, nextFormat, nextText, config);
          dom.replaceChild(nextInnerDOM, prevInnerDOM);
          return false;
        }
        let innerDOM = dom;
        if (nextOuterTag !== null) {
          if (prevOuterTag !== null) {
            innerDOM = dom.firstChild;
            if (innerDOM == null) {
              {
                throw Error(`updateDOM: innerDOM is null or undefined`);
              }
            }
          }
        }
        setTextContent(nextText, innerDOM, this);
        const theme = config.theme;
        const textClassNames = theme.text;
        if (textClassNames !== void 0 && prevFormat !== nextFormat) {
          setTextThemeClassNames(nextInnerTag, prevFormat, nextFormat, innerDOM, textClassNames);
        }
        const prevStyle = prevNode.__style;
        const nextStyle = this.__style;
        if (prevStyle !== nextStyle) {
          dom.style.cssText = nextStyle;
        }
        return false;
      }
      static importDOM() {
        return {
          "#text": () => ({
            conversion: convertTextDOMNode,
            priority: 0
          }),
          b: () => ({
            conversion: convertBringAttentionToElement,
            priority: 0
          }),
          code: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          em: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          i: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          s: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          span: () => ({
            conversion: convertSpanElement,
            priority: 0
          }),
          strong: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sub: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          sup: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          }),
          u: () => ({
            conversion: convertTextFormatElement,
            priority: 0
          })
        };
      }
      static importJSON(serializedNode) {
        const node = $createTextNode3(serializedNode.text);
        node.setFormat(serializedNode.format);
        node.setDetail(serializedNode.detail);
        node.setMode(serializedNode.mode);
        node.setStyle(serializedNode.style);
        return node;
      }
      // This improves Lexical's basic text output in copy+paste plus
      // for headless mode where people might use Lexical to generate
      // HTML content and not have the ability to use CSS classes.
      exportDOM(editor) {
        let {
          element
        } = super.exportDOM(editor);
        if (!(element !== null && isHTMLElement(element))) {
          throw Error(`Expected TextNode createDOM to always return a HTMLElement`);
        }
        element.style.whiteSpace = "pre-wrap";
        if (this.hasFormat("bold")) {
          element = wrapElementWith(element, "b");
        }
        if (this.hasFormat("italic")) {
          element = wrapElementWith(element, "i");
        }
        if (this.hasFormat("strikethrough")) {
          element = wrapElementWith(element, "s");
        }
        if (this.hasFormat("underline")) {
          element = wrapElementWith(element, "u");
        }
        return {
          element
        };
      }
      exportJSON() {
        return {
          detail: this.getDetail(),
          format: this.getFormat(),
          mode: this.getMode(),
          style: this.getStyle(),
          text: this.getTextContent(),
          type: "text",
          version: 1
        };
      }
      // Mutators
      selectionTransform(prevSelection, nextSelection) {
        return;
      }
      /**
       * Sets the node format to the provided TextFormatType or 32-bit integer. Note that the TextFormatType
       * version of the argument can only specify one format and doing so will remove all other formats that
       * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleFormat}
       *
       * @param format - TextFormatType or 32-bit integer representing the node format.
       *
       * @returns this TextNode.
       * // TODO 0.12 This should just be a `string`.
       */
      setFormat(format) {
        const self = this.getWritable();
        self.__format = typeof format === "string" ? TEXT_TYPE_TO_FORMAT[format] : format;
        return self;
      }
      /**
       * Sets the node detail to the provided TextDetailType or 32-bit integer. Note that the TextDetailType
       * version of the argument can only specify one detail value and doing so will remove all other detail values that
       * may be applied to the node. For toggling behavior, consider using {@link TextNode.toggleDirectionless}
       * or {@link TextNode.togglerUnmergeable}
       *
       * @param detail - TextDetailType or 32-bit integer representing the node detail.
       *
       * @returns this TextNode.
       * // TODO 0.12 This should just be a `string`.
       */
      setDetail(detail) {
        const self = this.getWritable();
        self.__detail = typeof detail === "string" ? DETAIL_TYPE_TO_DETAIL[detail] : detail;
        return self;
      }
      /**
       * Sets the node style to the provided CSSText-like string. Set this property as you
       * would an HTMLElement style attribute to apply inline styles to the underlying DOM Element.
       *
       * @param style - CSSText to be applied to the underlying HTMLElement.
       *
       * @returns this TextNode.
       */
      setStyle(style) {
        const self = this.getWritable();
        self.__style = style;
        return self;
      }
      /**
       * Applies the provided format to this TextNode if it's not present. Removes it if it is present.
       * Prefer using this method to turn specific formats on and off.
       *
       * @param type - TextFormatType to toggle.
       *
       * @returns this TextNode.
       */
      toggleFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return this.setFormat(this.getFormat() ^ formatFlag);
      }
      /**
       * Toggles the directionless detail value of the node. Prefer using this method over setDetail.
       *
       * @returns this TextNode.
       */
      toggleDirectionless() {
        const self = this.getWritable();
        self.__detail ^= IS_DIRECTIONLESS;
        return self;
      }
      /**
       * Toggles the unmergeable detail value of the node. Prefer using this method over setDetail.
       *
       * @returns this TextNode.
       */
      toggleUnmergeable() {
        const self = this.getWritable();
        self.__detail ^= IS_UNMERGEABLE;
        return self;
      }
      /**
       * Sets the mode of the node.
       *
       * @returns this TextNode.
       */
      setMode(type) {
        const mode = TEXT_MODE_TO_TYPE[type];
        if (this.__mode === mode) {
          return this;
        }
        const self = this.getWritable();
        self.__mode = mode;
        return self;
      }
      /**
       * Sets the text content of the node.
       *
       * @param text - the string to set as the text value of the node.
       *
       * @returns this TextNode.
       */
      setTextContent(text2) {
        if (this.__text === text2) {
          return this;
        }
        const self = this.getWritable();
        self.__text = text2;
        return self;
      }
      /**
       * Sets the current Lexical selection to be a RangeSelection with anchor and focus on this TextNode at the provided offsets.
       *
       * @param _anchorOffset - the offset at which the Selection anchor will be placed.
       * @param _focusOffset - the offset at which the Selection focus will be placed.
       *
       * @returns the new RangeSelection.
       */
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const selection = $getSelection2();
        const text2 = this.getTextContent();
        const key = this.__key;
        if (typeof text2 === "string") {
          const lastOffset = text2.length;
          if (anchorOffset === void 0) {
            anchorOffset = lastOffset;
          }
          if (focusOffset === void 0) {
            focusOffset = lastOffset;
          }
        } else {
          anchorOffset = 0;
          focusOffset = 0;
        }
        if (!$isRangeSelection2(selection)) {
          return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "text", "text");
        } else {
          const compositionKey = $getCompositionKey();
          if (compositionKey === selection.anchor.key || compositionKey === selection.focus.key) {
            $setCompositionKey(key);
          }
          selection.setTextNodeRange(this, anchorOffset, this, focusOffset);
        }
        return selection;
      }
      /**
       * Inserts the provided text into this TextNode at the provided offset, deleting the number of characters
       * specified. Can optionally calculate a new selection after the operation is complete.
       *
       * @param offset - the offset at which the splice operation should begin.
       * @param delCount - the number of characters to delete, starting from the offset.
       * @param newText - the text to insert into the TextNode at the offset.
       * @param moveSelection - optional, whether or not to move selection to the end of the inserted substring.
       *
       * @returns this TextNode.
       */
      spliceText(offset, delCount, newText, moveSelection) {
        const writableSelf = this.getWritable();
        const text2 = writableSelf.__text;
        const handledTextLength = newText.length;
        let index = offset;
        if (index < 0) {
          index = handledTextLength + index;
          if (index < 0) {
            index = 0;
          }
        }
        const selection = $getSelection2();
        if (moveSelection && $isRangeSelection2(selection)) {
          const newOffset = offset + handledTextLength;
          selection.setTextNodeRange(writableSelf, newOffset, writableSelf, newOffset);
        }
        const updatedText = text2.slice(0, index) + newText + text2.slice(index + delCount);
        writableSelf.__text = updatedText;
        return writableSelf;
      }
      /**
       * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
       * when a user event would cause text to be inserted before them in the editor. If true, Lexical will attempt
       * to insert text into this node. If false, it will insert the text in a new sibling node.
       *
       * @returns true if text can be inserted before the node, false otherwise.
       */
      canInsertTextBefore() {
        return true;
      }
      /**
       * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
       * when a user event would cause text to be inserted after them in the editor. If true, Lexical will attempt
       * to insert text into this node. If false, it will insert the text in a new sibling node.
       *
       * @returns true if text can be inserted after the node, false otherwise.
       */
      canInsertTextAfter() {
        return true;
      }
      /**
       * Splits this TextNode at the provided character offsets, forming new TextNodes from the substrings
       * formed by the split, and inserting those new TextNodes into the editor, replacing the one that was split.
       *
       * @param splitOffsets - rest param of the text content character offsets at which this node should be split.
       *
       * @returns an Array containing the newly-created TextNodes.
       */
      splitText(...splitOffsets) {
        errorOnReadOnly();
        const self = this.getLatest();
        const textContent = self.getTextContent();
        const key = self.__key;
        const compositionKey = $getCompositionKey();
        const offsetsSet = new Set(splitOffsets);
        const parts = [];
        const textLength = textContent.length;
        let string = "";
        for (let i = 0; i < textLength; i++) {
          if (string !== "" && offsetsSet.has(i)) {
            parts.push(string);
            string = "";
          }
          string += textContent[i];
        }
        if (string !== "") {
          parts.push(string);
        }
        const partsLength = parts.length;
        if (partsLength === 0) {
          return [];
        } else if (parts[0] === textContent) {
          return [self];
        }
        const firstPart = parts[0];
        const parent = self.getParentOrThrow();
        let writableNode;
        const format = self.getFormat();
        const style = self.getStyle();
        const detail = self.__detail;
        let hasReplacedSelf = false;
        if (self.isSegmented()) {
          writableNode = $createTextNode3(firstPart);
          writableNode.__format = format;
          writableNode.__style = style;
          writableNode.__detail = detail;
          hasReplacedSelf = true;
        } else {
          writableNode = self.getWritable();
          writableNode.__text = firstPart;
        }
        const selection = $getSelection2();
        const splitNodes = [writableNode];
        let textSize = firstPart.length;
        for (let i = 1; i < partsLength; i++) {
          const part = parts[i];
          const partSize = part.length;
          const sibling = $createTextNode3(part).getWritable();
          sibling.__format = format;
          sibling.__style = style;
          sibling.__detail = detail;
          const siblingKey = sibling.__key;
          const nextTextSize = textSize + partSize;
          if ($isRangeSelection2(selection)) {
            const anchor = selection.anchor;
            const focus = selection.focus;
            if (anchor.key === key && anchor.type === "text" && anchor.offset > textSize && anchor.offset <= nextTextSize) {
              anchor.key = siblingKey;
              anchor.offset -= textSize;
              selection.dirty = true;
            }
            if (focus.key === key && focus.type === "text" && focus.offset > textSize && focus.offset <= nextTextSize) {
              focus.key = siblingKey;
              focus.offset -= textSize;
              selection.dirty = true;
            }
          }
          if (compositionKey === key) {
            $setCompositionKey(siblingKey);
          }
          textSize = nextTextSize;
          splitNodes.push(sibling);
        }
        internalMarkSiblingsAsDirty(this);
        const writableParent = parent.getWritable();
        const insertionIndex = this.getIndexWithinParent();
        if (hasReplacedSelf) {
          writableParent.splice(insertionIndex, 0, splitNodes);
          this.remove();
        } else {
          writableParent.splice(insertionIndex, 1, splitNodes);
        }
        if ($isRangeSelection2(selection)) {
          $updateElementSelectionOnCreateDeleteNode(selection, parent, insertionIndex, partsLength - 1);
        }
        return splitNodes;
      }
      /**
       * Merges the target TextNode into this TextNode, removing the target node.
       *
       * @param target - the TextNode to merge into this one.
       *
       * @returns this TextNode.
       */
      mergeWithSibling(target) {
        const isBefore = target === this.getPreviousSibling();
        if (!isBefore && target !== this.getNextSibling()) {
          {
            throw Error(`mergeWithSibling: sibling must be a previous or next sibling`);
          }
        }
        const key = this.__key;
        const targetKey = target.__key;
        const text2 = this.__text;
        const textLength = text2.length;
        const compositionKey = $getCompositionKey();
        if (compositionKey === targetKey) {
          $setCompositionKey(key);
        }
        const selection = $getSelection2();
        if ($isRangeSelection2(selection)) {
          const anchor = selection.anchor;
          const focus = selection.focus;
          if (anchor !== null && anchor.key === targetKey) {
            adjustPointOffsetForMergedSibling(anchor, isBefore, key, target, textLength);
            selection.dirty = true;
          }
          if (focus !== null && focus.key === targetKey) {
            adjustPointOffsetForMergedSibling(focus, isBefore, key, target, textLength);
            selection.dirty = true;
          }
        }
        const targetText = target.__text;
        const newText = isBefore ? targetText + text2 : text2 + targetText;
        this.setTextContent(newText);
        const writableSelf = this.getWritable();
        target.remove();
        return writableSelf;
      }
      /**
       * This method is meant to be overriden by TextNode subclasses to control the behavior of those nodes
       * when used with the registerLexicalTextEntity function. If you're using registerLexicalTextEntity, the
       * node class that you create and replace matched text with should return true from this method.
       *
       * @returns true if the node is to be treated as a "text entity", false otherwise.
       */
      isTextEntity() {
        return false;
      }
    };
    function convertSpanElement(domNode) {
      const span = domNode;
      const hasBoldFontWeight = span.style.fontWeight === "700";
      const hasLinethroughTextDecoration = span.style.textDecoration === "line-through";
      const hasItalicFontStyle = span.style.fontStyle === "italic";
      const hasUnderlineTextDecoration = span.style.textDecoration === "underline";
      const verticalAlign = span.style.verticalAlign;
      return {
        forChild: (lexicalNode) => {
          if (!$isTextNode2(lexicalNode)) {
            return lexicalNode;
          }
          if (hasBoldFontWeight) {
            lexicalNode.toggleFormat("bold");
          }
          if (hasLinethroughTextDecoration) {
            lexicalNode.toggleFormat("strikethrough");
          }
          if (hasItalicFontStyle) {
            lexicalNode.toggleFormat("italic");
          }
          if (hasUnderlineTextDecoration) {
            lexicalNode.toggleFormat("underline");
          }
          if (verticalAlign === "sub") {
            lexicalNode.toggleFormat("subscript");
          }
          if (verticalAlign === "super") {
            lexicalNode.toggleFormat("superscript");
          }
          return lexicalNode;
        },
        node: null
      };
    }
    function convertBringAttentionToElement(domNode) {
      const b = domNode;
      const hasNormalFontWeight = b.style.fontWeight === "normal";
      return {
        forChild: (lexicalNode) => {
          if ($isTextNode2(lexicalNode) && !hasNormalFontWeight) {
            lexicalNode.toggleFormat("bold");
          }
          return lexicalNode;
        },
        node: null
      };
    }
    var preParentCache = /* @__PURE__ */ new WeakMap();
    function isNodePre(node) {
      return node.nodeName === "PRE" || node.nodeType === DOM_ELEMENT_TYPE && node.style.whiteSpace.startsWith("pre");
    }
    function findParentPreDOMNode(node) {
      let cached;
      let parent = node.parentNode;
      const visited = [node];
      while (parent !== null && (cached = preParentCache.get(parent)) === void 0 && !isNodePre(parent)) {
        visited.push(parent);
        parent = parent.parentNode;
      }
      const resultNode = cached === void 0 ? parent : cached;
      for (let i = 0; i < visited.length; i++) {
        preParentCache.set(visited[i], resultNode);
      }
      return resultNode;
    }
    function convertTextDOMNode(domNode) {
      const domNode_ = domNode;
      const parentDom = domNode.parentElement;
      if (!(parentDom !== null)) {
        throw Error(`Expected parentElement of Text not to be null`);
      }
      let textContent = domNode_.textContent || "";
      if (findParentPreDOMNode(domNode_) !== null) {
        const parts = textContent.split(/(\r?\n|\t)/);
        const nodes = [];
        const length = parts.length;
        for (let i = 0; i < length; i++) {
          const part = parts[i];
          if (part === "\n" || part === "\r\n") {
            nodes.push($createLineBreakNode2());
          } else if (part === "	") {
            nodes.push($createTabNode());
          } else if (part !== "") {
            nodes.push($createTextNode3(part));
          }
        }
        return {
          node: nodes
        };
      }
      textContent = textContent.replace(/\r/g, "").replace(/[ \t\n]+/g, " ");
      if (textContent === "") {
        return {
          node: null
        };
      }
      if (textContent[0] === " ") {
        let previousText = domNode_;
        let isStartOfLine = true;
        while (previousText !== null && (previousText = findTextInLine(previousText, false)) !== null) {
          const previousTextContent = previousText.textContent || "";
          if (previousTextContent.length > 0) {
            if (/[ \t\n]$/.test(previousTextContent)) {
              textContent = textContent.slice(1);
            }
            isStartOfLine = false;
            break;
          }
        }
        if (isStartOfLine) {
          textContent = textContent.slice(1);
        }
      }
      if (textContent[textContent.length - 1] === " ") {
        let nextText = domNode_;
        let isEndOfLine = true;
        while (nextText !== null && (nextText = findTextInLine(nextText, true)) !== null) {
          const nextTextContent = (nextText.textContent || "").replace(/^( |\t|\r?\n)+/, "");
          if (nextTextContent.length > 0) {
            isEndOfLine = false;
            break;
          }
        }
        if (isEndOfLine) {
          textContent = textContent.slice(0, textContent.length - 1);
        }
      }
      if (textContent === "") {
        return {
          node: null
        };
      }
      return {
        node: $createTextNode3(textContent)
      };
    }
    var inlineParents = new RegExp(/^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/, "i");
    function findTextInLine(text2, forward) {
      let node = text2;
      while (true) {
        let sibling;
        while ((sibling = forward ? node.nextSibling : node.previousSibling) === null) {
          const parentElement = node.parentElement;
          if (parentElement === null) {
            return null;
          }
          node = parentElement;
        }
        node = sibling;
        if (node.nodeType === DOM_ELEMENT_TYPE) {
          const display = node.style.display;
          if (display === "" && node.nodeName.match(inlineParents) === null || display !== "" && !display.startsWith("inline")) {
            return null;
          }
        }
        let descendant = node;
        while ((descendant = forward ? node.firstChild : node.lastChild) !== null) {
          node = descendant;
        }
        if (node.nodeType === DOM_TEXT_TYPE) {
          return node;
        } else if (node.nodeName === "BR") {
          return null;
        }
      }
    }
    var nodeNameToTextFormat = {
      code: "code",
      em: "italic",
      i: "italic",
      s: "strikethrough",
      strong: "bold",
      sub: "subscript",
      sup: "superscript",
      u: "underline"
    };
    function convertTextFormatElement(domNode) {
      const format = nodeNameToTextFormat[domNode.nodeName.toLowerCase()];
      if (format === void 0) {
        return {
          node: null
        };
      }
      return {
        forChild: (lexicalNode) => {
          if ($isTextNode2(lexicalNode) && !lexicalNode.hasFormat(format)) {
            lexicalNode.toggleFormat(format);
          }
          return lexicalNode;
        },
        node: null
      };
    }
    function $createTextNode3(text2 = "") {
      return $applyNodeReplacement(new TextNode2(text2));
    }
    function $isTextNode2(node) {
      return node instanceof TextNode2;
    }
    var TabNode = class _TabNode extends TextNode2 {
      static getType() {
        return "tab";
      }
      static clone(node) {
        const newNode = new _TabNode(node.__key);
        newNode.__text = node.__text;
        newNode.__format = node.__format;
        newNode.__style = node.__style;
        return newNode;
      }
      constructor(key) {
        super("	", key);
        this.__detail = IS_UNMERGEABLE;
      }
      static importDOM() {
        return null;
      }
      static importJSON(serializedTabNode) {
        const node = $createTabNode();
        node.setFormat(serializedTabNode.format);
        node.setStyle(serializedTabNode.style);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "tab",
          version: 1
        };
      }
      setTextContent(_text) {
        {
          throw Error(`TabNode does not support setTextContent`);
        }
      }
      setDetail(_detail) {
        {
          throw Error(`TabNode does not support setDetail`);
        }
      }
      setMode(_type) {
        {
          throw Error(`TabNode does not support setMode`);
        }
      }
      canInsertTextBefore() {
        return false;
      }
      canInsertTextAfter() {
        return false;
      }
    };
    function $createTabNode() {
      return $applyNodeReplacement(new TabNode());
    }
    function $isTabNode(node) {
      return node instanceof TabNode;
    }
    var Point = class {
      constructor(key, offset, type) {
        this._selection = null;
        this.key = key;
        this.offset = offset;
        this.type = type;
      }
      is(point) {
        return this.key === point.key && this.offset === point.offset && this.type === point.type;
      }
      isBefore(b) {
        let aNode = this.getNode();
        let bNode = b.getNode();
        const aOffset = this.offset;
        const bOffset = b.offset;
        if ($isElementNode2(aNode)) {
          const aNodeDescendant = aNode.getDescendantByIndex(aOffset);
          aNode = aNodeDescendant != null ? aNodeDescendant : aNode;
        }
        if ($isElementNode2(bNode)) {
          const bNodeDescendant = bNode.getDescendantByIndex(bOffset);
          bNode = bNodeDescendant != null ? bNodeDescendant : bNode;
        }
        if (aNode === bNode) {
          return aOffset < bOffset;
        }
        return aNode.isBefore(bNode);
      }
      getNode() {
        const key = this.key;
        const node = $getNodeByKey(key);
        if (node === null) {
          {
            throw Error(`Point.getNode: node not found`);
          }
        }
        return node;
      }
      set(key, offset, type) {
        const selection = this._selection;
        const oldKey = this.key;
        this.key = key;
        this.offset = offset;
        this.type = type;
        if (!isCurrentlyReadOnlyMode()) {
          if ($getCompositionKey() === oldKey) {
            $setCompositionKey(key);
          }
          if (selection !== null) {
            selection._cachedNodes = null;
            selection.dirty = true;
          }
        }
      }
    };
    function $createPoint(key, offset, type) {
      return new Point(key, offset, type);
    }
    function selectPointOnNode(point, node) {
      let key = node.__key;
      let offset = point.offset;
      let type = "element";
      if ($isTextNode2(node)) {
        type = "text";
        const textContentLength = node.getTextContentSize();
        if (offset > textContentLength) {
          offset = textContentLength;
        }
      } else if (!$isElementNode2(node)) {
        const nextSibling = node.getNextSibling();
        if ($isTextNode2(nextSibling)) {
          key = nextSibling.__key;
          offset = 0;
          type = "text";
        } else {
          const parentNode = node.getParent();
          if (parentNode) {
            key = parentNode.__key;
            offset = node.getIndexWithinParent() + 1;
          }
        }
      }
      point.set(key, offset, type);
    }
    function $moveSelectionPointToEnd(point, node) {
      if ($isElementNode2(node)) {
        const lastNode = node.getLastDescendant();
        if ($isElementNode2(lastNode) || $isTextNode2(lastNode)) {
          selectPointOnNode(point, lastNode);
        } else {
          selectPointOnNode(point, node);
        }
      } else {
        selectPointOnNode(point, node);
      }
    }
    function $transferStartingElementPointToTextPoint(start, end, format, style) {
      const element = start.getNode();
      const placementNode = element.getChildAtIndex(start.offset);
      const textNode = $createTextNode3();
      const target = $isRootNode2(element) ? $createParagraphNode3().append(textNode) : textNode;
      textNode.setFormat(format);
      textNode.setStyle(style);
      if (placementNode === null) {
        element.append(target);
      } else {
        placementNode.insertBefore(target);
        if (end.type === "element" && end.key === start.key && end.offset !== start.offset) {
          end.set(end.key, end.offset + 1, "element");
        }
      }
      if (start.is(end)) {
        end.set(textNode.__key, 0, "text");
      }
      start.set(textNode.__key, 0, "text");
    }
    function $setPointValues(point, key, offset, type) {
      point.key = key;
      point.offset = offset;
      point.type = type;
    }
    var NodeSelection = class _NodeSelection {
      constructor(objects) {
        this.dirty = false;
        this._nodes = objects;
        this._cachedNodes = null;
      }
      is(selection) {
        if (!$isNodeSelection(selection)) {
          return false;
        }
        const a = this._nodes;
        const b = selection._nodes;
        return a.size === b.size && Array.from(a).every((key) => b.has(key));
      }
      add(key) {
        this.dirty = true;
        this._nodes.add(key);
        this._cachedNodes = null;
      }
      delete(key) {
        this.dirty = true;
        this._nodes.delete(key);
        this._cachedNodes = null;
      }
      clear() {
        this.dirty = true;
        this._nodes.clear();
        this._cachedNodes = null;
      }
      has(key) {
        return this._nodes.has(key);
      }
      clone() {
        return new _NodeSelection(new Set(this._nodes));
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text2) {
      }
      insertText() {
      }
      insertNodes(nodes, selectStart) {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastSelectedNode = selectedNodes[selectedNodesLength - 1];
        let selectionAtEnd;
        if ($isTextNode2(lastSelectedNode)) {
          selectionAtEnd = lastSelectedNode.select();
        } else {
          const index = lastSelectedNode.getIndexWithinParent() + 1;
          selectionAtEnd = lastSelectedNode.getParentOrThrow().select(index, index);
        }
        selectionAtEnd.insertNodes(nodes, selectStart);
        for (let i = 0; i < selectedNodesLength; i++) {
          selectedNodes[i].remove();
        }
        return true;
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const objects = this._nodes;
        const nodes = [];
        for (const object of objects) {
          const node = $getNodeByKey(object);
          if (node !== null) {
            nodes.push(node);
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes();
        let textContent = "";
        for (let i = 0; i < nodes.length; i++) {
          textContent += nodes[i].getTextContent();
        }
        return textContent;
      }
    };
    function $isRangeSelection2(x) {
      return x instanceof RangeSelection;
    }
    function DEPRECATED_$getGridCellNodeRect(GridCellNode) {
      const [CellNode, , GridNode] = DEPRECATED_$getNodeTriplet(GridCellNode);
      const rows = GridNode.getChildren();
      const rowCount = rows.length;
      const columnCount = rows[0].getChildren().length;
      const cellMatrix = new Array(rowCount);
      for (let i = 0; i < rowCount; i++) {
        cellMatrix[i] = new Array(columnCount);
      }
      for (let rowIndex = 0; rowIndex < rowCount; rowIndex++) {
        const row = rows[rowIndex];
        const cells = row.getChildren();
        let columnIndex = 0;
        for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {
          while (cellMatrix[rowIndex][columnIndex]) {
            columnIndex++;
          }
          const cell = cells[cellIndex];
          const rowSpan = cell.__rowSpan || 1;
          const colSpan = cell.__colSpan || 1;
          for (let i = 0; i < rowSpan; i++) {
            for (let j = 0; j < colSpan; j++) {
              cellMatrix[rowIndex + i][columnIndex + j] = cell;
            }
          }
          if (CellNode === cell) {
            return {
              colSpan,
              columnIndex,
              rowIndex,
              rowSpan
            };
          }
          columnIndex += colSpan;
        }
      }
      return null;
    }
    var GridSelection = class _GridSelection {
      constructor(gridKey, anchor, focus) {
        this.gridKey = gridKey;
        this.anchor = anchor;
        this.focus = focus;
        this.dirty = false;
        this._cachedNodes = null;
        anchor._selection = this;
        focus._selection = this;
      }
      is(selection) {
        if (!DEPRECATED_$isGridSelection(selection)) {
          return false;
        }
        return this.gridKey === selection.gridKey && this.anchor.is(selection.anchor) && this.focus.is(selection.focus);
      }
      set(gridKey, anchorCellKey, focusCellKey) {
        this.dirty = true;
        this.gridKey = gridKey;
        this.anchor.key = anchorCellKey;
        this.focus.key = focusCellKey;
        this._cachedNodes = null;
      }
      clone() {
        return new _GridSelection(this.gridKey, this.anchor, this.focus);
      }
      isCollapsed() {
        return false;
      }
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      getCharacterOffsets() {
        return getCharacterOffsets(this);
      }
      extract() {
        return this.getNodes();
      }
      insertRawText(text2) {
      }
      insertText() {
      }
      insertNodes(nodes, selectStart) {
        const focusNode = this.focus.getNode();
        const selection = $normalizeSelection(focusNode.select(0, focusNode.getChildrenSize()));
        return selection.insertNodes(nodes, selectStart);
      }
      // TODO Deprecate this method. It's confusing when used with colspan|rowspan
      getShape() {
        const anchorCellNode = $getNodeByKey(this.anchor.key);
        if (!DEPRECATED_$isGridCellNode(anchorCellNode)) {
          throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);
        }
        const anchorCellNodeRect = DEPRECATED_$getGridCellNodeRect(anchorCellNode);
        if (!(anchorCellNodeRect !== null)) {
          throw Error(`getCellRect: expected to find AnchorNode`);
        }
        const focusCellNode = $getNodeByKey(this.focus.key);
        if (!DEPRECATED_$isGridCellNode(focusCellNode)) {
          throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);
        }
        const focusCellNodeRect = DEPRECATED_$getGridCellNodeRect(focusCellNode);
        if (!(focusCellNodeRect !== null)) {
          throw Error(`getCellRect: expected to find focusCellNode`);
        }
        const startX = Math.min(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);
        const stopX = Math.max(anchorCellNodeRect.columnIndex, focusCellNodeRect.columnIndex);
        const startY = Math.min(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);
        const stopY = Math.max(anchorCellNodeRect.rowIndex, focusCellNodeRect.rowIndex);
        return {
          fromX: Math.min(startX, stopX),
          fromY: Math.min(startY, stopY),
          toX: Math.max(startX, stopX),
          toY: Math.max(startY, stopY)
        };
      }
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const anchorNode = this.anchor.getNode();
        const focusNode = this.focus.getNode();
        const anchorCell = $findMatchingParent2(anchorNode, DEPRECATED_$isGridCellNode);
        const focusCell = $findMatchingParent2(focusNode, DEPRECATED_$isGridCellNode);
        if (!DEPRECATED_$isGridCellNode(anchorCell)) {
          throw Error(`Expected GridSelection anchor to be (or a child of) GridCellNode`);
        }
        if (!DEPRECATED_$isGridCellNode(focusCell)) {
          throw Error(`Expected GridSelection focus to be (or a child of) GridCellNode`);
        }
        const anchorRow = anchorCell.getParent();
        if (!DEPRECATED_$isGridRowNode(anchorRow)) {
          throw Error(`Expected anchorCell to have a parent GridRowNode`);
        }
        const gridNode = anchorRow.getParent();
        if (!DEPRECATED_$isGridNode(gridNode)) {
          throw Error(`Expected tableNode to have a parent GridNode`);
        }
        const [map3, cellAMap, cellBMap] = DEPRECATED_$computeGridMap(gridNode, anchorCell, focusCell);
        let minColumn = Math.min(cellAMap.startColumn, cellBMap.startColumn);
        let minRow = Math.min(cellAMap.startRow, cellBMap.startRow);
        let maxColumn = Math.max(cellAMap.startColumn + cellAMap.cell.__colSpan - 1, cellBMap.startColumn + cellBMap.cell.__colSpan - 1);
        let maxRow = Math.max(cellAMap.startRow + cellAMap.cell.__rowSpan - 1, cellBMap.startRow + cellBMap.cell.__rowSpan - 1);
        let exploredMinColumn = minColumn;
        let exploredMinRow = minRow;
        let exploredMaxColumn = minColumn;
        let exploredMaxRow = minRow;
        function expandBoundary(mapValue) {
          const {
            cell,
            startColumn: cellStartColumn,
            startRow: cellStartRow
          } = mapValue;
          minColumn = Math.min(minColumn, cellStartColumn);
          minRow = Math.min(minRow, cellStartRow);
          maxColumn = Math.max(maxColumn, cellStartColumn + cell.__colSpan - 1);
          maxRow = Math.max(maxRow, cellStartRow + cell.__rowSpan - 1);
        }
        while (minColumn < exploredMinColumn || minRow < exploredMinRow || maxColumn > exploredMaxColumn || maxRow > exploredMaxRow) {
          if (minColumn < exploredMinColumn) {
            const rowDiff = exploredMaxRow - exploredMinRow;
            const previousColumn = exploredMinColumn - 1;
            for (let i = 0; i <= rowDiff; i++) {
              expandBoundary(map3[exploredMinRow + i][previousColumn]);
            }
            exploredMinColumn = previousColumn;
          }
          if (minRow < exploredMinRow) {
            const columnDiff = exploredMaxColumn - exploredMinColumn;
            const previousRow = exploredMinRow - 1;
            for (let i = 0; i <= columnDiff; i++) {
              expandBoundary(map3[previousRow][exploredMinColumn + i]);
            }
            exploredMinRow = previousRow;
          }
          if (maxColumn > exploredMaxColumn) {
            const rowDiff = exploredMaxRow - exploredMinRow;
            const nextColumn = exploredMaxColumn + 1;
            for (let i = 0; i <= rowDiff; i++) {
              expandBoundary(map3[exploredMinRow + i][nextColumn]);
            }
            exploredMaxColumn = nextColumn;
          }
          if (maxRow > exploredMaxRow) {
            const columnDiff = exploredMaxColumn - exploredMinColumn;
            const nextRow = exploredMaxRow + 1;
            for (let i = 0; i <= columnDiff; i++) {
              expandBoundary(map3[nextRow][exploredMinColumn + i]);
            }
            exploredMaxRow = nextRow;
          }
        }
        const nodes = [gridNode];
        let lastRow = null;
        for (let i = minRow; i <= maxRow; i++) {
          for (let j = minColumn; j <= maxColumn; j++) {
            const {
              cell
            } = map3[i][j];
            const currentRow = cell.getParent();
            if (!DEPRECATED_$isGridRowNode(currentRow)) {
              throw Error(`Expected GridCellNode parent to be a GridRowNode`);
            }
            if (currentRow !== lastRow) {
              nodes.push(currentRow);
            }
            nodes.push(cell, ...$getChildrenRecursively(cell));
            lastRow = currentRow;
          }
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      getTextContent() {
        const nodes = this.getNodes();
        let textContent = "";
        for (let i = 0; i < nodes.length; i++) {
          textContent += nodes[i].getTextContent();
        }
        return textContent;
      }
    };
    function DEPRECATED_$isGridSelection(x) {
      return x instanceof GridSelection;
    }
    var RangeSelection = class _RangeSelection {
      constructor(anchor, focus, format, style) {
        this.anchor = anchor;
        this.focus = focus;
        this.dirty = false;
        this.format = format;
        this.style = style;
        this._cachedNodes = null;
        anchor._selection = this;
        focus._selection = this;
      }
      /**
       * Used to check if the provided selections is equal to this one by value,
       * inluding anchor, focus, format, and style properties.
       * @param selection - the Selection to compare this one to.
       * @returns true if the Selections are equal, false otherwise.
       */
      is(selection) {
        if (!$isRangeSelection2(selection)) {
          return false;
        }
        return this.anchor.is(selection.anchor) && this.focus.is(selection.focus) && this.format === selection.format && this.style === selection.style;
      }
      /**
       * Returns whether the Selection is "backwards", meaning the focus
       * logically precedes the anchor in the EditorState.
       * @returns true if the Selection is backwards, false otherwise.
       */
      isBackward() {
        return this.focus.isBefore(this.anchor);
      }
      /**
       * Returns whether the Selection is "collapsed", meaning the anchor and focus are
       * the same node and have the same offset.
       *
       * @returns true if the Selection is collapsed, false otherwise.
       */
      isCollapsed() {
        return this.anchor.is(this.focus);
      }
      /**
       * Gets all the nodes in the Selection. Uses caching to make it generally suitable
       * for use in hot paths.
       *
       * @returns an Array containing all the nodes in the Selection
       */
      getNodes() {
        const cachedNodes = this._cachedNodes;
        if (cachedNodes !== null) {
          return cachedNodes;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = anchor.isBefore(focus);
        const firstPoint = isBefore ? anchor : focus;
        const lastPoint = isBefore ? focus : anchor;
        let firstNode = firstPoint.getNode();
        let lastNode = lastPoint.getNode();
        const startOffset = firstPoint.offset;
        const endOffset = lastPoint.offset;
        if ($isElementNode2(firstNode)) {
          const firstNodeDescendant = firstNode.getDescendantByIndex(startOffset);
          firstNode = firstNodeDescendant != null ? firstNodeDescendant : firstNode;
        }
        if ($isElementNode2(lastNode)) {
          let lastNodeDescendant = lastNode.getDescendantByIndex(endOffset);
          if (lastNodeDescendant !== null && lastNodeDescendant !== firstNode && lastNode.getChildAtIndex(endOffset) === lastNodeDescendant) {
            lastNodeDescendant = lastNodeDescendant.getPreviousSibling();
          }
          lastNode = lastNodeDescendant != null ? lastNodeDescendant : lastNode;
        }
        let nodes;
        if (firstNode.is(lastNode)) {
          if ($isElementNode2(firstNode) && firstNode.getChildrenSize() > 0) {
            nodes = [];
          } else {
            nodes = [firstNode];
          }
        } else {
          nodes = firstNode.getNodesBetween(lastNode);
        }
        if (!isCurrentlyReadOnlyMode()) {
          this._cachedNodes = nodes;
        }
        return nodes;
      }
      /**
       * Sets this Selection to be of type "text" at the provided anchor and focus values.
       *
       * @param anchorNode - the anchor node to set on the Selection
       * @param anchorOffset - the offset to set on the Selection
       * @param focusNode - the focus node to set on the Selection
       * @param focusOffset - the focus offset to set on the Selection
       */
      setTextNodeRange(anchorNode, anchorOffset, focusNode, focusOffset) {
        $setPointValues(this.anchor, anchorNode.__key, anchorOffset, "text");
        $setPointValues(this.focus, focusNode.__key, focusOffset, "text");
        this._cachedNodes = null;
        this.dirty = true;
      }
      /**
       * Gets the (plain) text content of all the nodes in the selection.
       *
       * @returns a string representing the text content of all the nodes in the Selection
       */
      getTextContent() {
        const nodes = this.getNodes();
        if (nodes.length === 0) {
          return "";
        }
        const firstNode = nodes[0];
        const lastNode = nodes[nodes.length - 1];
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = anchor.isBefore(focus);
        const [anchorOffset, focusOffset] = getCharacterOffsets(this);
        let textContent = "";
        let prevWasElement = true;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if ($isElementNode2(node) && !node.isInline()) {
            if (!prevWasElement) {
              textContent += "\n";
            }
            if (node.isEmpty()) {
              prevWasElement = false;
            } else {
              prevWasElement = true;
            }
          } else {
            prevWasElement = false;
            if ($isTextNode2(node)) {
              let text2 = node.getTextContent();
              if (node === firstNode) {
                if (node === lastNode) {
                  if (anchor.type !== "element" || focus.type !== "element" || focus.offset === anchor.offset) {
                    text2 = anchorOffset < focusOffset ? text2.slice(anchorOffset, focusOffset) : text2.slice(focusOffset, anchorOffset);
                  }
                } else {
                  text2 = isBefore ? text2.slice(anchorOffset) : text2.slice(focusOffset);
                }
              } else if (node === lastNode) {
                text2 = isBefore ? text2.slice(0, focusOffset) : text2.slice(0, anchorOffset);
              }
              textContent += text2;
            } else if (($isDecoratorNode2(node) || $isLineBreakNode2(node)) && (node !== lastNode || !this.isCollapsed())) {
              textContent += node.getTextContent();
            }
          }
        }
        return textContent;
      }
      /**
       * Attempts to map a DOM selection range onto this Lexical Selection,
       * setting the anchor, focus, and type accordingly
       *
       * @param range a DOM Selection range conforming to the StaticRange interface.
       */
      applyDOMRange(range) {
        const editor = getActiveEditor();
        const currentEditorState = editor.getEditorState();
        const lastSelection = currentEditorState._selection;
        const resolvedSelectionPoints = internalResolveSelectionPoints(range.startContainer, range.startOffset, range.endContainer, range.endOffset, editor, lastSelection);
        if (resolvedSelectionPoints === null) {
          return;
        }
        const [anchorPoint, focusPoint] = resolvedSelectionPoints;
        $setPointValues(this.anchor, anchorPoint.key, anchorPoint.offset, anchorPoint.type);
        $setPointValues(this.focus, focusPoint.key, focusPoint.offset, focusPoint.type);
        this._cachedNodes = null;
      }
      /**
       * Creates a new RangeSelection, copying over all the property values from this one.
       *
       * @returns a new RangeSelection with the same property values as this one.
       */
      clone() {
        const anchor = this.anchor;
        const focus = this.focus;
        const selection = new _RangeSelection($createPoint(anchor.key, anchor.offset, anchor.type), $createPoint(focus.key, focus.offset, focus.type), this.format, this.style);
        return selection;
      }
      /**
       * Toggles the provided format on all the TextNodes in the Selection.
       *
       * @param format a string TextFormatType to toggle on the TextNodes in the selection
       */
      toggleFormat(format) {
        this.format = toggleTextFormatType(this.format, format, null);
        this.dirty = true;
      }
      /**
       * Sets the value of the style property on the Selection
       *
       * @param style - the style to set at the value of the style property.
       */
      setStyle(style) {
        this.style = style;
        this.dirty = true;
      }
      /**
       * Returns whether the provided TextFormatType is present on the Selection. This will be true if any node in the Selection
       * has the specified format.
       *
       * @param type the TextFormatType to check for.
       * @returns true if the provided format is currently toggled on on the Selection, false otherwise.
       */
      hasFormat(type) {
        const formatFlag = TEXT_TYPE_TO_FORMAT[type];
        return (this.format & formatFlag) !== 0;
      }
      /**
       * Attempts to insert the provided text into the EditorState at the current Selection.
       * converts tabs, newlines, and carriage returns into LexicalNodes.
       *
       * @param text the text to insert into the Selection
       */
      insertRawText(text2) {
        const parts = text2.split(/(\r?\n|\t)/);
        const nodes = [];
        const length = parts.length;
        for (let i = 0; i < length; i++) {
          const part = parts[i];
          if (part === "\n" || part === "\r\n") {
            nodes.push($createLineBreakNode2());
          } else if (part === "	") {
            nodes.push($createTabNode());
          } else {
            nodes.push($createTextNode3(part));
          }
        }
        this.insertNodes(nodes);
      }
      /**
       * Attempts to insert the provided text into the EditorState at the current Selection as a new
       * Lexical TextNode, according to a series of insertion heuristics based on the selection type and position.
       *
       * @param text the text to insert into the Selection
       */
      insertText(text2) {
        const anchor = this.anchor;
        const focus = this.focus;
        const isBefore = this.isCollapsed() || anchor.isBefore(focus);
        const format = this.format;
        const style = this.style;
        if (isBefore && anchor.type === "element") {
          $transferStartingElementPointToTextPoint(anchor, focus, format, style);
        } else if (!isBefore && focus.type === "element") {
          $transferStartingElementPointToTextPoint(focus, anchor, format, style);
        }
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const firstPoint = isBefore ? anchor : focus;
        const endPoint = isBefore ? focus : anchor;
        const startOffset = firstPoint.offset;
        const endOffset = endPoint.offset;
        let firstNode = selectedNodes[0];
        if (!$isTextNode2(firstNode)) {
          {
            throw Error(`insertText: first node is not a text node`);
          }
        }
        const firstNodeText = firstNode.getTextContent();
        const firstNodeTextLength = firstNodeText.length;
        const firstNodeParent = firstNode.getParentOrThrow();
        const lastIndex = selectedNodesLength - 1;
        let lastNode = selectedNodes[lastIndex];
        if (this.isCollapsed() && startOffset === firstNodeTextLength && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextAfter() || !firstNodeParent.canInsertTextAfter() && firstNode.getNextSibling() === null)) {
          let nextSibling = firstNode.getNextSibling();
          if (!$isTextNode2(nextSibling) || !nextSibling.canInsertTextBefore() || $isTokenOrSegmented(nextSibling)) {
            nextSibling = $createTextNode3();
            nextSibling.setFormat(format);
            if (!firstNodeParent.canInsertTextAfter()) {
              firstNodeParent.insertAfter(nextSibling);
            } else {
              firstNode.insertAfter(nextSibling);
            }
          }
          nextSibling.select(0, 0);
          firstNode = nextSibling;
          if (text2 !== "") {
            this.insertText(text2);
            return;
          }
        } else if (this.isCollapsed() && startOffset === 0 && (firstNode.isSegmented() || firstNode.isToken() || !firstNode.canInsertTextBefore() || !firstNodeParent.canInsertTextBefore() && firstNode.getPreviousSibling() === null)) {
          let prevSibling = firstNode.getPreviousSibling();
          if (!$isTextNode2(prevSibling) || $isTokenOrSegmented(prevSibling)) {
            prevSibling = $createTextNode3();
            prevSibling.setFormat(format);
            if (!firstNodeParent.canInsertTextBefore()) {
              firstNodeParent.insertBefore(prevSibling);
            } else {
              firstNode.insertBefore(prevSibling);
            }
          }
          prevSibling.select();
          firstNode = prevSibling;
          if (text2 !== "") {
            this.insertText(text2);
            return;
          }
        } else if (firstNode.isSegmented() && startOffset !== firstNodeTextLength) {
          const textNode = $createTextNode3(firstNode.getTextContent());
          textNode.setFormat(format);
          firstNode.replace(textNode);
          firstNode = textNode;
        } else if (!this.isCollapsed() && text2 !== "") {
          const lastNodeParent = lastNode.getParent();
          if (!firstNodeParent.canInsertTextBefore() || !firstNodeParent.canInsertTextAfter() || $isElementNode2(lastNodeParent) && (!lastNodeParent.canInsertTextBefore() || !lastNodeParent.canInsertTextAfter())) {
            this.insertText("");
            normalizeSelectionPointsForBoundaries(this.anchor, this.focus, null);
            this.insertText(text2);
            return;
          }
        }
        if (selectedNodesLength === 1) {
          if (firstNode.isToken()) {
            const textNode = $createTextNode3(text2);
            textNode.select();
            firstNode.replace(textNode);
            return;
          }
          const firstNodeFormat = firstNode.getFormat();
          const firstNodeStyle = firstNode.getStyle();
          if (startOffset === endOffset && (firstNodeFormat !== format || firstNodeStyle !== style)) {
            if (firstNode.getTextContent() === "") {
              firstNode.setFormat(format);
              firstNode.setStyle(style);
            } else {
              const textNode = $createTextNode3(text2);
              textNode.setFormat(format);
              textNode.setStyle(style);
              textNode.select();
              if (startOffset === 0) {
                firstNode.insertBefore(textNode, false);
              } else {
                const [targetNode] = firstNode.splitText(startOffset);
                targetNode.insertAfter(textNode, false);
              }
              if (textNode.isComposing() && this.anchor.type === "text") {
                this.anchor.offset -= text2.length;
              }
              return;
            }
          }
          const delCount = endOffset - startOffset;
          firstNode = firstNode.spliceText(startOffset, delCount, text2, true);
          if (firstNode.getTextContent() === "") {
            firstNode.remove();
          } else if (this.anchor.type === "text") {
            if (firstNode.isComposing()) {
              this.anchor.offset -= text2.length;
            } else {
              this.format = firstNodeFormat;
              this.style = firstNodeStyle;
            }
          }
        } else {
          const markedNodeKeysForKeep = /* @__PURE__ */ new Set([...firstNode.getParentKeys(), ...lastNode.getParentKeys()]);
          const firstElement = $isElementNode2(firstNode) ? firstNode : firstNode.getParentOrThrow();
          let lastElement = $isElementNode2(lastNode) ? lastNode : lastNode.getParentOrThrow();
          let lastElementChild = lastNode;
          if (!firstElement.is(lastElement) && lastElement.isInline()) {
            do {
              lastElementChild = lastElement;
              lastElement = lastElement.getParentOrThrow();
            } while (lastElement.isInline());
          }
          if (endPoint.type === "text" && (endOffset !== 0 || lastNode.getTextContent() === "") || endPoint.type === "element" && lastNode.getIndexWithinParent() < endOffset) {
            if ($isTextNode2(lastNode) && !lastNode.isToken() && endOffset !== lastNode.getTextContentSize()) {
              if (lastNode.isSegmented()) {
                const textNode = $createTextNode3(lastNode.getTextContent());
                lastNode.replace(textNode);
                lastNode = textNode;
              }
              if (!$isRootNode2(endPoint.getNode())) {
                lastNode = lastNode.spliceText(0, endOffset, "");
              }
              markedNodeKeysForKeep.add(lastNode.__key);
            } else {
              const lastNodeParent = lastNode.getParentOrThrow();
              if (!lastNodeParent.canBeEmpty() && lastNodeParent.getChildrenSize() === 1) {
                lastNodeParent.remove();
              } else {
                lastNode.remove();
              }
            }
          } else {
            markedNodeKeysForKeep.add(lastNode.__key);
          }
          const lastNodeChildren = lastElement.getChildren();
          const selectedNodesSet = new Set(selectedNodes);
          const firstAndLastElementsAreEqual = firstElement.is(lastElement);
          const insertionTarget = firstElement.isInline() && firstNode.getNextSibling() === null ? firstElement : firstNode;
          for (let i = lastNodeChildren.length - 1; i >= 0; i--) {
            const lastNodeChild = lastNodeChildren[i];
            if (lastNodeChild.is(firstNode) || $isElementNode2(lastNodeChild) && lastNodeChild.isParentOf(firstNode)) {
              break;
            }
            if (lastNodeChild.isAttached()) {
              if (!selectedNodesSet.has(lastNodeChild) || lastNodeChild.is(lastElementChild)) {
                if (!firstAndLastElementsAreEqual) {
                  insertionTarget.insertAfter(lastNodeChild, false);
                }
              } else {
                lastNodeChild.remove();
              }
            }
          }
          if (!firstAndLastElementsAreEqual) {
            let parent = lastElement;
            let lastRemovedParent = null;
            while (parent !== null) {
              const children = parent.getChildren();
              const childrenLength = children.length;
              if (childrenLength === 0 || children[childrenLength - 1].is(lastRemovedParent)) {
                markedNodeKeysForKeep.delete(parent.__key);
                lastRemovedParent = parent;
              }
              parent = parent.getParent();
            }
          }
          if (!firstNode.isToken()) {
            firstNode = firstNode.spliceText(startOffset, firstNodeTextLength - startOffset, text2, true);
            if (firstNode.getTextContent() === "") {
              firstNode.remove();
            } else if (firstNode.isComposing() && this.anchor.type === "text") {
              this.anchor.offset -= text2.length;
            }
          } else if (startOffset === firstNodeTextLength) {
            firstNode.select();
          } else {
            const textNode = $createTextNode3(text2);
            textNode.select();
            firstNode.replace(textNode);
          }
          for (let i = 1; i < selectedNodesLength; i++) {
            const selectedNode = selectedNodes[i];
            const key = selectedNode.__key;
            if (!markedNodeKeysForKeep.has(key)) {
              selectedNode.remove();
            }
          }
        }
      }
      /**
       * Removes the text in the Selection, adjusting the EditorState accordingly.
       */
      removeText() {
        this.insertText("");
      }
      /**
       * Applies the provided format to the TextNodes in the Selection, splitting or
       * merging nodes as necessary.
       *
       * @param formatType the format type to apply to the nodes in the Selection.
       */
      formatText(formatType) {
        if (this.isCollapsed()) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const selectedNodes = this.getNodes();
        const selectedTextNodes = [];
        for (const selectedNode of selectedNodes) {
          if ($isTextNode2(selectedNode)) {
            selectedTextNodes.push(selectedNode);
          }
        }
        const selectedTextNodesLength = selectedTextNodes.length;
        if (selectedTextNodesLength === 0) {
          this.toggleFormat(formatType);
          $setCompositionKey(null);
          return;
        }
        const anchor = this.anchor;
        const focus = this.focus;
        const isBackward = this.isBackward();
        const startPoint = isBackward ? focus : anchor;
        const endPoint = isBackward ? anchor : focus;
        let firstIndex = 0;
        let firstNode = selectedTextNodes[0];
        let startOffset = startPoint.type === "element" ? 0 : startPoint.offset;
        if (startPoint.type === "text" && startOffset === firstNode.getTextContentSize()) {
          firstIndex = 1;
          firstNode = selectedTextNodes[1];
          startOffset = 0;
        }
        if (firstNode == null) {
          return;
        }
        const firstNextFormat = firstNode.getFormatFlags(formatType, null);
        const lastIndex = selectedTextNodesLength - 1;
        let lastNode = selectedTextNodes[lastIndex];
        const endOffset = endPoint.type === "text" ? endPoint.offset : lastNode.getTextContentSize();
        if (firstNode.is(lastNode)) {
          if (startOffset === endOffset) {
            return;
          }
          if (startOffset === 0 && endOffset === firstNode.getTextContentSize()) {
            firstNode.setFormat(firstNextFormat);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            replacement.setFormat(firstNextFormat);
            if (startPoint.type === "text") {
              startPoint.set(replacement.__key, 0, "text");
            }
            if (endPoint.type === "text") {
              endPoint.set(replacement.__key, endOffset - startOffset, "text");
            }
          }
          this.format = firstNextFormat;
          return;
        }
        if (startOffset !== 0) {
          [, firstNode] = firstNode.splitText(startOffset);
          startOffset = 0;
        }
        firstNode.setFormat(firstNextFormat);
        const lastNextFormat = lastNode.getFormatFlags(formatType, firstNextFormat);
        if (endOffset > 0) {
          if (endOffset !== lastNode.getTextContentSize()) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          lastNode.setFormat(lastNextFormat);
        }
        for (let i = firstIndex + 1; i < lastIndex; i++) {
          const textNode = selectedTextNodes[i];
          if (!textNode.isToken()) {
            const nextFormat = textNode.getFormatFlags(formatType, lastNextFormat);
            textNode.setFormat(nextFormat);
          }
        }
        if (startPoint.type === "text") {
          startPoint.set(firstNode.__key, startOffset, "text");
        }
        if (endPoint.type === "text") {
          endPoint.set(lastNode.__key, endOffset, "text");
        }
        this.format = firstNextFormat | lastNextFormat;
      }
      /**
       * Attempts to "intelligently" insert an arbitrary list of Lexical nodes into the EditorState at the
       * current Selection according to a set of heuristics that determine how surrounding nodes
       * should be changed, replaced, or moved to accomodate the incoming ones.
       *
       * @param nodes - the nodes to insert
       * @param selectStart - whether or not to select the start after the insertion.
       * @returns true if the nodes were inserted successfully, false otherwise.
       */
      insertNodes(nodes, selectStart) {
        if (!this.isCollapsed()) {
          const selectionEnd = this.isBackward() ? this.anchor : this.focus;
          const nextSibling = selectionEnd.getNode().getNextSibling();
          const nextSiblingKey = nextSibling ? nextSibling.getKey() : null;
          const prevSibling = selectionEnd.getNode().getPreviousSibling();
          const prevSiblingKey = prevSibling ? prevSibling.getKey() : null;
          this.removeText();
          if (this.isCollapsed() && this.focus.type === "element") {
            let textNode;
            if (this.focus.key === nextSiblingKey && this.focus.offset === 0) {
              textNode = $createTextNode3();
              this.focus.getNode().insertBefore(textNode);
            } else if (this.focus.key === prevSiblingKey && this.focus.offset === this.focus.getNode().getChildrenSize()) {
              textNode = $createTextNode3();
              this.focus.getNode().insertAfter(textNode);
            }
            if (textNode) {
              this.focus.set(textNode.__key, 0, "text");
              this.anchor.set(textNode.__key, 0, "text");
            }
          }
        }
        const anchor = this.anchor;
        const anchorOffset = anchor.offset;
        const anchorNode = anchor.getNode();
        let target = anchorNode;
        if (anchor.type === "element") {
          const element = anchor.getNode();
          const placementNode = element.getChildAtIndex(anchorOffset - 1);
          if (placementNode === null) {
            target = element;
          } else {
            target = placementNode;
          }
        }
        const siblings = [];
        const nextSiblings = anchorNode.getNextSiblings();
        const topLevelElement = $isRootOrShadowRoot2(anchorNode) ? null : anchorNode.getTopLevelElementOrThrow();
        if ($isTextNode2(anchorNode)) {
          const textContent = anchorNode.getTextContent();
          const textContentLength = textContent.length;
          if (anchorOffset === 0 && textContentLength !== 0) {
            const prevSibling = anchorNode.getPreviousSibling();
            if (prevSibling !== null) {
              target = prevSibling;
            } else {
              target = anchorNode.getParentOrThrow();
            }
            siblings.push(anchorNode);
          } else if (anchorOffset === textContentLength) {
            target = anchorNode;
          } else if (anchorNode.isToken()) {
            return false;
          } else {
            let danglingText;
            [target, danglingText] = anchorNode.splitText(anchorOffset);
            siblings.push(danglingText);
          }
        }
        const startingNode = target;
        siblings.push(...nextSiblings);
        const firstNode = nodes[0];
        let didReplaceOrMerge = false;
        let lastNode = null;
        for (let i = 0; i < nodes.length; i++) {
          const node = nodes[i];
          if (!$isRootOrShadowRoot2(target) && !$isDecoratorNode2(target) && $isElementNode2(node) && !node.isInline()) {
            if (node.is(firstNode)) {
              if ($isElementNode2(target) && target.isEmpty() && target.canReplaceWith(node)) {
                target.replace(node);
                target = node;
                didReplaceOrMerge = true;
                continue;
              }
              const firstDescendant = node.getFirstDescendant();
              if ($isLeafNode(firstDescendant)) {
                let element = firstDescendant.getParentOrThrow();
                while (element.isInline()) {
                  element = element.getParentOrThrow();
                }
                const children = element.getChildren();
                const childrenLength = children.length;
                if ($isElementNode2(target)) {
                  let firstChild = target.getFirstChild();
                  for (let s = 0; s < childrenLength; s++) {
                    const child = children[s];
                    if (firstChild === null) {
                      target.append(child);
                    } else {
                      firstChild.insertAfter(child);
                    }
                    firstChild = child;
                  }
                } else {
                  for (let s = childrenLength - 1; s >= 0; s--) {
                    target.insertAfter(children[s]);
                  }
                  target = target.getParentOrThrow();
                }
                lastNode = children[childrenLength - 1];
                element.remove();
                didReplaceOrMerge = true;
                if (element.is(node)) {
                  continue;
                }
              }
            }
            if ($isTextNode2(target)) {
              if (topLevelElement === null) {
                {
                  throw Error(`insertNode: topLevelElement is root node`);
                }
              }
              target = topLevelElement;
            }
          } else if (didReplaceOrMerge && !$isElementNode2(node) && !$isDecoratorNode2(node) && $isRootOrShadowRoot2(target.getParent())) {
            {
              throw Error(`insertNodes: cannot insert a non-element into a root node`);
            }
          }
          didReplaceOrMerge = false;
          if ($isElementNode2(target) && !target.isInline()) {
            lastNode = node;
            if ($isDecoratorNode2(node) && !node.isInline()) {
              if (nodes.length === 1 && target.canBeEmpty() && target.isEmpty()) {
                target = target.insertBefore(node, false);
              } else {
                target = target.insertAfter(node, false);
              }
            } else if (!$isElementNode2(node)) {
              const firstChild = target.getFirstChild();
              if (firstChild !== null) {
                firstChild.insertBefore(node);
              } else {
                target.append(node);
              }
              target = node;
            } else {
              if (!node.canBeEmpty() && node.isEmpty()) {
                continue;
              }
              if ($isRootNode2(target)) {
                const placementNode = target.getChildAtIndex(anchorOffset);
                if (placementNode !== null) {
                  placementNode.insertBefore(node);
                } else {
                  target.append(node);
                }
                target = node;
              } else if (node.isInline()) {
                target.append(node);
                target = node;
              } else {
                target = target.insertAfter(node, false);
              }
            }
          } else if (!$isElementNode2(node) || $isElementNode2(node) && node.isInline() || $isDecoratorNode2(target) && !target.isInline()) {
            lastNode = node;
            if ($isRangeSelection2(this) && $isDecoratorNode2(node) && ($isElementNode2(target) || $isTextNode2(target)) && !node.isInline()) {
              let splitNode;
              let splitOffset;
              if ($isTextNode2(target)) {
                splitNode = target.getParentOrThrow();
                const [textNode] = target.splitText(anchorOffset);
                splitOffset = textNode.getIndexWithinParent() + 1;
              } else {
                splitNode = target;
                splitOffset = anchorOffset;
              }
              const [, rightTree] = $splitNode(splitNode, splitOffset);
              target = rightTree.insertBefore(node);
            } else {
              target = target.insertAfter(node, false);
            }
          } else {
            const nextTarget = target.getParentOrThrow();
            if ($isLineBreakNode2(target)) {
              target.remove();
            }
            target = nextTarget;
            i--;
            continue;
          }
        }
        if (selectStart) {
          if ($isTextNode2(startingNode)) {
            startingNode.select();
          } else {
            const prevSibling = target.getPreviousSibling();
            if ($isTextNode2(prevSibling)) {
              prevSibling.select();
            } else {
              const index = target.getIndexWithinParent();
              target.getParentOrThrow().select(index, index);
            }
          }
        }
        if ($isElementNode2(target)) {
          const lastChild = $isTextNode2(lastNode) ? lastNode : $isElementNode2(lastNode) && lastNode.isInline() ? lastNode.getLastDescendant() : target.getLastDescendant();
          if (!selectStart) {
            if (lastChild === null) {
              target.select();
            } else if ($isTextNode2(lastChild)) {
              if (lastChild.getTextContent() === "") {
                lastChild.selectPrevious();
              } else {
                lastChild.select();
              }
            } else {
              lastChild.selectNext();
            }
          }
          if (siblings.length !== 0) {
            const originalTarget = target;
            for (let i = siblings.length - 1; i >= 0; i--) {
              const sibling = siblings[i];
              const prevParent = sibling.getParentOrThrow();
              if ($isElementNode2(target) && !$isBlockElementNode(sibling) && !($isDecoratorNode2(sibling) && // Note: We are only looking for decorators that are inline and not isolated.
              (!sibling.isInline() || sibling.isIsolated()))) {
                if (originalTarget === target) {
                  target.append(sibling);
                } else {
                  target.insertBefore(sibling);
                }
                target = sibling;
              } else if (!$isElementNode2(target) && !$isBlockElementNode(sibling)) {
                target.insertBefore(sibling);
                target = sibling;
              } else {
                if ($isElementNode2(sibling) && !sibling.canInsertAfter(target)) {
                  const prevParentClone = prevParent.constructor.clone(prevParent);
                  if (!$isElementNode2(prevParentClone)) {
                    {
                      throw Error(`insertNodes: cloned parent clone is not an element`);
                    }
                  }
                  prevParentClone.append(sibling);
                  target.insertAfter(prevParentClone);
                } else {
                  target.insertAfter(sibling);
                }
              }
              if (prevParent.isEmpty() && !prevParent.canBeEmpty()) {
                prevParent.remove();
              }
            }
          }
        } else if (!selectStart) {
          if ($isTextNode2(target)) {
            target.select();
          } else {
            const element = target.getParentOrThrow();
            const index = target.getIndexWithinParent() + 1;
            element.select(index, index);
          }
        }
        return true;
      }
      /**
       * Inserts a new ParagraphNode into the EditorState at the current Selection
       */
      insertParagraph() {
        if (!this.isCollapsed()) {
          this.removeText();
        }
        const anchor = this.anchor;
        const anchorOffset = anchor.offset;
        let currentElement;
        let nodesToMove = [];
        let siblingsToMove = [];
        if (anchor.type === "text") {
          const anchorNode = anchor.getNode();
          nodesToMove = anchorNode.getNextSiblings().reverse();
          currentElement = anchorNode.getParentOrThrow();
          const isInline = currentElement.isInline();
          const textContentLength = isInline ? currentElement.getTextContentSize() : anchorNode.getTextContentSize();
          if (anchorOffset === 0) {
            nodesToMove.push(anchorNode);
          } else {
            if (isInline) {
              siblingsToMove = currentElement.getNextSiblings();
            }
            if (anchorOffset !== textContentLength) {
              if (!isInline || anchorOffset !== anchorNode.getTextContentSize()) {
                const [, splitNode] = anchorNode.splitText(anchorOffset);
                nodesToMove.push(splitNode);
              }
            }
          }
        } else {
          currentElement = anchor.getNode();
          if ($isRootOrShadowRoot2(currentElement)) {
            const paragraph2 = $createParagraphNode3();
            const child = currentElement.getChildAtIndex(anchorOffset);
            paragraph2.select();
            if (child !== null) {
              child.insertBefore(paragraph2, false);
            } else {
              currentElement.append(paragraph2);
            }
            return;
          }
          nodesToMove = currentElement.getChildren().slice(anchorOffset).reverse();
        }
        const nodesToMoveLength = nodesToMove.length;
        if (anchorOffset === 0 && nodesToMoveLength > 0 && currentElement.isInline()) {
          const parent = currentElement.getParentOrThrow();
          const newElement2 = parent.insertNewAfter(this, false);
          if ($isElementNode2(newElement2)) {
            const children = parent.getChildren();
            for (let i = 0; i < children.length; i++) {
              newElement2.append(children[i]);
            }
          }
          return;
        }
        const newElement = currentElement.insertNewAfter(this, false);
        if (newElement === null) {
          this.insertLineBreak();
        } else if ($isElementNode2(newElement)) {
          const currentElementFirstChild = currentElement.getFirstChild();
          const isBeginning = anchorOffset === 0 && (currentElement.is(anchor.getNode()) || currentElementFirstChild && currentElementFirstChild.is(anchor.getNode()));
          if (isBeginning && nodesToMoveLength > 0) {
            currentElement.insertBefore(newElement);
            return;
          }
          let firstChild = null;
          const siblingsToMoveLength = siblingsToMove.length;
          const parent = newElement.getParentOrThrow();
          if (siblingsToMoveLength > 0) {
            for (let i = 0; i < siblingsToMoveLength; i++) {
              const siblingToMove = siblingsToMove[i];
              parent.append(siblingToMove);
            }
          }
          if (nodesToMoveLength !== 0) {
            for (let i = 0; i < nodesToMoveLength; i++) {
              const nodeToMove = nodesToMove[i];
              if (firstChild === null) {
                newElement.append(nodeToMove);
              } else {
                firstChild.insertBefore(nodeToMove);
              }
              firstChild = nodeToMove;
            }
          }
          if (!newElement.canBeEmpty() && newElement.getChildrenSize() === 0) {
            newElement.selectPrevious();
            newElement.remove();
          } else {
            newElement.selectStart();
          }
        }
      }
      /**
       * Inserts a logical linebreak, which may be a new LineBreakNode or a new ParagraphNode, into the EditorState at the
       * current Selection.
       *
       * @param selectStart whether or not to select the start of the insertion range after the operation completes.
       */
      insertLineBreak(selectStart) {
        const lineBreakNode = $createLineBreakNode2();
        const anchor = this.anchor;
        if (anchor.type === "element") {
          const element = anchor.getNode();
          if ($isRootNode2(element)) {
            this.insertParagraph();
          }
        }
        if (selectStart) {
          this.insertNodes([lineBreakNode], true);
        } else {
          if (this.insertNodes([lineBreakNode])) {
            lineBreakNode.selectNext(0, 0);
          }
        }
      }
      /**
       * Returns the character-based offsets of the Selection, accounting for non-text Points
       * by using the children size or text content.
       *
       * @returns the character offsets for the Selection
       */
      getCharacterOffsets() {
        return getCharacterOffsets(this);
      }
      /**
       * Extracts the nodes in the Selection, splitting nodes where necessary
       * to get offset-level precision.
       *
       * @returns The nodes in the Selection
       */
      extract() {
        const selectedNodes = this.getNodes();
        const selectedNodesLength = selectedNodes.length;
        const lastIndex = selectedNodesLength - 1;
        const anchor = this.anchor;
        const focus = this.focus;
        let firstNode = selectedNodes[0];
        let lastNode = selectedNodes[lastIndex];
        const [anchorOffset, focusOffset] = getCharacterOffsets(this);
        if (selectedNodesLength === 0) {
          return [];
        } else if (selectedNodesLength === 1) {
          if ($isTextNode2(firstNode) && !this.isCollapsed()) {
            const startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            const endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const node = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            return node != null ? [node] : [];
          }
          return [firstNode];
        }
        const isBefore = anchor.isBefore(focus);
        if ($isTextNode2(firstNode)) {
          const startOffset = isBefore ? anchorOffset : focusOffset;
          if (startOffset === firstNode.getTextContentSize()) {
            selectedNodes.shift();
          } else if (startOffset !== 0) {
            [, firstNode] = firstNode.splitText(startOffset);
            selectedNodes[0] = firstNode;
          }
        }
        if ($isTextNode2(lastNode)) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          const endOffset = isBefore ? focusOffset : anchorOffset;
          if (endOffset === 0) {
            selectedNodes.pop();
          } else if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
            selectedNodes[lastIndex] = lastNode;
          }
        }
        return selectedNodes;
      }
      /**
       * Modifies the Selection according to the parameters and a set of heuristics that account for
       * various node types. Can be used to safely move or extend selection by one logical "unit" without
       * dealing explicitly with all the possible node types.
       *
       * @param alter the type of modification to perform
       * @param isBackward whether or not selection is backwards
       * @param granularity the granularity at which to apply the modification
       */
      modify(alter, isBackward, granularity) {
        const focus = this.focus;
        const anchor = this.anchor;
        const collapse = alter === "move";
        const possibleNode = $getAdjacentNode(focus, isBackward);
        if ($isDecoratorNode2(possibleNode) && !possibleNode.isIsolated()) {
          if (collapse && possibleNode.isKeyboardSelectable()) {
            const nodeSelection = $createNodeSelection();
            nodeSelection.add(possibleNode.__key);
            $setSelection2(nodeSelection);
            return;
          }
          const sibling = isBackward ? possibleNode.getPreviousSibling() : possibleNode.getNextSibling();
          if (!$isTextNode2(sibling)) {
            const parent = possibleNode.getParentOrThrow();
            let offset;
            let elementKey;
            if ($isElementNode2(sibling)) {
              elementKey = sibling.__key;
              offset = isBackward ? sibling.getChildrenSize() : 0;
            } else {
              offset = possibleNode.getIndexWithinParent();
              elementKey = parent.__key;
              if (!isBackward) {
                offset++;
              }
            }
            focus.set(elementKey, offset, "element");
            if (collapse) {
              anchor.set(elementKey, offset, "element");
            }
            return;
          } else {
            const siblingKey = sibling.__key;
            const offset = isBackward ? sibling.getTextContent().length : 0;
            focus.set(siblingKey, offset, "text");
            if (collapse) {
              anchor.set(siblingKey, offset, "text");
            }
            return;
          }
        }
        const editor = getActiveEditor();
        const domSelection = getDOMSelection(editor._window);
        if (!domSelection) {
          return;
        }
        const blockCursorElement = editor._blockCursorElement;
        const rootElement = editor._rootElement;
        if (rootElement !== null && blockCursorElement !== null && $isElementNode2(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty()) {
          removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
        }
        moveNativeSelection(domSelection, alter, isBackward ? "backward" : "forward", granularity);
        if (domSelection.rangeCount > 0) {
          const range = domSelection.getRangeAt(0);
          const anchorNode = this.anchor.getNode();
          const root2 = $isRootNode2(anchorNode) ? anchorNode : $getNearestRootOrShadowRoot(anchorNode);
          this.applyDOMRange(range);
          this.dirty = true;
          if (!collapse) {
            const nodes = this.getNodes();
            const validNodes = [];
            let shrinkSelection = false;
            for (let i = 0; i < nodes.length; i++) {
              const nextNode = nodes[i];
              if ($hasAncestor(nextNode, root2)) {
                validNodes.push(nextNode);
              } else {
                shrinkSelection = true;
              }
            }
            if (shrinkSelection && validNodes.length > 0) {
              if (isBackward) {
                const firstValidNode = validNodes[0];
                if ($isElementNode2(firstValidNode)) {
                  firstValidNode.selectStart();
                } else {
                  firstValidNode.getParentOrThrow().selectStart();
                }
              } else {
                const lastValidNode = validNodes[validNodes.length - 1];
                if ($isElementNode2(lastValidNode)) {
                  lastValidNode.selectEnd();
                } else {
                  lastValidNode.getParentOrThrow().selectEnd();
                }
              }
            }
            if (domSelection.anchorNode !== range.startContainer || domSelection.anchorOffset !== range.startOffset) {
              $swapPoints(this);
            }
          }
        }
      }
      /**
       * Performs one logical character deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteCharacter(isBackward) {
        const wasCollapsed = this.isCollapsed();
        if (this.isCollapsed()) {
          const anchor = this.anchor;
          const focus = this.focus;
          let anchorNode = anchor.getNode();
          if (!isBackward && // Delete forward handle case
          (anchor.type === "element" && $isElementNode2(anchorNode) && anchor.offset === anchorNode.getChildrenSize() || anchor.type === "text" && anchor.offset === anchorNode.getTextContentSize())) {
            const parent = anchorNode.getParent();
            const nextSibling = anchorNode.getNextSibling() || (parent === null ? null : parent.getNextSibling());
            if ($isElementNode2(nextSibling) && nextSibling.isShadowRoot()) {
              return;
            }
          }
          const possibleNode = $getAdjacentNode(focus, isBackward);
          if ($isDecoratorNode2(possibleNode) && !possibleNode.isIsolated()) {
            if (possibleNode.isKeyboardSelectable() && $isElementNode2(anchorNode) && anchorNode.getChildrenSize() === 0) {
              anchorNode.remove();
              const nodeSelection = $createNodeSelection();
              nodeSelection.add(possibleNode.__key);
              $setSelection2(nodeSelection);
            } else {
              possibleNode.remove();
              const editor = getActiveEditor();
              editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
            }
            return;
          } else if (!isBackward && $isElementNode2(possibleNode) && $isElementNode2(anchorNode) && anchorNode.isEmpty()) {
            anchorNode.remove();
            possibleNode.selectStart();
            return;
          }
          this.modify("extend", isBackward, "character");
          if (!this.isCollapsed()) {
            const focusNode = focus.type === "text" ? focus.getNode() : null;
            anchorNode = anchor.type === "text" ? anchor.getNode() : null;
            if (focusNode !== null && focusNode.isSegmented()) {
              const offset = focus.offset;
              const textContentSize = focusNode.getTextContentSize();
              if (focusNode.is(anchorNode) || isBackward && offset !== textContentSize || !isBackward && offset !== 0) {
                $removeSegment(focusNode, isBackward, offset);
                return;
              }
            } else if (anchorNode !== null && anchorNode.isSegmented()) {
              const offset = anchor.offset;
              const textContentSize = anchorNode.getTextContentSize();
              if (anchorNode.is(focusNode) || isBackward && offset !== 0 || !isBackward && offset !== textContentSize) {
                $removeSegment(anchorNode, isBackward, offset);
                return;
              }
            }
            $updateCaretSelectionForUnicodeCharacter(this, isBackward);
          } else if (isBackward && anchor.offset === 0) {
            const element = anchor.type === "element" ? anchor.getNode() : anchor.getNode().getParentOrThrow();
            if (element.collapseAtStart(this)) {
              return;
            }
          }
        }
        this.removeText();
        if (isBackward && !wasCollapsed && this.isCollapsed() && this.anchor.type === "element" && this.anchor.offset === 0) {
          const anchorNode = this.anchor.getNode();
          if (anchorNode.isEmpty() && $isRootNode2(anchorNode.getParent()) && anchorNode.getIndexWithinParent() === 0) {
            anchorNode.collapseAtStart(this);
          }
        }
      }
      /**
       * Performs one logical line deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteLine(isBackward) {
        if (this.isCollapsed()) {
          if (this.anchor.type === "text") {
            this.modify("extend", isBackward, "lineboundary");
          }
          const endPoint = isBackward ? this.focus : this.anchor;
          if (endPoint.offset === 0) {
            this.modify("extend", isBackward, "character");
          }
        }
        this.removeText();
      }
      /**
       * Performs one logical word deletion operation on the EditorState based on the current Selection.
       * Handles different node types.
       *
       * @param isBackward whether or not the selection is backwards.
       */
      deleteWord(isBackward) {
        if (this.isCollapsed()) {
          this.modify("extend", isBackward, "word");
        }
        this.removeText();
      }
    };
    function $isNodeSelection(x) {
      return x instanceof NodeSelection;
    }
    function getCharacterOffset(point) {
      const offset = point.offset;
      if (point.type === "text") {
        return offset;
      }
      const parent = point.getNode();
      return offset === parent.getChildrenSize() ? parent.getTextContent().length : 0;
    }
    function getCharacterOffsets(selection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      if (anchor.type === "element" && focus.type === "element" && anchor.key === focus.key && anchor.offset === focus.offset) {
        return [0, 0];
      }
      return [getCharacterOffset(anchor), getCharacterOffset(focus)];
    }
    function $swapPoints(selection) {
      const focus = selection.focus;
      const anchor = selection.anchor;
      const anchorKey = anchor.key;
      const anchorOffset = anchor.offset;
      const anchorType = anchor.type;
      $setPointValues(anchor, focus.key, focus.offset, focus.type);
      $setPointValues(focus, anchorKey, anchorOffset, anchorType);
      selection._cachedNodes = null;
    }
    function moveNativeSelection(domSelection, alter, direction, granularity) {
      domSelection.modify(alter, direction, granularity);
    }
    function $updateCaretSelectionForUnicodeCharacter(selection, isBackward) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (anchorNode === focusNode && anchor.type === "text" && focus.type === "text") {
        const anchorOffset = anchor.offset;
        const focusOffset = focus.offset;
        const isBefore = anchorOffset < focusOffset;
        const startOffset = isBefore ? anchorOffset : focusOffset;
        const endOffset = isBefore ? focusOffset : anchorOffset;
        const characterOffset = endOffset - 1;
        if (startOffset !== characterOffset) {
          const text2 = anchorNode.getTextContent().slice(startOffset, endOffset);
          if (!doesContainGrapheme(text2)) {
            if (isBackward) {
              focus.offset = characterOffset;
            } else {
              anchor.offset = characterOffset;
            }
          }
        }
      }
    }
    function $removeSegment(node, isBackward, offset) {
      const textNode = node;
      const textContent = textNode.getTextContent();
      const split = textContent.split(/(?=\s)/g);
      const splitLength = split.length;
      let segmentOffset = 0;
      let restoreOffset = 0;
      for (let i = 0; i < splitLength; i++) {
        const text2 = split[i];
        const isLast = i === splitLength - 1;
        restoreOffset = segmentOffset;
        segmentOffset += text2.length;
        if (isBackward && segmentOffset === offset || segmentOffset > offset || isLast) {
          split.splice(i, 1);
          if (isLast) {
            restoreOffset = void 0;
          }
          break;
        }
      }
      const nextTextContent = split.join("").trim();
      if (nextTextContent === "") {
        textNode.remove();
      } else {
        textNode.setTextContent(nextTextContent);
        textNode.select(restoreOffset, restoreOffset);
      }
    }
    function shouldResolveAncestor(resolvedElement, resolvedOffset, lastPoint) {
      const parent = resolvedElement.getParent();
      return lastPoint === null || parent === null || !parent.canBeEmpty() || parent !== lastPoint.getNode();
    }
    function internalResolveSelectionPoint(dom, offset, lastPoint, editor) {
      let resolvedOffset = offset;
      let resolvedNode;
      if (dom.nodeType === DOM_ELEMENT_TYPE) {
        let moveSelectionToEnd = false;
        const childNodes = dom.childNodes;
        const childNodesLength = childNodes.length;
        if (resolvedOffset === childNodesLength) {
          moveSelectionToEnd = true;
          resolvedOffset = childNodesLength - 1;
        }
        let childDOM = childNodes[resolvedOffset];
        let hasBlockCursor = false;
        if (childDOM === editor._blockCursorElement) {
          childDOM = childNodes[resolvedOffset + 1];
          hasBlockCursor = true;
        } else if (editor._blockCursorElement !== null) {
          resolvedOffset--;
        }
        resolvedNode = getNodeFromDOM(childDOM);
        if ($isTextNode2(resolvedNode)) {
          resolvedOffset = getTextNodeOffset(resolvedNode, moveSelectionToEnd);
        } else {
          let resolvedElement = getNodeFromDOM(dom);
          if (resolvedElement === null) {
            return null;
          }
          if ($isElementNode2(resolvedElement)) {
            let child = resolvedElement.getChildAtIndex(resolvedOffset);
            if ($isElementNode2(child) && shouldResolveAncestor(child, resolvedOffset, lastPoint)) {
              const descendant = moveSelectionToEnd ? child.getLastDescendant() : child.getFirstDescendant();
              if (descendant === null) {
                resolvedElement = child;
                resolvedOffset = 0;
              } else {
                child = descendant;
                resolvedElement = $isElementNode2(child) ? child : child.getParentOrThrow();
              }
            }
            if ($isTextNode2(child)) {
              resolvedNode = child;
              resolvedElement = null;
              resolvedOffset = getTextNodeOffset(child, moveSelectionToEnd);
            } else if (child !== resolvedElement && moveSelectionToEnd && !hasBlockCursor) {
              resolvedOffset++;
            }
          } else {
            const index = resolvedElement.getIndexWithinParent();
            if (offset === 0 && $isDecoratorNode2(resolvedElement) && getNodeFromDOM(dom) === resolvedElement) {
              resolvedOffset = index;
            } else {
              resolvedOffset = index + 1;
            }
            resolvedElement = resolvedElement.getParentOrThrow();
          }
          if ($isElementNode2(resolvedElement)) {
            return $createPoint(resolvedElement.__key, resolvedOffset, "element");
          }
        }
      } else {
        resolvedNode = getNodeFromDOM(dom);
      }
      if (!$isTextNode2(resolvedNode)) {
        return null;
      }
      return $createPoint(resolvedNode.__key, resolvedOffset, "text");
    }
    function resolveSelectionPointOnBoundary(point, isBackward, isCollapsed) {
      const offset = point.offset;
      const node = point.getNode();
      if (offset === 0) {
        const prevSibling = node.getPreviousSibling();
        const parent = node.getParent();
        if (!isBackward) {
          if ($isElementNode2(prevSibling) && !isCollapsed && prevSibling.isInline()) {
            point.key = prevSibling.__key;
            point.offset = prevSibling.getChildrenSize();
            point.type = "element";
          } else if ($isTextNode2(prevSibling)) {
            point.key = prevSibling.__key;
            point.offset = prevSibling.getTextContent().length;
          }
        } else if ((isCollapsed || !isBackward) && prevSibling === null && $isElementNode2(parent) && parent.isInline()) {
          const parentSibling = parent.getPreviousSibling();
          if ($isTextNode2(parentSibling)) {
            point.key = parentSibling.__key;
            point.offset = parentSibling.getTextContent().length;
          }
        }
      } else if (offset === node.getTextContent().length) {
        const nextSibling = node.getNextSibling();
        const parent = node.getParent();
        if (isBackward && $isElementNode2(nextSibling) && nextSibling.isInline()) {
          point.key = nextSibling.__key;
          point.offset = 0;
          point.type = "element";
        } else if ((isCollapsed || isBackward) && nextSibling === null && $isElementNode2(parent) && parent.isInline() && !parent.canInsertTextAfter()) {
          const parentSibling = parent.getNextSibling();
          if ($isTextNode2(parentSibling)) {
            point.key = parentSibling.__key;
            point.offset = 0;
          }
        }
      }
    }
    function normalizeSelectionPointsForBoundaries(anchor, focus, lastSelection) {
      if (anchor.type === "text" && focus.type === "text") {
        const isBackward = anchor.isBefore(focus);
        const isCollapsed = anchor.is(focus);
        resolveSelectionPointOnBoundary(anchor, isBackward, isCollapsed);
        resolveSelectionPointOnBoundary(focus, !isBackward, isCollapsed);
        if (isCollapsed) {
          focus.key = anchor.key;
          focus.offset = anchor.offset;
          focus.type = anchor.type;
        }
        const editor = getActiveEditor();
        if (editor.isComposing() && editor._compositionKey !== anchor.key && $isRangeSelection2(lastSelection)) {
          const lastAnchor = lastSelection.anchor;
          const lastFocus = lastSelection.focus;
          $setPointValues(anchor, lastAnchor.key, lastAnchor.offset, lastAnchor.type);
          $setPointValues(focus, lastFocus.key, lastFocus.offset, lastFocus.type);
        }
      }
    }
    function internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection) {
      if (anchorDOM === null || focusDOM === null || !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return null;
      }
      const resolvedAnchorPoint = internalResolveSelectionPoint(anchorDOM, anchorOffset, $isRangeSelection2(lastSelection) ? lastSelection.anchor : null, editor);
      if (resolvedAnchorPoint === null) {
        return null;
      }
      const resolvedFocusPoint = internalResolveSelectionPoint(focusDOM, focusOffset, $isRangeSelection2(lastSelection) ? lastSelection.focus : null, editor);
      if (resolvedFocusPoint === null) {
        return null;
      }
      if (resolvedAnchorPoint.type === "element" && resolvedFocusPoint.type === "element") {
        const anchorNode = getNodeFromDOM(anchorDOM);
        const focusNode = getNodeFromDOM(focusDOM);
        if ($isDecoratorNode2(anchorNode) && $isDecoratorNode2(focusNode)) {
          return null;
        }
      }
      normalizeSelectionPointsForBoundaries(resolvedAnchorPoint, resolvedFocusPoint, lastSelection);
      return [resolvedAnchorPoint, resolvedFocusPoint];
    }
    function $isBlockElementNode(node) {
      return $isElementNode2(node) && !node.isInline();
    }
    function internalMakeRangeSelection(anchorKey, anchorOffset, focusKey, focusOffset, anchorType, focusType) {
      const editorState = getActiveEditorState();
      const selection = new RangeSelection($createPoint(anchorKey, anchorOffset, anchorType), $createPoint(focusKey, focusOffset, focusType), 0, "");
      selection.dirty = true;
      editorState._selection = selection;
      return selection;
    }
    function $createRangeSelection() {
      const anchor = $createPoint("root", 0, "element");
      const focus = $createPoint("root", 0, "element");
      return new RangeSelection(anchor, focus, 0, "");
    }
    function $createNodeSelection() {
      return new NodeSelection(/* @__PURE__ */ new Set());
    }
    function DEPRECATED_$createGridSelection() {
      const anchor = $createPoint("root", 0, "element");
      const focus = $createPoint("root", 0, "element");
      return new GridSelection("root", anchor, focus);
    }
    function internalCreateSelection(editor) {
      const currentEditorState = editor.getEditorState();
      const lastSelection = currentEditorState._selection;
      const domSelection = getDOMSelection(editor._window);
      if ($isNodeSelection(lastSelection) || DEPRECATED_$isGridSelection(lastSelection)) {
        return lastSelection.clone();
      }
      return internalCreateRangeSelection(lastSelection, domSelection, editor);
    }
    function internalCreateRangeSelection(lastSelection, domSelection, editor) {
      const windowObj = editor._window;
      if (windowObj === null) {
        return null;
      }
      const windowEvent = windowObj.event;
      const eventType = windowEvent ? windowEvent.type : void 0;
      const isSelectionChange = eventType === "selectionchange";
      const useDOMSelection = !getIsProcesssingMutations() && (isSelectionChange || eventType === "beforeinput" || eventType === "compositionstart" || eventType === "compositionend" || eventType === "click" && windowEvent && windowEvent.detail === 3 || eventType === "drop" || eventType === void 0);
      let anchorDOM, focusDOM, anchorOffset, focusOffset;
      if (!$isRangeSelection2(lastSelection) || useDOMSelection) {
        if (domSelection === null) {
          return null;
        }
        anchorDOM = domSelection.anchorNode;
        focusDOM = domSelection.focusNode;
        anchorOffset = domSelection.anchorOffset;
        focusOffset = domSelection.focusOffset;
        if (isSelectionChange && $isRangeSelection2(lastSelection) && !isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
          return lastSelection.clone();
        }
      } else {
        return lastSelection.clone();
      }
      const resolvedSelectionPoints = internalResolveSelectionPoints(anchorDOM, anchorOffset, focusDOM, focusOffset, editor, lastSelection);
      if (resolvedSelectionPoints === null) {
        return null;
      }
      const [resolvedAnchorPoint, resolvedFocusPoint] = resolvedSelectionPoints;
      return new RangeSelection(resolvedAnchorPoint, resolvedFocusPoint, !$isRangeSelection2(lastSelection) ? 0 : lastSelection.format, !$isRangeSelection2(lastSelection) ? "" : lastSelection.style);
    }
    function $getSelection2() {
      const editorState = getActiveEditorState();
      return editorState._selection;
    }
    function $getPreviousSelection() {
      const editor = getActiveEditor();
      return editor._editorState._selection;
    }
    function $updateElementSelectionOnCreateDeleteNode(selection, parentNode, nodeOffset, times = 1) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (!parentNode.is(anchorNode) && !parentNode.is(focusNode)) {
        return;
      }
      const parentKey = parentNode.__key;
      if (selection.isCollapsed()) {
        const selectionOffset = anchor.offset;
        if (nodeOffset <= selectionOffset && times > 0 || nodeOffset < selectionOffset && times < 0) {
          const newSelectionOffset = Math.max(0, selectionOffset + times);
          anchor.set(parentKey, newSelectionOffset, "element");
          focus.set(parentKey, newSelectionOffset, "element");
          $updateSelectionResolveTextNodes(selection);
        }
      } else {
        const isBackward = selection.isBackward();
        const firstPoint = isBackward ? focus : anchor;
        const firstPointNode = firstPoint.getNode();
        const lastPoint = isBackward ? anchor : focus;
        const lastPointNode = lastPoint.getNode();
        if (parentNode.is(firstPointNode)) {
          const firstPointOffset = firstPoint.offset;
          if (nodeOffset <= firstPointOffset && times > 0 || nodeOffset < firstPointOffset && times < 0) {
            firstPoint.set(parentKey, Math.max(0, firstPointOffset + times), "element");
          }
        }
        if (parentNode.is(lastPointNode)) {
          const lastPointOffset = lastPoint.offset;
          if (nodeOffset <= lastPointOffset && times > 0 || nodeOffset < lastPointOffset && times < 0) {
            lastPoint.set(parentKey, Math.max(0, lastPointOffset + times), "element");
          }
        }
      }
      $updateSelectionResolveTextNodes(selection);
    }
    function $updateSelectionResolveTextNodes(selection) {
      const anchor = selection.anchor;
      const anchorOffset = anchor.offset;
      const focus = selection.focus;
      const focusOffset = focus.offset;
      const anchorNode = anchor.getNode();
      const focusNode = focus.getNode();
      if (selection.isCollapsed()) {
        if (!$isElementNode2(anchorNode)) {
          return;
        }
        const childSize = anchorNode.getChildrenSize();
        const anchorOffsetAtEnd = anchorOffset >= childSize;
        const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
        if ($isTextNode2(child)) {
          let newOffset = 0;
          if (anchorOffsetAtEnd) {
            newOffset = child.getTextContentSize();
          }
          anchor.set(child.__key, newOffset, "text");
          focus.set(child.__key, newOffset, "text");
        }
        return;
      }
      if ($isElementNode2(anchorNode)) {
        const childSize = anchorNode.getChildrenSize();
        const anchorOffsetAtEnd = anchorOffset >= childSize;
        const child = anchorOffsetAtEnd ? anchorNode.getChildAtIndex(childSize - 1) : anchorNode.getChildAtIndex(anchorOffset);
        if ($isTextNode2(child)) {
          let newOffset = 0;
          if (anchorOffsetAtEnd) {
            newOffset = child.getTextContentSize();
          }
          anchor.set(child.__key, newOffset, "text");
        }
      }
      if ($isElementNode2(focusNode)) {
        const childSize = focusNode.getChildrenSize();
        const focusOffsetAtEnd = focusOffset >= childSize;
        const child = focusOffsetAtEnd ? focusNode.getChildAtIndex(childSize - 1) : focusNode.getChildAtIndex(focusOffset);
        if ($isTextNode2(child)) {
          let newOffset = 0;
          if (focusOffsetAtEnd) {
            newOffset = child.getTextContentSize();
          }
          focus.set(child.__key, newOffset, "text");
        }
      }
    }
    function applySelectionTransforms(nextEditorState, editor) {
      const prevEditorState = editor.getEditorState();
      const prevSelection = prevEditorState._selection;
      const nextSelection = nextEditorState._selection;
      if ($isRangeSelection2(nextSelection)) {
        const anchor = nextSelection.anchor;
        const focus = nextSelection.focus;
        let anchorNode;
        if (anchor.type === "text") {
          anchorNode = anchor.getNode();
          anchorNode.selectionTransform(prevSelection, nextSelection);
        }
        if (focus.type === "text") {
          const focusNode = focus.getNode();
          if (anchorNode !== focusNode) {
            focusNode.selectionTransform(prevSelection, nextSelection);
          }
        }
      }
    }
    function moveSelectionPointToSibling(point, node, parent, prevSibling, nextSibling) {
      let siblingKey = null;
      let offset = 0;
      let type = null;
      if (prevSibling !== null) {
        siblingKey = prevSibling.__key;
        if ($isTextNode2(prevSibling)) {
          offset = prevSibling.getTextContentSize();
          type = "text";
        } else if ($isElementNode2(prevSibling)) {
          offset = prevSibling.getChildrenSize();
          type = "element";
        }
      } else {
        if (nextSibling !== null) {
          siblingKey = nextSibling.__key;
          if ($isTextNode2(nextSibling)) {
            type = "text";
          } else if ($isElementNode2(nextSibling)) {
            type = "element";
          }
        }
      }
      if (siblingKey !== null && type !== null) {
        point.set(siblingKey, offset, type);
      } else {
        offset = node.getIndexWithinParent();
        if (offset === -1) {
          offset = parent.getChildrenSize();
        }
        point.set(parent.__key, offset, "element");
      }
    }
    function adjustPointOffsetForMergedSibling(point, isBefore, key, target, textLength) {
      if (point.type === "text") {
        point.key = key;
        if (!isBefore) {
          point.offset += textLength;
        }
      } else if (point.offset > target.getIndexWithinParent()) {
        point.offset -= 1;
      }
    }
    function updateDOMSelection(prevSelection, nextSelection, editor, domSelection, tags, rootElement, nodeCount) {
      const anchorDOMNode = domSelection.anchorNode;
      const focusDOMNode = domSelection.focusNode;
      const anchorOffset = domSelection.anchorOffset;
      const focusOffset = domSelection.focusOffset;
      const activeElement = document.activeElement;
      if (tags.has("collaboration") && activeElement !== rootElement || activeElement !== null && isSelectionCapturedInDecoratorInput(activeElement)) {
        return;
      }
      if (!$isRangeSelection2(nextSelection)) {
        if (prevSelection !== null && isSelectionWithinEditor(editor, anchorDOMNode, focusDOMNode)) {
          domSelection.removeAllRanges();
        }
        return;
      }
      const anchor = nextSelection.anchor;
      const focus = nextSelection.focus;
      const anchorKey = anchor.key;
      const focusKey = focus.key;
      const anchorDOM = getElementByKeyOrThrow(editor, anchorKey);
      const focusDOM = getElementByKeyOrThrow(editor, focusKey);
      const nextAnchorOffset = anchor.offset;
      const nextFocusOffset = focus.offset;
      const nextFormat = nextSelection.format;
      const nextStyle = nextSelection.style;
      const isCollapsed = nextSelection.isCollapsed();
      let nextAnchorNode = anchorDOM;
      let nextFocusNode = focusDOM;
      let anchorFormatOrStyleChanged = false;
      if (anchor.type === "text") {
        nextAnchorNode = getDOMTextNode(anchorDOM);
        const anchorNode = anchor.getNode();
        anchorFormatOrStyleChanged = anchorNode.getFormat() !== nextFormat || anchorNode.getStyle() !== nextStyle;
      } else if ($isRangeSelection2(prevSelection) && prevSelection.anchor.type === "text") {
        anchorFormatOrStyleChanged = true;
      }
      if (focus.type === "text") {
        nextFocusNode = getDOMTextNode(focusDOM);
      }
      if (nextAnchorNode === null || nextFocusNode === null) {
        return;
      }
      if (isCollapsed && (prevSelection === null || anchorFormatOrStyleChanged || $isRangeSelection2(prevSelection) && (prevSelection.format !== nextFormat || prevSelection.style !== nextStyle))) {
        markCollapsedSelectionFormat(nextFormat, nextStyle, nextAnchorOffset, anchorKey, performance.now());
      }
      if (anchorOffset === nextAnchorOffset && focusOffset === nextFocusOffset && anchorDOMNode === nextAnchorNode && focusDOMNode === nextFocusNode && // Badly interpreted range selection when collapsed - #1482
      !(domSelection.type === "Range" && isCollapsed)) {
        if (activeElement === null || !rootElement.contains(activeElement)) {
          rootElement.focus({
            preventScroll: true
          });
        }
        if (anchor.type !== "element") {
          return;
        }
      }
      try {
        domSelection.setBaseAndExtent(nextAnchorNode, nextAnchorOffset, nextFocusNode, nextFocusOffset);
      } catch (error) {
      }
      if (!tags.has("skip-scroll-into-view") && nextSelection.isCollapsed() && rootElement !== null && rootElement === document.activeElement) {
        const selectionTarget = nextSelection instanceof RangeSelection && nextSelection.anchor.type === "element" ? nextAnchorNode.childNodes[nextAnchorOffset] || null : domSelection.rangeCount > 0 ? domSelection.getRangeAt(0) : null;
        if (selectionTarget !== null) {
          let selectionRect;
          if (selectionTarget instanceof Text) {
            const range = document.createRange();
            range.selectNode(selectionTarget);
            selectionRect = range.getBoundingClientRect();
          } else {
            selectionRect = selectionTarget.getBoundingClientRect();
          }
          scrollIntoViewIfNeeded(editor, selectionRect, rootElement);
        }
      }
      markSelectionChangeFromDOMUpdate();
    }
    function $insertNodes2(nodes, selectStart) {
      let selection = $getSelection2() || $getPreviousSelection();
      if (selection === null) {
        selection = $getRoot2().selectEnd();
      }
      return selection.insertNodes(nodes, selectStart);
    }
    function $getTextContent() {
      const selection = $getSelection2();
      if (selection === null) {
        return "";
      }
      return selection.getTextContent();
    }
    function DEPRECATED_$computeGridMap(grid, cellA, cellB) {
      const tableMap = [];
      let cellAValue = null;
      let cellBValue = null;
      function write(startRow, startColumn, cell) {
        const value = {
          cell,
          startColumn,
          startRow
        };
        const rowSpan = cell.__rowSpan;
        const colSpan = cell.__colSpan;
        for (let i = 0; i < rowSpan; i++) {
          if (tableMap[startRow + i] === void 0) {
            tableMap[startRow + i] = [];
          }
          for (let j = 0; j < colSpan; j++) {
            tableMap[startRow + i][startColumn + j] = value;
          }
        }
        if (cellA.is(cell)) {
          cellAValue = value;
        }
        if (cellB.is(cell)) {
          cellBValue = value;
        }
      }
      function isEmpty(row, column) {
        return tableMap[row] === void 0 || tableMap[row][column] === void 0;
      }
      const gridChildren = grid.getChildren();
      for (let i = 0; i < gridChildren.length; i++) {
        const row = gridChildren[i];
        if (!DEPRECATED_$isGridRowNode(row)) {
          throw Error(`Expected GridNode children to be GridRowNode`);
        }
        const rowChildren = row.getChildren();
        let j = 0;
        for (const cell of rowChildren) {
          if (!DEPRECATED_$isGridCellNode(cell)) {
            throw Error(`Expected GridRowNode children to be GridCellNode`);
          }
          while (!isEmpty(i, j)) {
            j++;
          }
          write(i, j, cell);
          j += cell.__colSpan;
        }
      }
      if (!(cellAValue !== null)) {
        throw Error(`Anchor not found in Grid`);
      }
      if (!(cellBValue !== null)) {
        throw Error(`Focus not found in Grid`);
      }
      return [tableMap, cellAValue, cellBValue];
    }
    function DEPRECATED_$getNodeTriplet(source) {
      let cell;
      if (source instanceof DEPRECATED_GridCellNode) {
        cell = source;
      } else if (source instanceof LexicalNode) {
        const cell_ = $findMatchingParent2(source, DEPRECATED_$isGridCellNode);
        if (!DEPRECATED_$isGridCellNode(cell_)) {
          throw Error(`Expected to find a parent GridCellNode`);
        }
        cell = cell_;
      } else {
        const cell_ = $findMatchingParent2(source.getNode(), DEPRECATED_$isGridCellNode);
        if (!DEPRECATED_$isGridCellNode(cell_)) {
          throw Error(`Expected to find a parent GridCellNode`);
        }
        cell = cell_;
      }
      const row = cell.getParent();
      if (!DEPRECATED_$isGridRowNode(row)) {
        throw Error(`Expected GridCellNode to have a parent GridRowNode`);
      }
      const grid = row.getParent();
      if (!DEPRECATED_$isGridNode(grid)) {
        throw Error(`Expected GridRowNode to have a parent GridNode`);
      }
      return [cell, row, grid];
    }
    var activeEditorState = null;
    var activeEditor = null;
    var isReadOnlyMode = false;
    var isAttemptingToRecoverFromReconcilerError = false;
    var infiniteTransformCount = 0;
    var observerOptions = {
      characterData: true,
      childList: true,
      subtree: true
    };
    function isCurrentlyReadOnlyMode() {
      return isReadOnlyMode || activeEditorState !== null && activeEditorState._readOnly;
    }
    function errorOnReadOnly() {
      if (isReadOnlyMode) {
        {
          throw Error(`Cannot use method in read-only mode.`);
        }
      }
    }
    function errorOnInfiniteTransforms() {
      if (infiniteTransformCount > 99) {
        {
          throw Error(`One or more transforms are endlessly triggering additional transforms. May have encountered infinite recursion caused by transforms that have their preconditions too lose and/or conflict with each other.`);
        }
      }
    }
    function getActiveEditorState() {
      if (activeEditorState === null) {
        {
          throw Error(`Unable to find an active editor state. State helpers or node methods can only be used synchronously during the callback of editor.update() or editorState.read().`);
        }
      }
      return activeEditorState;
    }
    function getActiveEditor() {
      if (activeEditor === null) {
        {
          throw Error(`Unable to find an active editor. This method can only be used synchronously during the callback of editor.update().`);
        }
      }
      return activeEditor;
    }
    function internalGetActiveEditor() {
      return activeEditor;
    }
    function $applyTransforms(editor, node, transformsCache) {
      const type = node.__type;
      const registeredNode = getRegisteredNodeOrThrow(editor, type);
      let transformsArr = transformsCache.get(type);
      if (transformsArr === void 0) {
        transformsArr = Array.from(registeredNode.transforms);
        transformsCache.set(type, transformsArr);
      }
      const transformsArrLength = transformsArr.length;
      for (let i = 0; i < transformsArrLength; i++) {
        transformsArr[i](node);
        if (!node.isAttached()) {
          break;
        }
      }
    }
    function $isNodeValidForTransform(node, compositionKey) {
      return node !== void 0 && // We don't want to transform nodes being composed
      node.__key !== compositionKey && node.isAttached();
    }
    function $normalizeAllDirtyTextNodes(editorState, editor) {
      const dirtyLeaves = editor._dirtyLeaves;
      const nodeMap = editorState._nodeMap;
      for (const nodeKey of dirtyLeaves) {
        const node = nodeMap.get(nodeKey);
        if ($isTextNode2(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
          $normalizeTextNode(node);
        }
      }
    }
    function $applyAllTransforms(editorState, editor) {
      const dirtyLeaves = editor._dirtyLeaves;
      const dirtyElements = editor._dirtyElements;
      const nodeMap = editorState._nodeMap;
      const compositionKey = $getCompositionKey();
      const transformsCache = /* @__PURE__ */ new Map();
      let untransformedDirtyLeaves = dirtyLeaves;
      let untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
      let untransformedDirtyElements = dirtyElements;
      let untransformedDirtyElementsLength = untransformedDirtyElements.size;
      while (untransformedDirtyLeavesLength > 0 || untransformedDirtyElementsLength > 0) {
        if (untransformedDirtyLeavesLength > 0) {
          editor._dirtyLeaves = /* @__PURE__ */ new Set();
          for (const nodeKey of untransformedDirtyLeaves) {
            const node = nodeMap.get(nodeKey);
            if ($isTextNode2(node) && node.isAttached() && node.isSimpleText() && !node.isUnmergeable()) {
              $normalizeTextNode(node);
            }
            if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
              $applyTransforms(editor, node, transformsCache);
            }
            dirtyLeaves.add(nodeKey);
          }
          untransformedDirtyLeaves = editor._dirtyLeaves;
          untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
          if (untransformedDirtyLeavesLength > 0) {
            infiniteTransformCount++;
            continue;
          }
        }
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        editor._dirtyElements = /* @__PURE__ */ new Map();
        for (const currentUntransformedDirtyElement of untransformedDirtyElements) {
          const nodeKey = currentUntransformedDirtyElement[0];
          const intentionallyMarkedAsDirty = currentUntransformedDirtyElement[1];
          if (nodeKey !== "root" && !intentionallyMarkedAsDirty) {
            continue;
          }
          const node = nodeMap.get(nodeKey);
          if (node !== void 0 && $isNodeValidForTransform(node, compositionKey)) {
            $applyTransforms(editor, node, transformsCache);
          }
          dirtyElements.set(nodeKey, intentionallyMarkedAsDirty);
        }
        untransformedDirtyLeaves = editor._dirtyLeaves;
        untransformedDirtyLeavesLength = untransformedDirtyLeaves.size;
        untransformedDirtyElements = editor._dirtyElements;
        untransformedDirtyElementsLength = untransformedDirtyElements.size;
        infiniteTransformCount++;
      }
      editor._dirtyLeaves = dirtyLeaves;
      editor._dirtyElements = dirtyElements;
    }
    function $parseSerializedNode(serializedNode) {
      const internalSerializedNode = serializedNode;
      return $parseSerializedNodeImpl(internalSerializedNode, getActiveEditor()._nodes);
    }
    function $parseSerializedNodeImpl(serializedNode, registeredNodes) {
      const type = serializedNode.type;
      const registeredNode = registeredNodes.get(type);
      if (registeredNode === void 0) {
        {
          throw Error(`parseEditorState: type "${type}" + not found`);
        }
      }
      const nodeClass = registeredNode.klass;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .importJSON().`);
        }
      }
      const node = nodeClass.importJSON(serializedNode);
      const children = serializedNode.children;
      if ($isElementNode2(node) && Array.isArray(children)) {
        for (let i = 0; i < children.length; i++) {
          const serializedJSONChildNode = children[i];
          const childNode = $parseSerializedNodeImpl(serializedJSONChildNode, registeredNodes);
          node.append(childNode);
        }
      }
      return node;
    }
    function parseEditorState(serializedEditorState, editor, updateFn) {
      const editorState = createEmptyEditorState();
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      const previousDirtyElements = editor._dirtyElements;
      const previousDirtyLeaves = editor._dirtyLeaves;
      const previousCloneNotNeeded = editor._cloneNotNeeded;
      const previousDirtyType = editor._dirtyType;
      editor._dirtyElements = /* @__PURE__ */ new Map();
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._cloneNotNeeded = /* @__PURE__ */ new Set();
      editor._dirtyType = 0;
      activeEditorState = editorState;
      isReadOnlyMode = false;
      activeEditor = editor;
      try {
        const registeredNodes = editor._nodes;
        const serializedNode = serializedEditorState.root;
        $parseSerializedNodeImpl(serializedNode, registeredNodes);
        if (updateFn) {
          updateFn();
        }
        editorState._readOnly = true;
        {
          handleDEVOnlyPendingUpdateGuarantees(editorState);
        }
      } catch (error) {
        if (error instanceof Error) {
          editor._onError(error);
        }
      } finally {
        editor._dirtyElements = previousDirtyElements;
        editor._dirtyLeaves = previousDirtyLeaves;
        editor._cloneNotNeeded = previousCloneNotNeeded;
        editor._dirtyType = previousDirtyType;
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
      }
      return editorState;
    }
    function readEditorState(editorState, callbackFn) {
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      activeEditorState = editorState;
      isReadOnlyMode = true;
      activeEditor = null;
      try {
        return callbackFn();
      } finally {
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
      }
    }
    function handleDEVOnlyPendingUpdateGuarantees(pendingEditorState) {
      const nodeMap = pendingEditorState._nodeMap;
      nodeMap.set = () => {
        throw new Error("Cannot call set() on a frozen Lexical node map");
      };
      nodeMap.clear = () => {
        throw new Error("Cannot call clear() on a frozen Lexical node map");
      };
      nodeMap.delete = () => {
        throw new Error("Cannot call delete() on a frozen Lexical node map");
      };
    }
    function commitPendingUpdates(editor, recoveryEditorState) {
      const pendingEditorState = editor._pendingEditorState;
      const rootElement = editor._rootElement;
      const shouldSkipDOM = editor._headless || rootElement === null;
      if (pendingEditorState === null) {
        return;
      }
      const currentEditorState = editor._editorState;
      const currentSelection = currentEditorState._selection;
      const pendingSelection = pendingEditorState._selection;
      const needsUpdate = editor._dirtyType !== NO_DIRTY_NODES;
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      const previouslyUpdating = editor._updating;
      const observer = editor._observer;
      let mutatedNodes2 = null;
      editor._pendingEditorState = null;
      editor._editorState = pendingEditorState;
      if (!shouldSkipDOM && needsUpdate && observer !== null) {
        activeEditor = editor;
        activeEditorState = pendingEditorState;
        isReadOnlyMode = false;
        editor._updating = true;
        try {
          const dirtyType = editor._dirtyType;
          const dirtyElements2 = editor._dirtyElements;
          const dirtyLeaves2 = editor._dirtyLeaves;
          observer.disconnect();
          mutatedNodes2 = reconcileRoot(currentEditorState, pendingEditorState, editor, dirtyType, dirtyElements2, dirtyLeaves2);
        } catch (error) {
          if (error instanceof Error) {
            editor._onError(error);
          }
          if (!isAttemptingToRecoverFromReconcilerError) {
            resetEditor(editor, null, rootElement, pendingEditorState);
            initMutationObserver(editor);
            editor._dirtyType = FULL_RECONCILE;
            isAttemptingToRecoverFromReconcilerError = true;
            commitPendingUpdates(editor, currentEditorState);
            isAttemptingToRecoverFromReconcilerError = false;
          } else {
            throw error;
          }
          return;
        } finally {
          observer.observe(rootElement, observerOptions);
          editor._updating = previouslyUpdating;
          activeEditorState = previousActiveEditorState;
          isReadOnlyMode = previousReadOnlyMode;
          activeEditor = previousActiveEditor;
        }
      }
      if (!pendingEditorState._readOnly) {
        pendingEditorState._readOnly = true;
        {
          handleDEVOnlyPendingUpdateGuarantees(pendingEditorState);
          if ($isRangeSelection2(pendingSelection)) {
            Object.freeze(pendingSelection.anchor);
            Object.freeze(pendingSelection.focus);
          }
          Object.freeze(pendingSelection);
        }
      }
      const dirtyLeaves = editor._dirtyLeaves;
      const dirtyElements = editor._dirtyElements;
      const normalizedNodes = editor._normalizedNodes;
      const tags = editor._updateTags;
      const deferred = editor._deferred;
      if (needsUpdate) {
        editor._dirtyType = NO_DIRTY_NODES;
        editor._cloneNotNeeded.clear();
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        editor._dirtyElements = /* @__PURE__ */ new Map();
        editor._normalizedNodes = /* @__PURE__ */ new Set();
        editor._updateTags = /* @__PURE__ */ new Set();
      }
      $garbageCollectDetachedDecorators(editor, pendingEditorState);
      const domSelection = shouldSkipDOM ? null : getDOMSelection(editor._window);
      if (editor._editable && // domSelection will be null in headless
      domSelection !== null && (needsUpdate || pendingSelection === null || pendingSelection.dirty)) {
        activeEditor = editor;
        activeEditorState = pendingEditorState;
        try {
          if (observer !== null) {
            observer.disconnect();
          }
          if (needsUpdate || pendingSelection === null || pendingSelection.dirty) {
            const blockCursorElement = editor._blockCursorElement;
            if (blockCursorElement !== null) {
              removeDOMBlockCursorElement(blockCursorElement, editor, rootElement);
            }
            updateDOMSelection(currentSelection, pendingSelection, editor, domSelection, tags, rootElement);
          }
          updateDOMBlockCursorElement(editor, rootElement, pendingSelection);
          if (observer !== null) {
            observer.observe(rootElement, observerOptions);
          }
        } finally {
          activeEditor = previousActiveEditor;
          activeEditorState = previousActiveEditorState;
        }
      }
      if (mutatedNodes2 !== null) {
        triggerMutationListeners(editor, mutatedNodes2, tags, dirtyLeaves, currentEditorState);
      }
      if (!$isRangeSelection2(pendingSelection) && pendingSelection !== null && (currentSelection === null || !currentSelection.is(pendingSelection))) {
        editor.dispatchCommand(SELECTION_CHANGE_COMMAND2, void 0);
      }
      const pendingDecorators = editor._pendingDecorators;
      if (pendingDecorators !== null) {
        editor._decorators = pendingDecorators;
        editor._pendingDecorators = null;
        triggerListeners("decorator", editor, true, pendingDecorators);
      }
      triggerTextContentListeners(editor, recoveryEditorState || currentEditorState, pendingEditorState);
      triggerListeners("update", editor, true, {
        dirtyElements,
        dirtyLeaves,
        editorState: pendingEditorState,
        normalizedNodes,
        prevEditorState: recoveryEditorState || currentEditorState,
        tags
      });
      triggerDeferredUpdateCallbacks(editor, deferred);
      triggerEnqueuedUpdates(editor);
    }
    function triggerTextContentListeners(editor, currentEditorState, pendingEditorState) {
      const currentTextContent = getEditorStateTextContent(currentEditorState);
      const latestTextContent = getEditorStateTextContent(pendingEditorState);
      if (currentTextContent !== latestTextContent) {
        triggerListeners("textcontent", editor, true, latestTextContent);
      }
    }
    function triggerMutationListeners(editor, mutatedNodes2, updateTags, dirtyLeaves, prevEditorState) {
      const listeners = Array.from(editor._listeners.mutation);
      const listenersLength = listeners.length;
      for (let i = 0; i < listenersLength; i++) {
        const [listener, klass] = listeners[i];
        const mutatedNodesByType = mutatedNodes2.get(klass);
        if (mutatedNodesByType !== void 0) {
          listener(mutatedNodesByType, {
            dirtyLeaves,
            prevEditorState,
            updateTags
          });
        }
      }
    }
    function triggerListeners(type, editor, isCurrentlyEnqueuingUpdates, ...payload) {
      const previouslyUpdating = editor._updating;
      editor._updating = isCurrentlyEnqueuingUpdates;
      try {
        const listeners = Array.from(editor._listeners[type]);
        for (let i = 0; i < listeners.length; i++) {
          listeners[i].apply(null, payload);
        }
      } finally {
        editor._updating = previouslyUpdating;
      }
    }
    function triggerCommandListeners(editor, type, payload) {
      if (editor._updating === false || activeEditor !== editor) {
        let returnVal = false;
        editor.update(() => {
          returnVal = triggerCommandListeners(editor, type, payload);
        });
        return returnVal;
      }
      const editors = getEditorsToPropagate(editor);
      for (let i = 4; i >= 0; i--) {
        for (let e = 0; e < editors.length; e++) {
          const currentEditor = editors[e];
          const commandListeners = currentEditor._commands;
          const listenerInPriorityOrder = commandListeners.get(type);
          if (listenerInPriorityOrder !== void 0) {
            const listenersSet = listenerInPriorityOrder[i];
            if (listenersSet !== void 0) {
              const listeners = Array.from(listenersSet);
              const listenersLength = listeners.length;
              for (let j = 0; j < listenersLength; j++) {
                if (listeners[j](payload, editor) === true) {
                  return true;
                }
              }
            }
          }
        }
      }
      return false;
    }
    function triggerEnqueuedUpdates(editor) {
      const queuedUpdates = editor._updates;
      if (queuedUpdates.length !== 0) {
        const queuedUpdate = queuedUpdates.shift();
        if (queuedUpdate) {
          const [updateFn, options] = queuedUpdate;
          beginUpdate(editor, updateFn, options);
        }
      }
    }
    function triggerDeferredUpdateCallbacks(editor, deferred) {
      editor._deferred = [];
      if (deferred.length !== 0) {
        const previouslyUpdating = editor._updating;
        editor._updating = true;
        try {
          for (let i = 0; i < deferred.length; i++) {
            deferred[i]();
          }
        } finally {
          editor._updating = previouslyUpdating;
        }
      }
    }
    function processNestedUpdates(editor, initialSkipTransforms) {
      const queuedUpdates = editor._updates;
      let skipTransforms = initialSkipTransforms || false;
      while (queuedUpdates.length !== 0) {
        const queuedUpdate = queuedUpdates.shift();
        if (queuedUpdate) {
          const [nextUpdateFn, options] = queuedUpdate;
          let onUpdate;
          let tag;
          if (options !== void 0) {
            onUpdate = options.onUpdate;
            tag = options.tag;
            if (options.skipTransforms) {
              skipTransforms = true;
            }
            if (onUpdate) {
              editor._deferred.push(onUpdate);
            }
            if (tag) {
              editor._updateTags.add(tag);
            }
          }
          nextUpdateFn();
        }
      }
      return skipTransforms;
    }
    function beginUpdate(editor, updateFn, options) {
      const updateTags = editor._updateTags;
      let onUpdate;
      let tag;
      let skipTransforms = false;
      let discrete = false;
      if (options !== void 0) {
        onUpdate = options.onUpdate;
        tag = options.tag;
        if (tag != null) {
          updateTags.add(tag);
        }
        skipTransforms = options.skipTransforms || false;
        discrete = options.discrete || false;
      }
      if (onUpdate) {
        editor._deferred.push(onUpdate);
      }
      const currentEditorState = editor._editorState;
      let pendingEditorState = editor._pendingEditorState;
      let editorStateWasCloned = false;
      if (pendingEditorState === null || pendingEditorState._readOnly) {
        pendingEditorState = editor._pendingEditorState = cloneEditorState(pendingEditorState || currentEditorState);
        editorStateWasCloned = true;
      }
      pendingEditorState._flushSync = discrete;
      const previousActiveEditorState = activeEditorState;
      const previousReadOnlyMode = isReadOnlyMode;
      const previousActiveEditor = activeEditor;
      const previouslyUpdating = editor._updating;
      activeEditorState = pendingEditorState;
      isReadOnlyMode = false;
      editor._updating = true;
      activeEditor = editor;
      try {
        if (editorStateWasCloned) {
          if (editor._headless) {
            if (currentEditorState._selection != null) {
              pendingEditorState._selection = currentEditorState._selection.clone();
            }
          } else {
            pendingEditorState._selection = internalCreateSelection(editor);
          }
        }
        const startingCompositionKey = editor._compositionKey;
        updateFn();
        skipTransforms = processNestedUpdates(editor, skipTransforms);
        applySelectionTransforms(pendingEditorState, editor);
        if (editor._dirtyType !== NO_DIRTY_NODES) {
          if (skipTransforms) {
            $normalizeAllDirtyTextNodes(pendingEditorState, editor);
          } else {
            $applyAllTransforms(pendingEditorState, editor);
          }
          processNestedUpdates(editor);
          $garbageCollectDetachedNodes(currentEditorState, pendingEditorState, editor._dirtyLeaves, editor._dirtyElements);
        }
        const endingCompositionKey = editor._compositionKey;
        if (startingCompositionKey !== endingCompositionKey) {
          pendingEditorState._flushSync = true;
        }
        const pendingSelection = pendingEditorState._selection;
        if ($isRangeSelection2(pendingSelection)) {
          const pendingNodeMap = pendingEditorState._nodeMap;
          const anchorKey = pendingSelection.anchor.key;
          const focusKey = pendingSelection.focus.key;
          if (pendingNodeMap.get(anchorKey) === void 0 || pendingNodeMap.get(focusKey) === void 0) {
            {
              throw Error(`updateEditor: selection has been lost because the previously selected nodes have been removed and selection wasn't moved to another node. Ensure selection changes after removing/replacing a selected node.`);
            }
          }
        } else if ($isNodeSelection(pendingSelection)) {
          if (pendingSelection._nodes.size === 0) {
            pendingEditorState._selection = null;
          }
        }
      } catch (error) {
        if (error instanceof Error) {
          editor._onError(error);
        }
        editor._pendingEditorState = currentEditorState;
        editor._dirtyType = FULL_RECONCILE;
        editor._cloneNotNeeded.clear();
        editor._dirtyLeaves = /* @__PURE__ */ new Set();
        editor._dirtyElements.clear();
        commitPendingUpdates(editor);
        return;
      } finally {
        activeEditorState = previousActiveEditorState;
        isReadOnlyMode = previousReadOnlyMode;
        activeEditor = previousActiveEditor;
        editor._updating = previouslyUpdating;
        infiniteTransformCount = 0;
      }
      const shouldUpdate = editor._dirtyType !== NO_DIRTY_NODES || editorStateHasDirtySelection(pendingEditorState, editor);
      if (shouldUpdate) {
        if (pendingEditorState._flushSync) {
          pendingEditorState._flushSync = false;
          commitPendingUpdates(editor);
        } else if (editorStateWasCloned) {
          scheduleMicroTask(() => {
            commitPendingUpdates(editor);
          });
        }
      } else {
        pendingEditorState._flushSync = false;
        if (editorStateWasCloned) {
          updateTags.clear();
          editor._deferred = [];
          editor._pendingEditorState = null;
        }
      }
    }
    function updateEditor(editor, updateFn, options) {
      if (editor._updating) {
        editor._updates.push([updateFn, options]);
      } else {
        beginUpdate(editor, updateFn, options);
      }
    }
    var DecoratorNode = class extends LexicalNode {
      constructor(key) {
        super(key);
      }
      decorate(editor, config) {
        {
          throw Error(`decorate: base method not extended`);
        }
      }
      isIsolated() {
        return false;
      }
      isInline() {
        return true;
      }
      isKeyboardSelectable() {
        return true;
      }
    };
    function $isDecoratorNode2(node) {
      return node instanceof DecoratorNode;
    }
    var ElementNode = class extends LexicalNode {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(key) {
        super(key);
        this.__first = null;
        this.__last = null;
        this.__size = 0;
        this.__format = 0;
        this.__indent = 0;
        this.__dir = null;
      }
      getFormat() {
        const self = this.getLatest();
        return self.__format;
      }
      getFormatType() {
        const format = this.getFormat();
        return ELEMENT_FORMAT_TO_TYPE[format] || "";
      }
      getIndent() {
        const self = this.getLatest();
        return self.__indent;
      }
      getChildren() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenKeys() {
        const children = [];
        let child = this.getFirstChild();
        while (child !== null) {
          children.push(child.__key);
          child = child.getNextSibling();
        }
        return children;
      }
      getChildrenSize() {
        const self = this.getLatest();
        return self.__size;
      }
      isEmpty() {
        return this.getChildrenSize() === 0;
      }
      isDirty() {
        const editor = getActiveEditor();
        const dirtyElements = editor._dirtyElements;
        return dirtyElements !== null && dirtyElements.has(this.__key);
      }
      isLastChild() {
        const self = this.getLatest();
        const parentLastChild = this.getParentOrThrow().getLastChild();
        return parentLastChild !== null && parentLastChild.is(self);
      }
      getAllTextNodes() {
        const textNodes = [];
        let child = this.getFirstChild();
        while (child !== null) {
          if ($isTextNode2(child)) {
            textNodes.push(child);
          }
          if ($isElementNode2(child)) {
            const subChildrenNodes = child.getAllTextNodes();
            textNodes.push(...subChildrenNodes);
          }
          child = child.getNextSibling();
        }
        return textNodes;
      }
      getFirstDescendant() {
        let node = this.getFirstChild();
        while (node !== null) {
          if ($isElementNode2(node)) {
            const child = node.getFirstChild();
            if (child !== null) {
              node = child;
              continue;
            }
          }
          break;
        }
        return node;
      }
      getLastDescendant() {
        let node = this.getLastChild();
        while (node !== null) {
          if ($isElementNode2(node)) {
            const child = node.getLastChild();
            if (child !== null) {
              node = child;
              continue;
            }
          }
          break;
        }
        return node;
      }
      getDescendantByIndex(index) {
        const children = this.getChildren();
        const childrenLength = children.length;
        if (index >= childrenLength) {
          const resolvedNode2 = children[childrenLength - 1];
          return $isElementNode2(resolvedNode2) && resolvedNode2.getLastDescendant() || resolvedNode2 || null;
        }
        const resolvedNode = children[index];
        return $isElementNode2(resolvedNode) && resolvedNode.getFirstDescendant() || resolvedNode || null;
      }
      getFirstChild() {
        const self = this.getLatest();
        const firstKey = self.__first;
        return firstKey === null ? null : $getNodeByKey(firstKey);
      }
      getFirstChildOrThrow() {
        const firstChild = this.getFirstChild();
        if (firstChild === null) {
          {
            throw Error(`Expected node ${this.__key} to have a first child.`);
          }
        }
        return firstChild;
      }
      getLastChild() {
        const self = this.getLatest();
        const lastKey = self.__last;
        return lastKey === null ? null : $getNodeByKey(lastKey);
      }
      getLastChildOrThrow() {
        const lastChild = this.getLastChild();
        if (lastChild === null) {
          {
            throw Error(`Expected node ${this.__key} to have a last child.`);
          }
        }
        return lastChild;
      }
      getChildAtIndex(index) {
        const size = this.getChildrenSize();
        let node;
        let i;
        if (index < size / 2) {
          node = this.getFirstChild();
          i = 0;
          while (node !== null && i <= index) {
            if (i === index) {
              return node;
            }
            node = node.getNextSibling();
            i++;
          }
          return null;
        }
        node = this.getLastChild();
        i = size - 1;
        while (node !== null && i >= index) {
          if (i === index) {
            return node;
          }
          node = node.getPreviousSibling();
          i--;
        }
        return null;
      }
      getTextContent() {
        let textContent = "";
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i = 0; i < childrenLength; i++) {
          const child = children[i];
          textContent += child.getTextContent();
          if ($isElementNode2(child) && i !== childrenLength - 1 && !child.isInline()) {
            textContent += DOUBLE_LINE_BREAK;
          }
        }
        return textContent;
      }
      getTextContentSize() {
        let textContentSize = 0;
        const children = this.getChildren();
        const childrenLength = children.length;
        for (let i = 0; i < childrenLength; i++) {
          const child = children[i];
          textContentSize += child.getTextContentSize();
          if ($isElementNode2(child) && i !== childrenLength - 1 && !child.isInline()) {
            textContentSize += DOUBLE_LINE_BREAK.length;
          }
        }
        return textContentSize;
      }
      getDirection() {
        const self = this.getLatest();
        return self.__dir;
      }
      hasFormat(type) {
        if (type !== "") {
          const formatFlag = ELEMENT_TYPE_TO_FORMAT[type];
          return (this.getFormat() & formatFlag) !== 0;
        }
        return false;
      }
      // Mutators
      select(_anchorOffset, _focusOffset) {
        errorOnReadOnly();
        const selection = $getSelection2();
        let anchorOffset = _anchorOffset;
        let focusOffset = _focusOffset;
        const childrenCount = this.getChildrenSize();
        if (!this.canBeEmpty()) {
          if (_anchorOffset === 0 && _focusOffset === 0) {
            const firstChild = this.getFirstChild();
            if ($isTextNode2(firstChild) || $isElementNode2(firstChild)) {
              return firstChild.select(0, 0);
            }
          } else if ((_anchorOffset === void 0 || _anchorOffset === childrenCount) && (_focusOffset === void 0 || _focusOffset === childrenCount)) {
            const lastChild = this.getLastChild();
            if ($isTextNode2(lastChild) || $isElementNode2(lastChild)) {
              return lastChild.select();
            }
          }
        }
        if (anchorOffset === void 0) {
          anchorOffset = childrenCount;
        }
        if (focusOffset === void 0) {
          focusOffset = childrenCount;
        }
        const key = this.__key;
        if (!$isRangeSelection2(selection)) {
          return internalMakeRangeSelection(key, anchorOffset, key, focusOffset, "element", "element");
        } else {
          selection.anchor.set(key, anchorOffset, "element");
          selection.focus.set(key, focusOffset, "element");
          selection.dirty = true;
        }
        return selection;
      }
      selectStart() {
        const firstNode = this.getFirstDescendant();
        if ($isElementNode2(firstNode) || $isTextNode2(firstNode)) {
          return firstNode.select(0, 0);
        }
        if (firstNode !== null) {
          return firstNode.selectPrevious();
        }
        return this.select(0, 0);
      }
      selectEnd() {
        const lastNode = this.getLastDescendant();
        if ($isElementNode2(lastNode) || $isTextNode2(lastNode)) {
          return lastNode.select();
        }
        if (lastNode !== null) {
          return lastNode.selectNext();
        }
        return this.select();
      }
      clear() {
        const writableSelf = this.getWritable();
        const children = this.getChildren();
        children.forEach((child) => child.remove());
        return writableSelf;
      }
      append(...nodesToAppend) {
        return this.splice(this.getChildrenSize(), 0, nodesToAppend);
      }
      setDirection(direction) {
        const self = this.getWritable();
        self.__dir = direction;
        return self;
      }
      setFormat(type) {
        const self = this.getWritable();
        self.__format = type !== "" ? ELEMENT_TYPE_TO_FORMAT[type] : 0;
        return this;
      }
      setIndent(indentLevel) {
        const self = this.getWritable();
        self.__indent = indentLevel;
        return this;
      }
      splice(start, deleteCount, nodesToInsert) {
        const nodesToInsertLength = nodesToInsert.length;
        const oldSize = this.getChildrenSize();
        const writableSelf = this.getWritable();
        const writableSelfKey = writableSelf.__key;
        const nodesToInsertKeys = [];
        const nodesToRemoveKeys = [];
        const nodeAfterRange = this.getChildAtIndex(start + deleteCount);
        let nodeBeforeRange = null;
        let newSize = oldSize - deleteCount + nodesToInsertLength;
        if (start !== 0) {
          if (start === oldSize) {
            nodeBeforeRange = this.getLastChild();
          } else {
            const node = this.getChildAtIndex(start);
            if (node !== null) {
              nodeBeforeRange = node.getPreviousSibling();
            }
          }
        }
        if (deleteCount > 0) {
          let nodeToDelete = nodeBeforeRange === null ? this.getFirstChild() : nodeBeforeRange.getNextSibling();
          for (let i = 0; i < deleteCount; i++) {
            if (nodeToDelete === null) {
              {
                throw Error(`splice: sibling not found`);
              }
            }
            const nextSibling = nodeToDelete.getNextSibling();
            const nodeKeyToDelete = nodeToDelete.__key;
            const writableNodeToDelete = nodeToDelete.getWritable();
            removeFromParent(writableNodeToDelete);
            nodesToRemoveKeys.push(nodeKeyToDelete);
            nodeToDelete = nextSibling;
          }
        }
        let prevNode = nodeBeforeRange;
        for (let i = 0; i < nodesToInsertLength; i++) {
          const nodeToInsert = nodesToInsert[i];
          if (prevNode !== null && nodeToInsert.is(prevNode)) {
            nodeBeforeRange = prevNode = prevNode.getPreviousSibling();
          }
          const writableNodeToInsert = nodeToInsert.getWritable();
          if (writableNodeToInsert.__parent === writableSelfKey) {
            newSize--;
          }
          removeFromParent(writableNodeToInsert);
          const nodeKeyToInsert = nodeToInsert.__key;
          if (prevNode === null) {
            writableSelf.__first = nodeKeyToInsert;
            writableNodeToInsert.__prev = null;
          } else {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = nodeKeyToInsert;
            writableNodeToInsert.__prev = writablePrevNode.__key;
          }
          if (nodeToInsert.__key === writableSelfKey) {
            {
              throw Error(`append: attempting to append self`);
            }
          }
          writableNodeToInsert.__parent = writableSelfKey;
          nodesToInsertKeys.push(nodeKeyToInsert);
          prevNode = nodeToInsert;
        }
        if (start + deleteCount === oldSize) {
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writablePrevNode.__next = null;
            writableSelf.__last = prevNode.__key;
          }
        } else if (nodeAfterRange !== null) {
          const writableNodeAfterRange = nodeAfterRange.getWritable();
          if (prevNode !== null) {
            const writablePrevNode = prevNode.getWritable();
            writableNodeAfterRange.__prev = prevNode.__key;
            writablePrevNode.__next = nodeAfterRange.__key;
          } else {
            writableNodeAfterRange.__prev = null;
          }
        }
        writableSelf.__size = newSize;
        if (nodesToRemoveKeys.length) {
          const selection = $getSelection2();
          if ($isRangeSelection2(selection)) {
            const nodesToRemoveKeySet = new Set(nodesToRemoveKeys);
            const nodesToInsertKeySet = new Set(nodesToInsertKeys);
            const {
              anchor,
              focus
            } = selection;
            if (isPointRemoved(anchor, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(anchor, anchor.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (isPointRemoved(focus, nodesToRemoveKeySet, nodesToInsertKeySet)) {
              moveSelectionPointToSibling(focus, focus.getNode(), this, nodeBeforeRange, nodeAfterRange);
            }
            if (newSize === 0 && !this.canBeEmpty() && !$isRootOrShadowRoot2(this)) {
              this.remove();
            }
          }
        }
        return writableSelf;
      }
      // JSON serialization
      exportJSON() {
        return {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          type: "element",
          version: 1
        };
      }
      // These are intended to be extends for specific element heuristics.
      insertNewAfter(selection, restoreSelection) {
        return null;
      }
      canIndent() {
        return true;
      }
      /*
       * This method controls the behavior of a the node during backwards
       * deletion (i.e., backspace) when selection is at the beginning of
       * the node (offset 0)
       */
      collapseAtStart(selection) {
        return false;
      }
      excludeFromCopy(destination) {
        return false;
      }
      // TODO 0.10 deprecate
      canExtractContents() {
        return true;
      }
      canReplaceWith(replacement) {
        return true;
      }
      canInsertAfter(node) {
        return true;
      }
      canBeEmpty() {
        return true;
      }
      canInsertTextBefore() {
        return true;
      }
      canInsertTextAfter() {
        return true;
      }
      isInline() {
        return false;
      }
      // A shadow root is a Node that behaves like RootNode. The shadow root (and RootNode) mark the
      // end of the hiercharchy, most implementations should treat it as there's nothing (upwards)
      // beyond this point. For example, node.getTopLevelElement(), when performed inside a TableCellNode
      // will return the immediate first child underneath TableCellNode instead of RootNode.
      isShadowRoot() {
        return false;
      }
      canMergeWith(node) {
        return false;
      }
      extractWithChild(child, selection, destination) {
        return false;
      }
    };
    function $isElementNode2(node) {
      return node instanceof ElementNode;
    }
    function isPointRemoved(point, nodesToRemoveKeySet, nodesToInsertKeySet) {
      let node = point.getNode();
      while (node) {
        const nodeKey = node.__key;
        if (nodesToRemoveKeySet.has(nodeKey) && !nodesToInsertKeySet.has(nodeKey)) {
          return true;
        }
        node = node.getParent();
      }
      return false;
    }
    var RootNode = class _RootNode extends ElementNode {
      /** @internal */
      static getType() {
        return "root";
      }
      static clone() {
        return new _RootNode();
      }
      constructor() {
        super("root");
        this.__cachedText = null;
      }
      getTopLevelElementOrThrow() {
        {
          throw Error(`getTopLevelElementOrThrow: root nodes are not top level elements`);
        }
      }
      getTextContent() {
        const cachedText = this.__cachedText;
        if (isCurrentlyReadOnlyMode() || getActiveEditor()._dirtyType === NO_DIRTY_NODES) {
          if (cachedText !== null) {
            return cachedText;
          }
        }
        return super.getTextContent();
      }
      remove() {
        {
          throw Error(`remove: cannot be called on root nodes`);
        }
      }
      replace(node) {
        {
          throw Error(`replace: cannot be called on root nodes`);
        }
      }
      insertBefore(nodeToInsert) {
        {
          throw Error(`insertBefore: cannot be called on root nodes`);
        }
      }
      insertAfter(nodeToInsert) {
        {
          throw Error(`insertAfter: cannot be called on root nodes`);
        }
      }
      // View
      updateDOM(prevNode, dom) {
        return false;
      }
      // Mutate
      append(...nodesToAppend) {
        for (let i = 0; i < nodesToAppend.length; i++) {
          const node = nodesToAppend[i];
          if (!$isElementNode2(node) && !$isDecoratorNode2(node)) {
            {
              throw Error(`rootNode.append: Only element or decorator nodes can be appended to the root node`);
            }
          }
        }
        return super.append(...nodesToAppend);
      }
      static importJSON(serializedNode) {
        const node = $getRoot2();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          children: [],
          direction: this.getDirection(),
          format: this.getFormatType(),
          indent: this.getIndent(),
          type: "root",
          version: 1
        };
      }
      collapseAtStart() {
        return true;
      }
    };
    function $createRootNode() {
      return new RootNode();
    }
    function $isRootNode2(node) {
      return node instanceof RootNode;
    }
    function editorStateHasDirtySelection(editorState, editor) {
      const currentSelection = editor.getEditorState()._selection;
      const pendingSelection = editorState._selection;
      if (pendingSelection !== null) {
        if (pendingSelection.dirty || !pendingSelection.is(currentSelection)) {
          return true;
        }
      } else if (currentSelection !== null) {
        return true;
      }
      return false;
    }
    function cloneEditorState(current) {
      return new EditorState(new Map(current._nodeMap));
    }
    function createEmptyEditorState() {
      return new EditorState(/* @__PURE__ */ new Map([["root", $createRootNode()]]));
    }
    function exportNodeToJSON(node) {
      const serializedNode = node.exportJSON();
      const nodeClass = node.constructor;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not match the serialized type. Check if .exportJSON() is implemented and it is returning the correct type.`);
        }
      }
      const serializedChildren = serializedNode.children;
      if ($isElementNode2(node)) {
        if (!Array.isArray(serializedChildren)) {
          {
            throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
          }
        }
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          const serializedChildNode = exportNodeToJSON(child);
          serializedChildren.push(serializedChildNode);
        }
      }
      return serializedNode;
    }
    var EditorState = class _EditorState {
      constructor(nodeMap, selection) {
        this._nodeMap = nodeMap;
        this._selection = selection || null;
        this._flushSync = false;
        this._readOnly = false;
      }
      isEmpty() {
        return this._nodeMap.size === 1 && this._selection === null;
      }
      read(callbackFn) {
        return readEditorState(this, callbackFn);
      }
      clone(selection) {
        const editorState = new _EditorState(this._nodeMap, selection === void 0 ? this._selection : selection);
        editorState._readOnly = true;
        return editorState;
      }
      toJSON() {
        return readEditorState(this, () => ({
          root: exportNodeToJSON($getRoot2())
        }));
      }
    };
    var ParagraphNode2 = class _ParagraphNode extends ElementNode {
      static getType() {
        return "paragraph";
      }
      static clone(node) {
        return new _ParagraphNode(node.__key);
      }
      // View
      createDOM(config) {
        const dom = document.createElement("p");
        const classNames = getCachedClassNameArray(config.theme, "paragraph");
        if (classNames !== void 0) {
          const domClassList = dom.classList;
          domClassList.add(...classNames);
        }
        return dom;
      }
      updateDOM(prevNode, dom, config) {
        return false;
      }
      static importDOM() {
        return {
          p: (node) => ({
            conversion: convertParagraphElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && isHTMLElement(element)) {
          if (this.isEmpty())
            element.append(document.createElement("br"));
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
          const indent = this.getIndent();
          if (indent > 0) {
            element.style.textIndent = `${indent * 20}px`;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createParagraphNode3();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "paragraph",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(_, restoreSelection) {
        const newElement = $createParagraphNode3();
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart() {
        const children = this.getChildren();
        if (children.length === 0 || $isTextNode2(children[0]) && children[0].getTextContent().trim() === "") {
          const nextSibling = this.getNextSibling();
          if (nextSibling !== null) {
            this.selectNext();
            this.remove();
            return true;
          }
          const prevSibling = this.getPreviousSibling();
          if (prevSibling !== null) {
            this.selectPrevious();
            this.remove();
            return true;
          }
        }
        return false;
      }
    };
    function convertParagraphElement(element) {
      const node = $createParagraphNode3();
      if (element.style) {
        node.setFormat(element.style.textAlign);
        const indent = parseInt(element.style.textIndent, 10) / 20;
        if (indent > 0) {
          node.setIndent(indent);
        }
      }
      return {
        node
      };
    }
    function $createParagraphNode3() {
      return $applyNodeReplacement(new ParagraphNode2());
    }
    function $isParagraphNode2(node) {
      return node instanceof ParagraphNode2;
    }
    var COMMAND_PRIORITY_EDITOR = 0;
    var COMMAND_PRIORITY_LOW = 1;
    var COMMAND_PRIORITY_NORMAL = 2;
    var COMMAND_PRIORITY_HIGH = 3;
    var COMMAND_PRIORITY_CRITICAL2 = 4;
    function resetEditor(editor, prevRootElement, nextRootElement, pendingEditorState) {
      const keyNodeMap = editor._keyToDOMMap;
      keyNodeMap.clear();
      editor._editorState = createEmptyEditorState();
      editor._pendingEditorState = pendingEditorState;
      editor._compositionKey = null;
      editor._dirtyType = NO_DIRTY_NODES;
      editor._cloneNotNeeded.clear();
      editor._dirtyLeaves = /* @__PURE__ */ new Set();
      editor._dirtyElements.clear();
      editor._normalizedNodes = /* @__PURE__ */ new Set();
      editor._updateTags = /* @__PURE__ */ new Set();
      editor._updates = [];
      editor._blockCursorElement = null;
      const observer = editor._observer;
      if (observer !== null) {
        observer.disconnect();
        editor._observer = null;
      }
      if (prevRootElement !== null) {
        prevRootElement.textContent = "";
      }
      if (nextRootElement !== null) {
        nextRootElement.textContent = "";
        keyNodeMap.set("root", nextRootElement);
      }
    }
    function initializeConversionCache(nodes) {
      const conversionCache = /* @__PURE__ */ new Map();
      const handledConversions = /* @__PURE__ */ new Set();
      nodes.forEach((node) => {
        const importDOM = node.klass.importDOM != null ? node.klass.importDOM.bind(node.klass) : null;
        if (importDOM == null || handledConversions.has(importDOM)) {
          return;
        }
        handledConversions.add(importDOM);
        const map3 = importDOM();
        if (map3 !== null) {
          Object.keys(map3).forEach((key) => {
            let currentCache = conversionCache.get(key);
            if (currentCache === void 0) {
              currentCache = [];
              conversionCache.set(key, currentCache);
            }
            currentCache.push(map3[key]);
          });
        }
      });
      return conversionCache;
    }
    function createEditor(editorConfig) {
      const config = editorConfig || {};
      const activeEditor2 = internalGetActiveEditor();
      const theme = config.theme || {};
      const parentEditor = editorConfig === void 0 ? activeEditor2 : config.parentEditor || null;
      const disableEvents = config.disableEvents || false;
      const editorState = createEmptyEditorState();
      const namespace = config.namespace || (parentEditor !== null ? parentEditor._config.namespace : createUID());
      const initialEditorState = config.editorState;
      const nodes = [RootNode, TextNode2, LineBreakNode, TabNode, ParagraphNode2, ...config.nodes || []];
      const onError = config.onError;
      const isEditable = config.editable !== void 0 ? config.editable : true;
      let registeredNodes;
      if (editorConfig === void 0 && activeEditor2 !== null) {
        registeredNodes = activeEditor2._nodes;
      } else {
        registeredNodes = /* @__PURE__ */ new Map();
        for (let i = 0; i < nodes.length; i++) {
          let klass = nodes[i];
          let replacementClass = null;
          let replacementKlass = null;
          if (typeof klass !== "function") {
            const options = klass;
            klass = options.replace;
            replacementClass = options.with;
            replacementKlass = options.withKlass ? options.withKlass : null;
          }
          {
            const name = klass.name;
            if (name !== "RootNode") {
              const proto = klass.prototype;
              ["getType", "clone"].forEach((method) => {
                if (!klass.hasOwnProperty(method)) {
                  console.warn(`${name} must implement static "${method}" method`);
                }
              });
              if (
                // eslint-disable-next-line no-prototype-builtins
                !klass.hasOwnProperty("importDOM") && // eslint-disable-next-line no-prototype-builtins
                klass.hasOwnProperty("exportDOM")
              ) {
                console.warn(`${name} should implement "importDOM" if using a custom "exportDOM" method to ensure HTML serialization (important for copy & paste) works as expected`);
              }
              if (proto instanceof DecoratorNode) {
                if (!proto.hasOwnProperty("decorate")) {
                  console.warn(`${proto.constructor.name} must implement "decorate" method`);
                }
              }
              if (
                // eslint-disable-next-line no-prototype-builtins
                !klass.hasOwnProperty("importJSON")
              ) {
                console.warn(`${name} should implement "importJSON" method to ensure JSON and default HTML serialization works as expected`);
              }
              if (
                // eslint-disable-next-line no-prototype-builtins
                !proto.hasOwnProperty("exportJSON")
              ) {
                console.warn(`${name} should implement "exportJSON" method to ensure JSON and default HTML serialization works as expected`);
              }
            }
          }
          const type = klass.getType();
          const transform = klass.transform();
          const transforms = /* @__PURE__ */ new Set();
          if (transform !== null) {
            transforms.add(transform);
          }
          registeredNodes.set(type, {
            klass,
            replace: replacementClass,
            replaceWithKlass: replacementKlass,
            transforms
          });
        }
      }
      const editor = new LexicalEditor(editorState, parentEditor, registeredNodes, {
        disableEvents,
        namespace,
        theme
      }, onError ? onError : console.error, initializeConversionCache(registeredNodes), isEditable);
      if (initialEditorState !== void 0) {
        editor._pendingEditorState = initialEditorState;
        editor._dirtyType = FULL_RECONCILE;
      }
      return editor;
    }
    var LexicalEditor = class {
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      /** @internal */
      constructor(editorState, parentEditor, nodes, config, onError, htmlConversions, editable) {
        this._parentEditor = parentEditor;
        this._rootElement = null;
        this._editorState = editorState;
        this._pendingEditorState = null;
        this._compositionKey = null;
        this._deferred = [];
        this._keyToDOMMap = /* @__PURE__ */ new Map();
        this._updates = [];
        this._updating = false;
        this._listeners = {
          decorator: /* @__PURE__ */ new Set(),
          editable: /* @__PURE__ */ new Set(),
          mutation: /* @__PURE__ */ new Map(),
          root: /* @__PURE__ */ new Set(),
          textcontent: /* @__PURE__ */ new Set(),
          update: /* @__PURE__ */ new Set()
        };
        this._commands = /* @__PURE__ */ new Map();
        this._config = config;
        this._nodes = nodes;
        this._decorators = {};
        this._pendingDecorators = null;
        this._dirtyType = NO_DIRTY_NODES;
        this._cloneNotNeeded = /* @__PURE__ */ new Set();
        this._dirtyLeaves = /* @__PURE__ */ new Set();
        this._dirtyElements = /* @__PURE__ */ new Map();
        this._normalizedNodes = /* @__PURE__ */ new Set();
        this._updateTags = /* @__PURE__ */ new Set();
        this._observer = null;
        this._key = createUID();
        this._onError = onError;
        this._htmlConversions = htmlConversions;
        this._editable = editable;
        this._headless = parentEditor !== null && parentEditor._headless;
        this._window = null;
        this._blockCursorElement = null;
      }
      /**
       *
       * @returns true if the editor is currently in "composition" mode due to receiving input
       * through an IME, or 3P extension, for example. Returns false otherwise.
       */
      isComposing() {
        return this._compositionKey != null;
      }
      /**
       * Registers a listener for Editor update event. Will trigger the provided callback
       * each time the editor goes through an update (via {@link LexicalEditor.update}) until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerUpdateListener(listener) {
        const listenerSetOrMap = this._listeners.update;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for for when the editor changes between editable and non-editable states.
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerEditableListener(listener) {
        const listenerSetOrMap = this._listeners.editable;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when the editor's decorator object changes. The decorator object contains
       * all DecoratorNode keys -> their decorated value. This is primarily used with external UI frameworks.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerDecoratorListener(listener) {
        const listenerSetOrMap = this._listeners.decorator;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when Lexical commits an update to the DOM and the text content of
       * the editor changes from the previous state of the editor. If the text content is the
       * same between updates, no notifications to the listeners will happen.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerTextContentListener(listener) {
        const listenerSetOrMap = this._listeners.textcontent;
        listenerSetOrMap.add(listener);
        return () => {
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener for when the editor's root DOM element (the content editable
       * Lexical attaches to) changes. This is primarily used to attach event listeners to the root
       *  element. The root listener function is executed directly upon registration and then on
       * any subsequent update.
       *
       * Will trigger the provided callback each time the editor transitions between these states until the
       * teardown function is called.
       *
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerRootListener(listener) {
        const listenerSetOrMap = this._listeners.root;
        listener(this._rootElement, null);
        listenerSetOrMap.add(listener);
        return () => {
          listener(null, this._rootElement);
          listenerSetOrMap.delete(listener);
        };
      }
      /**
       * Registers a listener that will trigger anytime the provided command
       * is dispatched, subject to priority. Listeners that run at a higher priority can "intercept"
       * commands and prevent them from propagating to other handlers by returning true.
       *
       * Listeners registered at the same priority level will run deterministically in the order of registration.
       *
       * @param command - the command that will trigger the callback.
       * @param listener - the function that will execute when the command is dispatched.
       * @param priority - the relative priority of the listener. 0 | 1 | 2 | 3 | 4
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerCommand(command, listener, priority) {
        if (priority === void 0) {
          {
            throw Error(`Listener for type "command" requires a "priority".`);
          }
        }
        const commandsMap = this._commands;
        if (!commandsMap.has(command)) {
          commandsMap.set(command, [/* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set(), /* @__PURE__ */ new Set()]);
        }
        const listenersInPriorityOrder = commandsMap.get(command);
        if (listenersInPriorityOrder === void 0) {
          {
            throw Error(`registerCommand: Command ${String(command)} not found in command map`);
          }
        }
        const listeners = listenersInPriorityOrder[priority];
        listeners.add(listener);
        return () => {
          listeners.delete(listener);
          if (listenersInPriorityOrder.every((listenersSet) => listenersSet.size === 0)) {
            commandsMap.delete(command);
          }
        };
      }
      /**
       * Registers a listener that will run when a Lexical node of the provided class is
       * mutated. The listener will receive a list of nodes along with the type of mutation
       * that was performed on each: created, destroyed, or updated.
       *
       * One common use case for this is to attach DOM event listeners to the underlying DOM nodes as Lexical nodes are created.
       * {@link LexicalEditor.getElementByKey} can be used for this.
       *
       * @param klass - The class of the node that you want to listen to mutations on.
       * @param listener - The logic you want to run when the node is mutated.
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerMutationListener(klass, listener) {
        const registeredNode = this._nodes.get(klass.getType());
        if (registeredNode === void 0) {
          {
            throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        const mutations = this._listeners.mutation;
        mutations.set(listener, klass);
        return () => {
          mutations.delete(listener);
        };
      }
      /** @internal */
      registerNodeTransformToKlass(klass, listener) {
        const type = klass.getType();
        const registeredNode = this._nodes.get(type);
        if (registeredNode === void 0) {
          {
            throw Error(`Node ${klass.name} has not been registered. Ensure node has been passed to createEditor.`);
          }
        }
        const transforms = registeredNode.transforms;
        transforms.add(listener);
        return registeredNode;
      }
      /**
       * Registers a listener that will run when a Lexical node of the provided class is
       * marked dirty during an update. The listener will continue to run as long as the node
       * is marked dirty. There are no guarantees around the order of transform execution!
       *
       * Watch out for infinite loops. See [Node Transforms](https://lexical.dev/docs/concepts/transforms)
       * @param klass - The class of the node that you want to run transforms on.
       * @param listener - The logic you want to run when the node is updated.
       * @returns a teardown function that can be used to cleanup the listener.
       */
      registerNodeTransform(klass, listener) {
        const registeredNode = this.registerNodeTransformToKlass(klass, listener);
        const registeredNodes = [registeredNode];
        const replaceWithKlass = registeredNode.replaceWithKlass;
        if (replaceWithKlass != null) {
          const registeredReplaceWithNode = this.registerNodeTransformToKlass(replaceWithKlass, listener);
          registeredNodes.push(registeredReplaceWithNode);
        }
        markAllNodesAsDirty(this, klass.getType());
        return () => {
          registeredNodes.forEach((node) => node.transforms.delete(listener));
        };
      }
      /**
       * Used to assert that a certain node is registered, usually by plugins to ensure nodes that they
       * depend on have been registered.
       * @returns True if the editor has registered the provided node type, false otherwise.
       */
      hasNode(node) {
        return this._nodes.has(node.getType());
      }
      /**
       * Used to assert that certain nodes are registered, usually by plugins to ensure nodes that they
       * depend on have been registered.
       * @returns True if the editor has registered all of the provided node types, false otherwise.
       */
      hasNodes(nodes) {
        return nodes.every(this.hasNode.bind(this));
      }
      /**
       * Dispatches a command of the specified type with the specified payload.
       * This triggers all command listeners (set by {@link LexicalEditor.registerCommand})
       * for this type, passing them the provided payload.
       * @param type - the type of command listeners to trigger.
       * @param payload - the data to pass as an argument to the command listeners.
       */
      dispatchCommand(type, payload) {
        return dispatchCommand(this, type, payload);
      }
      /**
       * Gets a map of all decorators in the editor.
       * @returns A mapping of call decorator keys to their decorated content
       */
      getDecorators() {
        return this._decorators;
      }
      /**
       *
       * @returns the current root element of the editor. If you want to register
       * an event listener, do it via {@link LexicalEditor.registerRootListener}, since
       * this reference may not be stable.
       */
      getRootElement() {
        return this._rootElement;
      }
      /**
       * Gets the key of the editor
       * @returns The editor key
       */
      getKey() {
        return this._key;
      }
      /**
       * Imperatively set the root contenteditable element that Lexical listens
       * for events on.
       */
      setRootElement(nextRootElement) {
        const prevRootElement = this._rootElement;
        if (nextRootElement !== prevRootElement) {
          const classNames = getCachedClassNameArray(this._config.theme, "root");
          const pendingEditorState = this._pendingEditorState || this._editorState;
          this._rootElement = nextRootElement;
          resetEditor(this, prevRootElement, nextRootElement, pendingEditorState);
          if (prevRootElement !== null) {
            if (!this._config.disableEvents) {
              removeRootElementEvents(prevRootElement);
            }
            if (classNames != null) {
              prevRootElement.classList.remove(...classNames);
            }
          }
          if (nextRootElement !== null) {
            const windowObj = getDefaultView(nextRootElement);
            const style = nextRootElement.style;
            style.userSelect = "text";
            style.whiteSpace = "pre-wrap";
            style.wordBreak = "break-word";
            nextRootElement.setAttribute("data-lexical-editor", "true");
            this._window = windowObj;
            this._dirtyType = FULL_RECONCILE;
            initMutationObserver(this);
            this._updateTags.add("history-merge");
            commitPendingUpdates(this);
            if (!this._config.disableEvents) {
              addRootElementEvents(nextRootElement, this);
            }
            if (classNames != null) {
              nextRootElement.classList.add(...classNames);
            }
          } else {
            this._editorState = pendingEditorState;
            this._pendingEditorState = null;
            this._window = null;
          }
          triggerListeners("root", this, false, nextRootElement, prevRootElement);
        }
      }
      /**
       * Gets the underlying HTMLElement associated with the LexicalNode for the given key.
       * @returns the HTMLElement rendered by the LexicalNode associated with the key.
       * @param key - the key of the LexicalNode.
       */
      getElementByKey(key) {
        return this._keyToDOMMap.get(key) || null;
      }
      /**
       * Gets the active editor state.
       * @returns The editor state
       */
      getEditorState() {
        return this._editorState;
      }
      /**
       * Imperatively set the EditorState. Triggers reconciliation like an update.
       * @param editorState - the state to set the editor
       * @param options - options for the update.
       */
      setEditorState(editorState, options) {
        if (editorState.isEmpty()) {
          {
            throw Error(`setEditorState: the editor state is empty. Ensure the editor state's root node never becomes empty.`);
          }
        }
        flushRootMutations(this);
        const pendingEditorState = this._pendingEditorState;
        const tags = this._updateTags;
        const tag = options !== void 0 ? options.tag : null;
        if (pendingEditorState !== null && !pendingEditorState.isEmpty()) {
          if (tag != null) {
            tags.add(tag);
          }
          commitPendingUpdates(this);
        }
        this._pendingEditorState = editorState;
        this._dirtyType = FULL_RECONCILE;
        this._dirtyElements.set("root", false);
        this._compositionKey = null;
        if (tag != null) {
          tags.add(tag);
        }
        commitPendingUpdates(this);
      }
      /**
       * Parses a SerializedEditorState (usually produced by {@link EditorState.toJSON}) and returns
       * and EditorState object that can be, for example, passed to {@link LexicalEditor.setEditorState}. Typically,
       * deserliazation from JSON stored in a database uses this method.
       * @param maybeStringifiedEditorState
       * @param updateFn
       * @returns
       */
      parseEditorState(maybeStringifiedEditorState, updateFn) {
        const serializedEditorState = typeof maybeStringifiedEditorState === "string" ? JSON.parse(maybeStringifiedEditorState) : maybeStringifiedEditorState;
        return parseEditorState(serializedEditorState, this, updateFn);
      }
      /**
       * Executes an update to the editor state. The updateFn callback is the ONLY place
       * where Lexical editor state can be safely mutated.
       * @param updateFn - A function that has access to writable editor state.
       * @param options - A bag of options to control the behavior of the update.
       * @param options.onUpdate - A function to run once the update is complete.
       * Useful for synchronizing updates in some cases.
       * @param options.skipTransforms - Setting this to true will suppress all node
       * transforms for this update cycle.
       * @param options.tag - A tag to identify this update, in an update listener, for instance.
       * Some tags are reserved by the core and control update behavior in different ways.
       * @param options.discrete - If true, prevents this update from being batched, forcing it to
       * run synchronously.
       */
      update(updateFn, options) {
        updateEditor(this, updateFn, options);
      }
      /**
       * Focuses the editor
       * @param callbackFn - A function to run after the editor is focused.
       * @param options - A bag of options
       * @param options.defaultSelection - Where to move selection when the editor is
       * focused. Can be rootStart, rootEnd, or undefined. Defaults to rootEnd.
       */
      focus(callbackFn, options = {}) {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.setAttribute("autocapitalize", "off");
          updateEditor(this, () => {
            const selection = $getSelection2();
            const root2 = $getRoot2();
            if (selection !== null) {
              selection.dirty = true;
            } else if (root2.getChildrenSize() !== 0) {
              if (options.defaultSelection === "rootStart") {
                root2.selectStart();
              } else {
                root2.selectEnd();
              }
            }
          }, {
            onUpdate: () => {
              rootElement.removeAttribute("autocapitalize");
              if (callbackFn) {
                callbackFn();
              }
            },
            tag: "focus"
          });
          if (this._pendingEditorState === null) {
            rootElement.removeAttribute("autocapitalize");
          }
        }
      }
      /**
       * Removes focus from the editor.
       */
      blur() {
        const rootElement = this._rootElement;
        if (rootElement !== null) {
          rootElement.blur();
        }
        const domSelection = getDOMSelection(this._window);
        if (domSelection !== null) {
          domSelection.removeAllRanges();
        }
      }
      /**
       * Returns true if the editor is editable, false otherwise.
       * @returns True if the editor is editable, false otherwise.
       */
      isEditable() {
        return this._editable;
      }
      /**
       * Sets the editable property of the editor. When false, the
       * editor will not listen for user events on the underling contenteditable.
       * @param editable - the value to set the editable mode to.
       */
      setEditable(editable) {
        if (this._editable !== editable) {
          this._editable = editable;
          triggerListeners("editable", this, true, editable);
        }
      }
      /**
       * Returns a JSON-serializable javascript object NOT a JSON string.
       * You still must call JSON.stringify (or something else) to turn the
       * state into a string you can transfer over the wire and store in a database.
       *
       * See {@link LexicalNode.exportJSON}
       *
       * @returns A JSON-serializable javascript object
       */
      toJSON() {
        return {
          editorState: this._editorState.toJSON()
        };
      }
    };
    var DEPRECATED_GridCellNode = class extends ElementNode {
      /** @internal */
      constructor(colSpan, key) {
        super(key);
        this.__colSpan = colSpan;
        this.__rowSpan = 1;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          colSpan: this.__colSpan,
          rowSpan: this.__rowSpan
        };
      }
      getColSpan() {
        return this.__colSpan;
      }
      setColSpan(colSpan) {
        this.getWritable().__colSpan = colSpan;
        return this;
      }
      getRowSpan() {
        return this.__rowSpan;
      }
      setRowSpan(rowSpan) {
        this.getWritable().__rowSpan = rowSpan;
        return this;
      }
    };
    function DEPRECATED_$isGridCellNode(node) {
      return node instanceof DEPRECATED_GridCellNode;
    }
    var DEPRECATED_GridNode = class extends ElementNode {
    };
    function DEPRECATED_$isGridNode(node) {
      return node instanceof DEPRECATED_GridNode;
    }
    var DEPRECATED_GridRowNode = class extends ElementNode {
    };
    function DEPRECATED_$isGridRowNode(node) {
      return node instanceof DEPRECATED_GridRowNode;
    }
    exports.$addUpdateTag = $addUpdateTag;
    exports.$applyNodeReplacement = $applyNodeReplacement;
    exports.$copyNode = $copyNode;
    exports.$createLineBreakNode = $createLineBreakNode2;
    exports.$createNodeSelection = $createNodeSelection;
    exports.$createParagraphNode = $createParagraphNode3;
    exports.$createRangeSelection = $createRangeSelection;
    exports.$createTabNode = $createTabNode;
    exports.$createTextNode = $createTextNode3;
    exports.$getAdjacentNode = $getAdjacentNode;
    exports.$getNearestNodeFromDOMNode = $getNearestNodeFromDOMNode;
    exports.$getNearestRootOrShadowRoot = $getNearestRootOrShadowRoot;
    exports.$getNodeByKey = $getNodeByKey;
    exports.$getPreviousSelection = $getPreviousSelection;
    exports.$getRoot = $getRoot2;
    exports.$getSelection = $getSelection2;
    exports.$getTextContent = $getTextContent;
    exports.$hasAncestor = $hasAncestor;
    exports.$hasUpdateTag = $hasUpdateTag;
    exports.$insertNodes = $insertNodes2;
    exports.$isBlockElementNode = $isBlockElementNode;
    exports.$isDecoratorNode = $isDecoratorNode2;
    exports.$isElementNode = $isElementNode2;
    exports.$isInlineElementOrDecoratorNode = $isInlineElementOrDecoratorNode;
    exports.$isLeafNode = $isLeafNode;
    exports.$isLineBreakNode = $isLineBreakNode2;
    exports.$isNodeSelection = $isNodeSelection;
    exports.$isParagraphNode = $isParagraphNode2;
    exports.$isRangeSelection = $isRangeSelection2;
    exports.$isRootNode = $isRootNode2;
    exports.$isRootOrShadowRoot = $isRootOrShadowRoot2;
    exports.$isTabNode = $isTabNode;
    exports.$isTextNode = $isTextNode2;
    exports.$nodesOfType = $nodesOfType;
    exports.$normalizeSelection__EXPERIMENTAL = $normalizeSelection;
    exports.$parseSerializedNode = $parseSerializedNode;
    exports.$selectAll = $selectAll;
    exports.$setCompositionKey = $setCompositionKey;
    exports.$setSelection = $setSelection2;
    exports.$splitNode = $splitNode;
    exports.BLUR_COMMAND = BLUR_COMMAND2;
    exports.CAN_REDO_COMMAND = CAN_REDO_COMMAND;
    exports.CAN_UNDO_COMMAND = CAN_UNDO_COMMAND;
    exports.CLEAR_EDITOR_COMMAND = CLEAR_EDITOR_COMMAND;
    exports.CLEAR_HISTORY_COMMAND = CLEAR_HISTORY_COMMAND;
    exports.CLICK_COMMAND = CLICK_COMMAND;
    exports.COMMAND_PRIORITY_CRITICAL = COMMAND_PRIORITY_CRITICAL2;
    exports.COMMAND_PRIORITY_EDITOR = COMMAND_PRIORITY_EDITOR;
    exports.COMMAND_PRIORITY_HIGH = COMMAND_PRIORITY_HIGH;
    exports.COMMAND_PRIORITY_LOW = COMMAND_PRIORITY_LOW;
    exports.COMMAND_PRIORITY_NORMAL = COMMAND_PRIORITY_NORMAL;
    exports.CONTROLLED_TEXT_INSERTION_COMMAND = CONTROLLED_TEXT_INSERTION_COMMAND;
    exports.COPY_COMMAND = COPY_COMMAND;
    exports.CUT_COMMAND = CUT_COMMAND;
    exports.DELETE_CHARACTER_COMMAND = DELETE_CHARACTER_COMMAND;
    exports.DELETE_LINE_COMMAND = DELETE_LINE_COMMAND;
    exports.DELETE_WORD_COMMAND = DELETE_WORD_COMMAND;
    exports.DEPRECATED_$computeGridMap = DEPRECATED_$computeGridMap;
    exports.DEPRECATED_$createGridSelection = DEPRECATED_$createGridSelection;
    exports.DEPRECATED_$getGridCellNodeRect = DEPRECATED_$getGridCellNodeRect;
    exports.DEPRECATED_$getNodeTriplet = DEPRECATED_$getNodeTriplet;
    exports.DEPRECATED_$isGridCellNode = DEPRECATED_$isGridCellNode;
    exports.DEPRECATED_$isGridNode = DEPRECATED_$isGridNode;
    exports.DEPRECATED_$isGridRowNode = DEPRECATED_$isGridRowNode;
    exports.DEPRECATED_$isGridSelection = DEPRECATED_$isGridSelection;
    exports.DEPRECATED_GridCellNode = DEPRECATED_GridCellNode;
    exports.DEPRECATED_GridNode = DEPRECATED_GridNode;
    exports.DEPRECATED_GridRowNode = DEPRECATED_GridRowNode;
    exports.DRAGEND_COMMAND = DRAGEND_COMMAND;
    exports.DRAGOVER_COMMAND = DRAGOVER_COMMAND;
    exports.DRAGSTART_COMMAND = DRAGSTART_COMMAND;
    exports.DROP_COMMAND = DROP_COMMAND;
    exports.DecoratorNode = DecoratorNode;
    exports.ElementNode = ElementNode;
    exports.FOCUS_COMMAND = FOCUS_COMMAND;
    exports.FORMAT_ELEMENT_COMMAND = FORMAT_ELEMENT_COMMAND;
    exports.FORMAT_TEXT_COMMAND = FORMAT_TEXT_COMMAND2;
    exports.INDENT_CONTENT_COMMAND = INDENT_CONTENT_COMMAND;
    exports.INSERT_LINE_BREAK_COMMAND = INSERT_LINE_BREAK_COMMAND;
    exports.INSERT_PARAGRAPH_COMMAND = INSERT_PARAGRAPH_COMMAND;
    exports.INSERT_TAB_COMMAND = INSERT_TAB_COMMAND;
    exports.KEY_ARROW_DOWN_COMMAND = KEY_ARROW_DOWN_COMMAND;
    exports.KEY_ARROW_LEFT_COMMAND = KEY_ARROW_LEFT_COMMAND;
    exports.KEY_ARROW_RIGHT_COMMAND = KEY_ARROW_RIGHT_COMMAND;
    exports.KEY_ARROW_UP_COMMAND = KEY_ARROW_UP_COMMAND;
    exports.KEY_BACKSPACE_COMMAND = KEY_BACKSPACE_COMMAND;
    exports.KEY_DELETE_COMMAND = KEY_DELETE_COMMAND;
    exports.KEY_DOWN_COMMAND = KEY_DOWN_COMMAND2;
    exports.KEY_ENTER_COMMAND = KEY_ENTER_COMMAND;
    exports.KEY_ESCAPE_COMMAND = KEY_ESCAPE_COMMAND;
    exports.KEY_MODIFIER_COMMAND = KEY_MODIFIER_COMMAND;
    exports.KEY_SPACE_COMMAND = KEY_SPACE_COMMAND;
    exports.KEY_TAB_COMMAND = KEY_TAB_COMMAND;
    exports.LineBreakNode = LineBreakNode;
    exports.MOVE_TO_END = MOVE_TO_END;
    exports.MOVE_TO_START = MOVE_TO_START;
    exports.OUTDENT_CONTENT_COMMAND = OUTDENT_CONTENT_COMMAND;
    exports.PASTE_COMMAND = PASTE_COMMAND;
    exports.ParagraphNode = ParagraphNode2;
    exports.REDO_COMMAND = REDO_COMMAND;
    exports.REMOVE_TEXT_COMMAND = REMOVE_TEXT_COMMAND;
    exports.RootNode = RootNode;
    exports.SELECTION_CHANGE_COMMAND = SELECTION_CHANGE_COMMAND2;
    exports.SELECT_ALL_COMMAND = SELECT_ALL_COMMAND;
    exports.TabNode = TabNode;
    exports.TextNode = TextNode2;
    exports.UNDO_COMMAND = UNDO_COMMAND;
    exports.createCommand = createCommand2;
    exports.createEditor = createEditor;
    exports.getNearestEditorFromDOMNode = getNearestEditorFromDOMNode;
    exports.isHTMLAnchorElement = isHTMLAnchorElement;
    exports.isHTMLElement = isHTMLElement;
    exports.isSelectionCapturedInDecoratorInput = isSelectionCapturedInDecoratorInput;
    exports.isSelectionWithinEditor = isSelectionWithinEditor;
  }
});

// node_modules/lexical/Lexical.js
var require_Lexical = __commonJS({
  "node_modules/lexical/Lexical.js"(exports, module) {
    "use strict";
    var Lexical = true ? require_Lexical_dev() : null;
    module.exports = Lexical;
  }
});

// node_modules/@lexical/selection/LexicalSelection.dev.js
var require_LexicalSelection_dev = __commonJS({
  "node_modules/@lexical/selection/LexicalSelection.dev.js"(exports) {
    "use strict";
    var lexical = require_Lexical();
    var CSS_TO_STYLES = /* @__PURE__ */ new Map();
    function getDOMTextNode(element) {
      let node = element;
      while (node != null) {
        if (node.nodeType === Node.TEXT_NODE) {
          return node;
        }
        node = node.firstChild;
      }
      return null;
    }
    function getDOMIndexWithinParent(node) {
      const parent = node.parentNode;
      if (parent == null) {
        throw new Error("Should never happen");
      }
      return [parent, Array.from(parent.childNodes).indexOf(node)];
    }
    function createDOMRange(editor, anchorNode, _anchorOffset, focusNode, _focusOffset) {
      const anchorKey = anchorNode.getKey();
      const focusKey = focusNode.getKey();
      const range = document.createRange();
      let anchorDOM = editor.getElementByKey(anchorKey);
      let focusDOM = editor.getElementByKey(focusKey);
      let anchorOffset = _anchorOffset;
      let focusOffset = _focusOffset;
      if (lexical.$isTextNode(anchorNode)) {
        anchorDOM = getDOMTextNode(anchorDOM);
      }
      if (lexical.$isTextNode(focusNode)) {
        focusDOM = getDOMTextNode(focusDOM);
      }
      if (anchorNode === void 0 || focusNode === void 0 || anchorDOM === null || focusDOM === null) {
        return null;
      }
      if (anchorDOM.nodeName === "BR") {
        [anchorDOM, anchorOffset] = getDOMIndexWithinParent(anchorDOM);
      }
      if (focusDOM.nodeName === "BR") {
        [focusDOM, focusOffset] = getDOMIndexWithinParent(focusDOM);
      }
      const firstChild = anchorDOM.firstChild;
      if (anchorDOM === focusDOM && firstChild != null && firstChild.nodeName === "BR" && anchorOffset === 0 && focusOffset === 0) {
        focusOffset = 1;
      }
      try {
        range.setStart(anchorDOM, anchorOffset);
        range.setEnd(focusDOM, focusOffset);
      } catch (e) {
        return null;
      }
      if (range.collapsed && (anchorOffset !== focusOffset || anchorKey !== focusKey)) {
        range.setStart(focusDOM, focusOffset);
        range.setEnd(anchorDOM, anchorOffset);
      }
      return range;
    }
    function createRectsFromDOMRange(editor, range) {
      const rootElement = editor.getRootElement();
      if (rootElement === null) {
        return [];
      }
      const rootRect = rootElement.getBoundingClientRect();
      const computedStyle = getComputedStyle(rootElement);
      const rootPadding = parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight);
      const selectionRects = Array.from(range.getClientRects());
      let selectionRectsLength = selectionRects.length;
      selectionRects.sort((a, b) => {
        const top = a.top - b.top;
        if (Math.abs(top) <= 3) {
          return a.left - b.left;
        }
        return top;
      });
      let prevRect;
      for (let i = 0; i < selectionRectsLength; i++) {
        const selectionRect = selectionRects[i];
        const isOverlappingRect = prevRect && prevRect.top <= selectionRect.top && prevRect.top + prevRect.height > selectionRect.top && prevRect.left + prevRect.width > selectionRect.left;
        const selectionSpansElement = selectionRect.width + rootPadding === rootRect.width;
        if (isOverlappingRect || selectionSpansElement) {
          selectionRects.splice(i--, 1);
          selectionRectsLength--;
          continue;
        }
        prevRect = selectionRect;
      }
      return selectionRects;
    }
    function getStyleObjectFromRawCSS(css) {
      const styleObject = {};
      const styles = css.split(";");
      for (const style of styles) {
        if (style !== "") {
          const [key, value] = style.split(/:([^]+)/);
          styleObject[key.trim()] = value.trim();
        }
      }
      return styleObject;
    }
    function getStyleObjectFromCSS(css) {
      let value = CSS_TO_STYLES.get(css);
      if (value === void 0) {
        value = getStyleObjectFromRawCSS(css);
        CSS_TO_STYLES.set(css, value);
      }
      {
        Object.freeze(value);
      }
      return value;
    }
    function getCSSFromStyleObject(styles) {
      let css = "";
      for (const style in styles) {
        if (style) {
          css += `${style}: ${styles[style]};`;
        }
      }
      return css;
    }
    function $updateElementNodeProperties(target, source) {
      target.__first = source.__first;
      target.__last = source.__last;
      target.__size = source.__size;
      target.__format = source.__format;
      target.__indent = source.__indent;
      target.__dir = source.__dir;
      return target;
    }
    function $updateTextNodeProperties(target, source) {
      target.__format = source.__format;
      target.__style = source.__style;
      target.__mode = source.__mode;
      target.__detail = source.__detail;
      return target;
    }
    function $cloneWithProperties(node) {
      const constructor = node.constructor;
      const clone = constructor.clone(node);
      clone.__parent = node.__parent;
      clone.__next = node.__next;
      clone.__prev = node.__prev;
      if (lexical.$isElementNode(node) && lexical.$isElementNode(clone)) {
        return $updateElementNodeProperties(clone, node);
      }
      if (lexical.$isTextNode(node) && lexical.$isTextNode(clone)) {
        return $updateTextNodeProperties(clone, node);
      }
      return clone;
    }
    function $sliceSelectedTextNodeContent(selection, textNode) {
      if (textNode.isSelected() && !textNode.isSegmented() && !textNode.isToken() && (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection))) {
        const anchorNode = selection.anchor.getNode();
        const focusNode = selection.focus.getNode();
        const isAnchor = textNode.is(anchorNode);
        const isFocus = textNode.is(focusNode);
        if (isAnchor || isFocus) {
          const isBackward = selection.isBackward();
          const [anchorOffset, focusOffset] = selection.getCharacterOffsets();
          const isSame = anchorNode.is(focusNode);
          const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
          const isLast = textNode.is(isBackward ? anchorNode : focusNode);
          let startOffset = 0;
          let endOffset = void 0;
          if (isSame) {
            startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
            endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
          } else if (isFirst) {
            const offset = isBackward ? focusOffset : anchorOffset;
            startOffset = offset;
            endOffset = void 0;
          } else if (isLast) {
            const offset = isBackward ? anchorOffset : focusOffset;
            startOffset = 0;
            endOffset = offset;
          }
          textNode.__text = textNode.__text.slice(startOffset, endOffset);
          return textNode;
        }
      }
      return textNode;
    }
    function $isAtNodeEnd(point) {
      if (point.type === "text") {
        return point.offset === point.getNode().getTextContentSize();
      }
      return point.offset === point.getNode().getChildrenSize();
    }
    function trimTextContentFromAnchor(editor, anchor, delCount) {
      let currentNode = anchor.getNode();
      let remaining = delCount;
      if (lexical.$isElementNode(currentNode)) {
        const descendantNode = currentNode.getDescendantByIndex(anchor.offset);
        if (descendantNode !== null) {
          currentNode = descendantNode;
        }
      }
      while (remaining > 0 && currentNode !== null) {
        let nextNode = currentNode.getPreviousSibling();
        let additionalElementWhitespace = 0;
        if (nextNode === null) {
          let parent = currentNode.getParentOrThrow();
          let parentSibling = parent.getPreviousSibling();
          while (parentSibling === null) {
            parent = parent.getParent();
            if (parent === null) {
              nextNode = null;
              break;
            }
            parentSibling = parent.getPreviousSibling();
          }
          if (parent !== null) {
            additionalElementWhitespace = parent.isInline() ? 0 : 2;
            if (lexical.$isElementNode(parentSibling)) {
              nextNode = parentSibling.getLastDescendant();
            } else {
              nextNode = parentSibling;
            }
          }
        }
        let text2 = currentNode.getTextContent();
        if (text2 === "" && lexical.$isElementNode(currentNode) && !currentNode.isInline()) {
          text2 = "\n\n";
        }
        const currentNodeSize = text2.length;
        if (!lexical.$isTextNode(currentNode) || remaining >= currentNodeSize) {
          const parent = currentNode.getParent();
          currentNode.remove();
          if (parent != null && parent.getChildrenSize() === 0 && !lexical.$isRootNode(parent)) {
            parent.remove();
          }
          remaining -= currentNodeSize + additionalElementWhitespace;
          currentNode = nextNode;
        } else {
          const key = currentNode.getKey();
          const prevTextContent = editor.getEditorState().read(() => {
            const prevNode = lexical.$getNodeByKey(key);
            if (lexical.$isTextNode(prevNode) && prevNode.isSimpleText()) {
              return prevNode.getTextContent();
            }
            return null;
          });
          const offset = currentNodeSize - remaining;
          const slicedText = text2.slice(0, offset);
          if (prevTextContent !== null && prevTextContent !== text2) {
            const prevSelection = lexical.$getPreviousSelection();
            let target = currentNode;
            if (!currentNode.isSimpleText()) {
              const textNode = lexical.$createTextNode(prevTextContent);
              currentNode.replace(textNode);
              target = textNode;
            } else {
              currentNode.setTextContent(prevTextContent);
            }
            if (lexical.$isRangeSelection(prevSelection) && prevSelection.isCollapsed()) {
              const prevOffset = prevSelection.anchor.offset;
              target.select(prevOffset, prevOffset);
            }
          } else if (currentNode.isSimpleText()) {
            const isSelected = anchor.key === key;
            let anchorOffset = anchor.offset;
            if (anchorOffset < remaining) {
              anchorOffset = currentNodeSize;
            }
            const splitStart = isSelected ? anchorOffset - remaining : 0;
            const splitEnd = isSelected ? anchorOffset : offset;
            if (isSelected && splitStart === 0) {
              const [excessNode] = currentNode.splitText(splitStart, splitEnd);
              excessNode.remove();
            } else {
              const [, excessNode] = currentNode.splitText(splitStart, splitEnd);
              excessNode.remove();
            }
          } else {
            const textNode = lexical.$createTextNode(slicedText);
            currentNode.replace(textNode);
          }
          remaining = 0;
        }
      }
    }
    function $addNodeStyle(node) {
      const CSSText = node.getStyle();
      const styles = getStyleObjectFromRawCSS(CSSText);
      CSS_TO_STYLES.set(CSSText, styles);
    }
    function $patchStyle(target, patch) {
      const prevStyles = getStyleObjectFromCSS("getStyle" in target ? target.getStyle() : target.style);
      const newStyles = Object.entries(patch).reduce((styles, [key, value]) => {
        if (value === null) {
          delete styles[key];
        } else {
          styles[key] = value;
        }
        return styles;
      }, {
        ...prevStyles
      });
      const newCSSText = getCSSFromStyleObject(newStyles);
      target.setStyle(newCSSText);
      CSS_TO_STYLES.set(newCSSText, newStyles);
    }
    function $patchStyleText(selection, patch) {
      const selectedNodes = selection.getNodes();
      const selectedNodesLength = selectedNodes.length;
      if (lexical.DEPRECATED_$isGridSelection(selection)) {
        const cellSelection = lexical.$createRangeSelection();
        const cellSelectionAnchor = cellSelection.anchor;
        const cellSelectionFocus = cellSelection.focus;
        for (let i = 0; i < selectedNodesLength; i++) {
          const node = selectedNodes[i];
          if (lexical.DEPRECATED_$isGridCellNode(node)) {
            cellSelectionAnchor.set(node.getKey(), 0, "element");
            cellSelectionFocus.set(node.getKey(), node.getChildrenSize(), "element");
            $patchStyleText(lexical.$normalizeSelection__EXPERIMENTAL(cellSelection), patch);
          }
        }
        lexical.$setSelection(selection);
        return;
      }
      const lastIndex = selectedNodesLength - 1;
      let firstNode = selectedNodes[0];
      let lastNode = selectedNodes[lastIndex];
      if (selection.isCollapsed()) {
        $patchStyle(selection, patch);
        return;
      }
      const anchor = selection.anchor;
      const focus = selection.focus;
      const firstNodeText = firstNode.getTextContent();
      const firstNodeTextLength = firstNodeText.length;
      const focusOffset = focus.offset;
      let anchorOffset = anchor.offset;
      const isBefore = anchor.isBefore(focus);
      let startOffset = isBefore ? anchorOffset : focusOffset;
      let endOffset = isBefore ? focusOffset : anchorOffset;
      const startType = isBefore ? anchor.type : focus.type;
      const endType = isBefore ? focus.type : anchor.type;
      const endKey = isBefore ? focus.key : anchor.key;
      if (lexical.$isTextNode(firstNode) && startOffset === firstNodeTextLength) {
        const nextSibling = firstNode.getNextSibling();
        if (lexical.$isTextNode(nextSibling)) {
          anchorOffset = 0;
          startOffset = 0;
          firstNode = nextSibling;
        }
      }
      if (selectedNodes.length === 1) {
        if (lexical.$isTextNode(firstNode)) {
          startOffset = startType === "element" ? 0 : anchorOffset > focusOffset ? focusOffset : anchorOffset;
          endOffset = endType === "element" ? firstNodeTextLength : anchorOffset > focusOffset ? anchorOffset : focusOffset;
          if (startOffset === endOffset) {
            return;
          }
          if (startOffset === 0 && endOffset === firstNodeTextLength) {
            $patchStyle(firstNode, patch);
            firstNode.select(startOffset, endOffset);
          } else {
            const splitNodes = firstNode.splitText(startOffset, endOffset);
            const replacement = startOffset === 0 ? splitNodes[0] : splitNodes[1];
            $patchStyle(replacement, patch);
            replacement.select(0, endOffset - startOffset);
          }
        }
      } else {
        if (lexical.$isTextNode(firstNode) && startOffset < firstNode.getTextContentSize()) {
          if (startOffset !== 0) {
            firstNode = firstNode.splitText(startOffset)[1];
            startOffset = 0;
          }
          $patchStyle(firstNode, patch);
        }
        if (lexical.$isTextNode(lastNode)) {
          const lastNodeText = lastNode.getTextContent();
          const lastNodeTextLength = lastNodeText.length;
          if (lastNode.__key !== endKey && endOffset !== 0) {
            endOffset = lastNodeTextLength;
          }
          if (endOffset !== lastNodeTextLength) {
            [lastNode] = lastNode.splitText(endOffset);
          }
          if (endOffset !== 0) {
            $patchStyle(lastNode, patch);
          }
        }
        for (let i = 1; i < lastIndex; i++) {
          const selectedNode = selectedNodes[i];
          const selectedNodeKey = selectedNode.getKey();
          if (lexical.$isTextNode(selectedNode) && selectedNodeKey !== firstNode.getKey() && selectedNodeKey !== lastNode.getKey() && !selectedNode.isToken()) {
            $patchStyle(selectedNode, patch);
          }
        }
      }
    }
    function $setBlocksType2(selection, createElement) {
      if (selection.anchor.key === "root") {
        const element = createElement();
        const root2 = lexical.$getRoot();
        const firstChild = root2.getFirstChild();
        if (firstChild) {
          firstChild.replace(element, true);
        } else {
          root2.append(element);
        }
        return;
      }
      const nodes = selection.getNodes();
      let maybeBlock = selection.anchor.getNode().getParentOrThrow();
      if (nodes.indexOf(maybeBlock) === -1) {
        nodes.push(maybeBlock);
      }
      if (maybeBlock.isInline()) {
        maybeBlock = maybeBlock.getParentOrThrow();
        if (nodes.indexOf(maybeBlock) === -1) {
          nodes.push(maybeBlock);
        }
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (!isBlock(node)) {
          continue;
        }
        const targetElement = createElement();
        targetElement.setFormat(node.getFormatType());
        targetElement.setIndent(node.getIndent());
        node.replace(targetElement, true);
      }
    }
    function isBlock(node) {
      if (!lexical.$isElementNode(node) || lexical.$isRootOrShadowRoot(node)) {
        return false;
      }
      const firstChild = node.getFirstChild();
      const isLeafElement = firstChild === null || lexical.$isLineBreakNode(firstChild) || lexical.$isTextNode(firstChild) || firstChild.isInline();
      return !node.isInline() && node.canBeEmpty() !== false && isLeafElement;
    }
    function isPointAttached(point) {
      return point.getNode().isAttached();
    }
    function $removeParentEmptyElements(startingNode) {
      let node = startingNode;
      while (node !== null && !lexical.$isRootOrShadowRoot(node)) {
        const latest = node.getLatest();
        const parentNode = node.getParent();
        if (latest.getChildrenSize() === 0) {
          node.remove(true);
        }
        node = parentNode;
      }
    }
    function $wrapNodes(selection, createElement, wrappingElement = null) {
      const nodes = selection.getNodes();
      const nodesLength = nodes.length;
      const anchor = selection.anchor;
      if (nodesLength === 0 || nodesLength === 1 && anchor.type === "element" && anchor.getNode().getChildrenSize() === 0) {
        const target = anchor.type === "text" ? anchor.getNode().getParentOrThrow() : anchor.getNode();
        const children = target.getChildren();
        let element = createElement();
        element.setFormat(target.getFormatType());
        element.setIndent(target.getIndent());
        children.forEach((child) => element.append(child));
        if (wrappingElement) {
          element = wrappingElement.append(element);
        }
        target.replace(element);
        return;
      }
      let topLevelNode = null;
      let descendants = [];
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isRootOrShadowRoot(node)) {
          $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
          descendants = [];
          topLevelNode = node;
        } else if (topLevelNode === null || topLevelNode !== null && lexical.$hasAncestor(node, topLevelNode)) {
          descendants.push(node);
        } else {
          $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
          descendants = [node];
        }
      }
      $wrapNodesImpl(selection, descendants, descendants.length, createElement, wrappingElement);
    }
    function $wrapNodesImpl(selection, nodes, nodesLength, createElement, wrappingElement = null) {
      if (nodes.length === 0) {
        return;
      }
      const firstNode = nodes[0];
      const elementMapping = /* @__PURE__ */ new Map();
      const elements = [];
      let target = lexical.$isElementNode(firstNode) ? firstNode : firstNode.getParentOrThrow();
      if (target.isInline()) {
        target = target.getParentOrThrow();
      }
      let targetIsPrevSibling = false;
      while (target !== null) {
        const prevSibling = target.getPreviousSibling();
        if (prevSibling !== null) {
          target = prevSibling;
          targetIsPrevSibling = true;
          break;
        }
        target = target.getParentOrThrow();
        if (lexical.$isRootOrShadowRoot(target)) {
          break;
        }
      }
      const emptyElements = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        if (lexical.$isElementNode(node) && node.getChildrenSize() === 0) {
          emptyElements.add(node.getKey());
        }
      }
      const movedNodes = /* @__PURE__ */ new Set();
      for (let i = 0; i < nodesLength; i++) {
        const node = nodes[i];
        let parent = node.getParent();
        if (parent !== null && parent.isInline()) {
          parent = parent.getParent();
        }
        if (parent !== null && lexical.$isLeafNode(node) && !movedNodes.has(node.getKey())) {
          const parentKey = parent.getKey();
          if (elementMapping.get(parentKey) === void 0) {
            const targetElement = createElement();
            targetElement.setFormat(parent.getFormatType());
            targetElement.setIndent(parent.getIndent());
            elements.push(targetElement);
            elementMapping.set(parentKey, targetElement);
            parent.getChildren().forEach((child) => {
              targetElement.append(child);
              movedNodes.add(child.getKey());
              if (lexical.$isElementNode(child)) {
                child.getChildrenKeys().forEach((key) => movedNodes.add(key));
              }
            });
            $removeParentEmptyElements(parent);
          }
        } else if (emptyElements.has(node.getKey())) {
          const targetElement = createElement();
          targetElement.setFormat(node.getFormatType());
          targetElement.setIndent(node.getIndent());
          elements.push(targetElement);
          node.remove(true);
        }
      }
      if (wrappingElement !== null) {
        for (let i = 0; i < elements.length; i++) {
          const element = elements[i];
          wrappingElement.append(element);
        }
      }
      let lastElement = null;
      if (lexical.$isRootOrShadowRoot(target)) {
        if (targetIsPrevSibling) {
          if (wrappingElement !== null) {
            target.insertAfter(wrappingElement);
          } else {
            for (let i = elements.length - 1; i >= 0; i--) {
              const element = elements[i];
              target.insertAfter(element);
            }
          }
        } else {
          const firstChild = target.getFirstChild();
          if (lexical.$isElementNode(firstChild)) {
            target = firstChild;
          }
          if (firstChild === null) {
            if (wrappingElement) {
              target.append(wrappingElement);
            } else {
              for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                target.append(element);
                lastElement = element;
              }
            }
          } else {
            if (wrappingElement !== null) {
              firstChild.insertBefore(wrappingElement);
            } else {
              for (let i = 0; i < elements.length; i++) {
                const element = elements[i];
                firstChild.insertBefore(element);
                lastElement = element;
              }
            }
          }
        }
      } else {
        if (wrappingElement) {
          target.insertAfter(wrappingElement);
        } else {
          for (let i = elements.length - 1; i >= 0; i--) {
            const element = elements[i];
            target.insertAfter(element);
            lastElement = element;
          }
        }
      }
      const prevSelection = lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(prevSelection) && isPointAttached(prevSelection.anchor) && isPointAttached(prevSelection.focus)) {
        lexical.$setSelection(prevSelection.clone());
      } else if (lastElement !== null) {
        lastElement.selectEnd();
      } else {
        selection.dirty = true;
      }
    }
    function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
      const possibleNode = lexical.$getAdjacentNode(selection.focus, isBackward);
      return lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || lexical.$isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
    }
    function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
      selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
    }
    function $isParentElementRTL(selection) {
      const anchorNode = selection.anchor.getNode();
      const parent = lexical.$isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
      return parent.getDirection() === "rtl";
    }
    function $moveCharacter(selection, isHoldingShift, isBackward) {
      const isRTL = $isParentElementRTL(selection);
      $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, "character");
    }
    function $selectAll(selection) {
      const anchor = selection.anchor;
      const focus = selection.focus;
      const anchorNode = anchor.getNode();
      const topParent = anchorNode.getTopLevelElementOrThrow();
      const root2 = topParent.getParentOrThrow();
      let firstNode = root2.getFirstDescendant();
      let lastNode = root2.getLastDescendant();
      let firstType = "element";
      let lastType = "element";
      let lastOffset = 0;
      if (lexical.$isTextNode(firstNode)) {
        firstType = "text";
      } else if (!lexical.$isElementNode(firstNode) && firstNode !== null) {
        firstNode = firstNode.getParentOrThrow();
      }
      if (lexical.$isTextNode(lastNode)) {
        lastType = "text";
        lastOffset = lastNode.getTextContentSize();
      } else if (!lexical.$isElementNode(lastNode) && lastNode !== null) {
        lastNode = lastNode.getParentOrThrow();
      }
      if (firstNode && lastNode) {
        anchor.set(firstNode.getKey(), 0, firstType);
        focus.set(lastNode.getKey(), lastOffset, lastType);
      }
    }
    function $getNodeStyleValueForProperty(node, styleProperty, defaultValue) {
      const css = node.getStyle();
      const styleObject = getStyleObjectFromCSS(css);
      if (styleObject !== null) {
        return styleObject[styleProperty] || defaultValue;
      }
      return defaultValue;
    }
    function $getSelectionStyleValueForProperty(selection, styleProperty, defaultValue = "") {
      let styleValue = null;
      const nodes = selection.getNodes();
      const anchor = selection.anchor;
      const focus = selection.focus;
      const isBackward = selection.isBackward();
      const endOffset = isBackward ? focus.offset : anchor.offset;
      const endNode = isBackward ? focus.getNode() : anchor.getNode();
      if (selection.style !== "") {
        const css = selection.style;
        const styleObject = getStyleObjectFromCSS(css);
        if (styleObject !== null && styleProperty in styleObject) {
          return styleObject[styleProperty];
        }
      }
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        if (i !== 0 && endOffset === 0 && node.is(endNode)) {
          continue;
        }
        if (lexical.$isTextNode(node)) {
          const nodeStyleValue = $getNodeStyleValueForProperty(node, styleProperty, defaultValue);
          if (styleValue === null) {
            styleValue = nodeStyleValue;
          } else if (styleValue !== nodeStyleValue) {
            styleValue = "";
            break;
          }
        }
      }
      return styleValue === null ? defaultValue : styleValue;
    }
    exports.$addNodeStyle = $addNodeStyle;
    exports.$cloneWithProperties = $cloneWithProperties;
    exports.$getSelectionStyleValueForProperty = $getSelectionStyleValueForProperty;
    exports.$isAtNodeEnd = $isAtNodeEnd;
    exports.$isParentElementRTL = $isParentElementRTL;
    exports.$moveCaretSelection = $moveCaretSelection;
    exports.$moveCharacter = $moveCharacter;
    exports.$patchStyleText = $patchStyleText;
    exports.$selectAll = $selectAll;
    exports.$setBlocksType = $setBlocksType2;
    exports.$shouldOverrideDefaultCharacterSelection = $shouldOverrideDefaultCharacterSelection;
    exports.$sliceSelectedTextNodeContent = $sliceSelectedTextNodeContent;
    exports.$wrapNodes = $wrapNodes;
    exports.createDOMRange = createDOMRange;
    exports.createRectsFromDOMRange = createRectsFromDOMRange;
    exports.getStyleObjectFromCSS = getStyleObjectFromCSS;
    exports.trimTextContentFromAnchor = trimTextContentFromAnchor;
  }
});

// node_modules/@lexical/selection/LexicalSelection.js
var require_LexicalSelection = __commonJS({
  "node_modules/@lexical/selection/LexicalSelection.js"(exports, module) {
    "use strict";
    var LexicalSelection = true ? require_LexicalSelection_dev() : null;
    module.exports = LexicalSelection;
  }
});

// node_modules/@lexical/utils/LexicalUtils.dev.js
var require_LexicalUtils_dev = __commonJS({
  "node_modules/@lexical/utils/LexicalUtils.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var lexical = require_Lexical();
    function addClassNamesToElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          const classesToAdd = className.split(" ").filter((n) => n !== "");
          element.classList.add(...classesToAdd);
        }
      });
    }
    function removeClassNamesFromElement(element, ...classNames) {
      classNames.forEach((className) => {
        if (typeof className === "string") {
          element.classList.remove(...className.split(" "));
        }
      });
    }
    function isMimeType(file, acceptableMimeTypes) {
      for (const acceptableType of acceptableMimeTypes) {
        if (file.type.startsWith(acceptableType)) {
          return true;
        }
      }
      return false;
    }
    function mediaFileReader(files, acceptableMimeTypes) {
      const filesIterator = files[Symbol.iterator]();
      return new Promise((resolve, reject) => {
        const processed = [];
        const handleNextFile = () => {
          const {
            done,
            value: file
          } = filesIterator.next();
          if (done) {
            return resolve(processed);
          }
          const fileReader = new FileReader();
          fileReader.addEventListener("error", reject);
          fileReader.addEventListener("load", () => {
            const result = fileReader.result;
            if (typeof result === "string") {
              processed.push({
                file,
                result
              });
            }
            handleNextFile();
          });
          if (isMimeType(file, acceptableMimeTypes)) {
            fileReader.readAsDataURL(file);
          } else {
            handleNextFile();
          }
        };
        handleNextFile();
      });
    }
    function $dfs(startingNode, endingNode) {
      const nodes = [];
      const start = (startingNode || lexical.$getRoot()).getLatest();
      const end = endingNode || (lexical.$isElementNode(start) ? start.getLastDescendant() : start);
      let node = start;
      let depth = $getDepth(node);
      while (node !== null && !node.is(end)) {
        nodes.push({
          depth,
          node
        });
        if (lexical.$isElementNode(node) && node.getChildrenSize() > 0) {
          node = node.getFirstChild();
          depth++;
        } else {
          let sibling = null;
          while (sibling === null && node !== null) {
            sibling = node.getNextSibling();
            if (sibling === null) {
              node = node.getParent();
              depth--;
            } else {
              node = sibling;
            }
          }
        }
      }
      if (node !== null && node.is(end)) {
        nodes.push({
          depth,
          node
        });
      }
      return nodes;
    }
    function $getDepth(node) {
      let innerNode = node;
      let depth = 0;
      while ((innerNode = innerNode.getParent()) !== null) {
        depth++;
      }
      return depth;
    }
    function $getNearestNodeOfType(node, klass) {
      let parent = node;
      while (parent != null) {
        if (parent instanceof klass) {
          return parent;
        }
        parent = parent.getParent();
      }
      return null;
    }
    function $getNearestBlockElementAncestorOrThrow(startNode) {
      const blockNode = $findMatchingParent2(startNode, (node) => lexical.$isElementNode(node) && !node.isInline());
      if (!lexical.$isElementNode(blockNode)) {
        {
          throw Error(`Expected node ${startNode.__key} to have closest block element node.`);
        }
      }
      return blockNode;
    }
    function $findMatchingParent2(startingNode, findFn) {
      let curr = startingNode;
      while (curr !== lexical.$getRoot() && curr != null) {
        if (findFn(curr)) {
          return curr;
        }
        curr = curr.getParent();
      }
      return null;
    }
    function mergeRegister(...func) {
      return () => {
        func.forEach((f) => f());
      };
    }
    function registerNestedElementResolver(editor, targetNode, cloneNode, handleOverlap) {
      const $isTargetNode = (node) => {
        return node instanceof targetNode;
      };
      const $findMatch = (node) => {
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
          const child = children[i];
          if ($isTargetNode(child)) {
            return null;
          }
        }
        let parentNode = node;
        let childNode = node;
        while (parentNode !== null) {
          childNode = parentNode;
          parentNode = parentNode.getParent();
          if ($isTargetNode(parentNode)) {
            return {
              child: childNode,
              parent: parentNode
            };
          }
        }
        return null;
      };
      const elementNodeTransform = (node) => {
        const match = $findMatch(node);
        if (match !== null) {
          const {
            child,
            parent
          } = match;
          if (child.is(node)) {
            handleOverlap(parent, node);
            const nextSiblings = child.getNextSiblings();
            const nextSiblingsLength = nextSiblings.length;
            parent.insertAfter(child);
            if (nextSiblingsLength !== 0) {
              const newParent = cloneNode(parent);
              child.insertAfter(newParent);
              for (let i = 0; i < nextSiblingsLength; i++) {
                newParent.append(nextSiblings[i]);
              }
            }
            if (!parent.canBeEmpty() && parent.getChildrenSize() === 0) {
              parent.remove();
            }
          }
        }
      };
      return editor.registerNodeTransform(targetNode, elementNodeTransform);
    }
    function $restoreEditorState(editor, editorState) {
      const FULL_RECONCILE = 2;
      const nodeMap = /* @__PURE__ */ new Map();
      const activeEditorState = editor._pendingEditorState;
      for (const [key, node] of editorState._nodeMap) {
        const clone = selection.$cloneWithProperties(node);
        if (lexical.$isTextNode(clone)) {
          clone.__text = node.__text;
        }
        nodeMap.set(key, clone);
      }
      if (activeEditorState) {
        activeEditorState._nodeMap = nodeMap;
      }
      editor._dirtyType = FULL_RECONCILE;
      const selection$1 = editorState._selection;
      lexical.$setSelection(selection$1 === null ? null : selection$1.clone());
    }
    function $insertNodeToNearestRoot2(node) {
      const selection2 = lexical.$getSelection() || lexical.$getPreviousSelection();
      if (lexical.$isRangeSelection(selection2)) {
        const {
          focus
        } = selection2;
        const focusNode = focus.getNode();
        const focusOffset = focus.offset;
        if (lexical.$isRootOrShadowRoot(focusNode)) {
          const focusChild = focusNode.getChildAtIndex(focusOffset);
          if (focusChild == null) {
            focusNode.append(node);
          } else {
            focusChild.insertBefore(node);
          }
          node.selectNext();
        } else {
          let splitNode;
          let splitOffset;
          if (lexical.$isTextNode(focusNode)) {
            splitNode = focusNode.getParentOrThrow();
            splitOffset = focusNode.getIndexWithinParent();
            if (focusOffset > 0) {
              splitOffset += 1;
              focusNode.splitText(focusOffset);
            }
          } else {
            splitNode = focusNode;
            splitOffset = focusOffset;
          }
          const [, rightTree] = lexical.$splitNode(splitNode, splitOffset);
          rightTree.insertBefore(node);
          rightTree.selectStart();
        }
      } else {
        if (lexical.$isNodeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
          const nodes = selection2.getNodes();
          nodes[nodes.length - 1].getTopLevelElementOrThrow().insertAfter(node);
        } else {
          const root2 = lexical.$getRoot();
          root2.append(node);
        }
        const paragraphNode = lexical.$createParagraphNode();
        node.insertAfter(paragraphNode);
        paragraphNode.select();
      }
      return node.getLatest();
    }
    function $wrapNodeInElement2(node, createElementNode) {
      const elementNode = createElementNode();
      node.replace(elementNode);
      elementNode.append(node);
      return elementNode;
    }
    function objectKlassEquals(object, objectClass) {
      return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
    }
    function $filter(nodes, filterFn) {
      const result = [];
      for (let i = 0; i < nodes.length; i++) {
        const node = filterFn(nodes[i]);
        if (node !== null) {
          result.push(node);
        }
      }
      return result;
    }
    function $insertFirst(parent, node) {
      const firstChild = parent.getFirstChild();
      if (firstChild !== null) {
        firstChild.insertBefore(node);
      } else {
        parent.append(node);
      }
    }
    exports.$splitNode = lexical.$splitNode;
    exports.isHTMLAnchorElement = lexical.isHTMLAnchorElement;
    exports.isHTMLElement = lexical.isHTMLElement;
    exports.$dfs = $dfs;
    exports.$filter = $filter;
    exports.$findMatchingParent = $findMatchingParent2;
    exports.$getNearestBlockElementAncestorOrThrow = $getNearestBlockElementAncestorOrThrow;
    exports.$getNearestNodeOfType = $getNearestNodeOfType;
    exports.$insertFirst = $insertFirst;
    exports.$insertNodeToNearestRoot = $insertNodeToNearestRoot2;
    exports.$restoreEditorState = $restoreEditorState;
    exports.$wrapNodeInElement = $wrapNodeInElement2;
    exports.addClassNamesToElement = addClassNamesToElement;
    exports.isMimeType = isMimeType;
    exports.mediaFileReader = mediaFileReader;
    exports.mergeRegister = mergeRegister;
    exports.objectKlassEquals = objectKlassEquals;
    exports.registerNestedElementResolver = registerNestedElementResolver;
    exports.removeClassNamesFromElement = removeClassNamesFromElement;
  }
});

// node_modules/@lexical/utils/LexicalUtils.js
var require_LexicalUtils = __commonJS({
  "node_modules/@lexical/utils/LexicalUtils.js"(exports, module) {
    "use strict";
    var LexicalUtils = true ? require_LexicalUtils_dev() : null;
    module.exports = LexicalUtils;
  }
});

// node_modules/@lexical/html/LexicalHtml.dev.js
var require_LexicalHtml_dev = __commonJS({
  "node_modules/@lexical/html/LexicalHtml.dev.js"(exports) {
    "use strict";
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function $generateNodesFromDOM(editor, dom) {
      const elements = dom.body ? dom.body.childNodes : [];
      let lexicalNodes = [];
      for (let i = 0; i < elements.length; i++) {
        const element = elements[i];
        if (!IGNORE_TAGS.has(element.nodeName)) {
          const lexicalNode = $createNodesFromDOM(element, editor);
          if (lexicalNode !== null) {
            lexicalNodes = lexicalNodes.concat(lexicalNode);
          }
        }
      }
      return lexicalNodes;
    }
    function $generateHtmlFromNodes(editor, selection2) {
      if (typeof document === "undefined" || typeof window === "undefined") {
        throw new Error("To use $generateHtmlFromNodes in headless mode please initialize a headless browser implementation such as JSDom before calling this function.");
      }
      const container = document.createElement("div");
      const root2 = lexical.$getRoot();
      const topLevelChildren = root2.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToHTML(editor, topLevelNode, container, selection2);
      }
      return container.innerHTML;
    }
    function $appendNodesToHTML(editor, currentNode, parentElement, selection$1 = null) {
      let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const {
        element,
        after
      } = target.exportDOM(editor);
      if (!element) {
        return false;
      }
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToHTML(editor, childNode, fragment, selection$1);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "html")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        if (utils.isHTMLElement(element)) {
          element.append(fragment);
        }
        parentElement.append(element);
        if (after) {
          const newElement = after.call(target, element);
          if (newElement)
            element.replaceWith(newElement);
        }
      } else {
        parentElement.append(fragment);
      }
      return shouldInclude;
    }
    function getConversionFunction(domNode, editor) {
      const {
        nodeName
      } = domNode;
      const cachedConversions = editor._htmlConversions.get(nodeName.toLowerCase());
      let currentConversion = null;
      if (cachedConversions !== void 0) {
        for (const cachedConversion of cachedConversions) {
          const domConversion = cachedConversion(domNode);
          if (domConversion !== null && (currentConversion === null || currentConversion.priority < domConversion.priority)) {
            currentConversion = domConversion;
          }
        }
      }
      return currentConversion !== null ? currentConversion.conversion : null;
    }
    var IGNORE_TAGS = /* @__PURE__ */ new Set(["STYLE", "SCRIPT"]);
    function $createNodesFromDOM(node, editor, forChildMap = /* @__PURE__ */ new Map(), parentLexicalNode) {
      let lexicalNodes = [];
      if (IGNORE_TAGS.has(node.nodeName)) {
        return lexicalNodes;
      }
      let currentLexicalNode = null;
      const transformFunction = getConversionFunction(node, editor);
      const transformOutput = transformFunction ? transformFunction(node) : null;
      let postTransform = null;
      if (transformOutput !== null) {
        postTransform = transformOutput.after;
        const transformNodes = transformOutput.node;
        currentLexicalNode = Array.isArray(transformNodes) ? transformNodes[transformNodes.length - 1] : transformNodes;
        if (currentLexicalNode !== null) {
          for (const [, forChildFunction] of forChildMap) {
            currentLexicalNode = forChildFunction(currentLexicalNode, parentLexicalNode);
            if (!currentLexicalNode) {
              break;
            }
          }
          if (currentLexicalNode) {
            lexicalNodes.push(...Array.isArray(transformNodes) ? transformNodes : [currentLexicalNode]);
          }
        }
        if (transformOutput.forChild != null) {
          forChildMap.set(node.nodeName, transformOutput.forChild);
        }
      }
      const children = node.childNodes;
      let childLexicalNodes = [];
      for (let i = 0; i < children.length; i++) {
        childLexicalNodes.push(...$createNodesFromDOM(children[i], editor, new Map(forChildMap), currentLexicalNode));
      }
      if (postTransform != null) {
        childLexicalNodes = postTransform(childLexicalNodes);
      }
      if (currentLexicalNode == null) {
        lexicalNodes = lexicalNodes.concat(childLexicalNodes);
      } else {
        if (lexical.$isElementNode(currentLexicalNode)) {
          currentLexicalNode.append(...childLexicalNodes);
        }
      }
      return lexicalNodes;
    }
    exports.$generateHtmlFromNodes = $generateHtmlFromNodes;
    exports.$generateNodesFromDOM = $generateNodesFromDOM;
  }
});

// node_modules/@lexical/html/LexicalHtml.js
var require_LexicalHtml = __commonJS({
  "node_modules/@lexical/html/LexicalHtml.js"(exports, module) {
    "use strict";
    var LexicalHtml = true ? require_LexicalHtml_dev() : null;
    module.exports = LexicalHtml;
  }
});

// node_modules/@lexical/clipboard/LexicalClipboard.dev.js
var require_LexicalClipboard_dev = __commonJS({
  "node_modules/@lexical/clipboard/LexicalClipboard.dev.js"(exports) {
    "use strict";
    var html2 = require_LexicalHtml();
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var CAN_USE_DOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var getDOMSelection = (targetWindow) => CAN_USE_DOM2 ? (targetWindow || window).getSelection() : null;
    function $getHtmlContent(editor) {
      const selection2 = lexical.$getSelection();
      if (selection2 == null) {
        {
          throw Error(`Expected valid LexicalSelection`);
        }
      }
      if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
        return "";
      }
      return html2.$generateHtmlFromNodes(editor, selection2);
    }
    function $getLexicalContent(editor) {
      const selection2 = lexical.$getSelection();
      if (selection2 == null) {
        {
          throw Error(`Expected valid LexicalSelection`);
        }
      }
      if (lexical.$isRangeSelection(selection2) && selection2.isCollapsed() || selection2.getNodes().length === 0) {
        return null;
      }
      return JSON.stringify($generateJSONFromSelectedNodes(editor, selection2));
    }
    function $insertDataTransferForPlainText(dataTransfer, selection2) {
      const text2 = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
      if (text2 != null) {
        selection2.insertRawText(text2);
      }
    }
    function $insertDataTransferForRichText(dataTransfer, selection2, editor) {
      const lexicalString = dataTransfer.getData("application/x-lexical-editor");
      if (lexicalString) {
        try {
          const payload = JSON.parse(lexicalString);
          if (payload.namespace === editor._config.namespace && Array.isArray(payload.nodes)) {
            const nodes = $generateNodesFromSerializedNodes(payload.nodes);
            return $insertGeneratedNodes(editor, nodes, selection2);
          }
        } catch {
        }
      }
      const htmlString = dataTransfer.getData("text/html");
      if (htmlString) {
        try {
          const parser = new DOMParser();
          const dom = parser.parseFromString(htmlString, "text/html");
          const nodes = html2.$generateNodesFromDOM(editor, dom);
          return $insertGeneratedNodes(editor, nodes, selection2);
        } catch {
        }
      }
      const text2 = dataTransfer.getData("text/plain") || dataTransfer.getData("text/uri-list");
      if (text2 != null) {
        if (lexical.$isRangeSelection(selection2)) {
          const parts = text2.split(/(\r?\n|\t)/);
          const partsLength = parts.length;
          for (let i = 0; i < partsLength; i++) {
            const part = parts[i];
            if (part === "\n" || part === "\r\n") {
              selection2.insertParagraph();
            } else if (part === "	") {
              selection2.insertNodes([lexical.$createTabNode()]);
            } else {
              selection2.insertText(part);
            }
          }
        } else {
          selection2.insertRawText(text2);
        }
      }
    }
    function $insertGeneratedNodes(editor, nodes, selection2) {
      const isSelectionInsideOfGrid = lexical.DEPRECATED_$isGridSelection(selection2) || utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null && utils.$findMatchingParent(selection2.focus.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n)) !== null;
      if (isSelectionInsideOfGrid && nodes.length === 1 && lexical.DEPRECATED_$isGridNode(nodes[0])) {
        $mergeGridNodesStrategy(nodes, selection2, false, editor);
        return;
      }
      $basicInsertStrategy(nodes, selection2);
      return;
    }
    function $basicInsertStrategy(nodes, selection2) {
      const topLevelBlocks = [];
      let currentBlock = null;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const isLineBreakNode = lexical.$isLineBreakNode(node);
        if (isLineBreakNode || lexical.$isDecoratorNode(node) && node.isInline() || lexical.$isElementNode(node) && node.isInline() || lexical.$isTextNode(node) || node.isParentRequired()) {
          if (currentBlock === null) {
            currentBlock = node.createParentElementNode();
            topLevelBlocks.push(currentBlock);
            if (isLineBreakNode) {
              continue;
            }
          }
          if (currentBlock !== null) {
            currentBlock.append(node);
          }
        } else {
          topLevelBlocks.push(node);
          currentBlock = null;
        }
      }
      if (lexical.$isRangeSelection(selection2)) {
        selection2.insertNodes(topLevelBlocks);
      } else if (lexical.DEPRECATED_$isGridSelection(selection2)) {
        const anchorCell = selection2.anchor.getNode();
        if (!lexical.DEPRECATED_$isGridCellNode(anchorCell)) {
          {
            throw Error(`Expected Grid Cell in Grid Selection`);
          }
        }
        anchorCell.append(...topLevelBlocks);
      }
    }
    function $mergeGridNodesStrategy(nodes, selection2, isFromLexical, editor) {
      if (nodes.length !== 1 || !lexical.DEPRECATED_$isGridNode(nodes[0])) {
        {
          throw Error(`$mergeGridNodesStrategy: Expected Grid insertion.`);
        }
      }
      const newGrid = nodes[0];
      const newGridRows = newGrid.getChildren();
      const newColumnCount = newGrid.getFirstChildOrThrow().getChildrenSize();
      const newRowCount = newGrid.getChildrenSize();
      const gridCellNode = utils.$findMatchingParent(selection2.anchor.getNode(), (n) => lexical.DEPRECATED_$isGridCellNode(n));
      const gridRowNode = gridCellNode && utils.$findMatchingParent(gridCellNode, (n) => lexical.DEPRECATED_$isGridRowNode(n));
      const gridNode = gridRowNode && utils.$findMatchingParent(gridRowNode, (n) => lexical.DEPRECATED_$isGridNode(n));
      if (!lexical.DEPRECATED_$isGridCellNode(gridCellNode) || !lexical.DEPRECATED_$isGridRowNode(gridRowNode) || !lexical.DEPRECATED_$isGridNode(gridNode)) {
        {
          throw Error(`$mergeGridNodesStrategy: Expected selection to be inside of a Grid.`);
        }
      }
      const startY = gridRowNode.getIndexWithinParent();
      const stopY = Math.min(gridNode.getChildrenSize() - 1, startY + newRowCount - 1);
      const startX = gridCellNode.getIndexWithinParent();
      const stopX = Math.min(gridRowNode.getChildrenSize() - 1, startX + newColumnCount - 1);
      const fromX = Math.min(startX, stopX);
      const fromY = Math.min(startY, stopY);
      const toX = Math.max(startX, stopX);
      const toY = Math.max(startY, stopY);
      const gridRowNodes = gridNode.getChildren();
      let newRowIdx = 0;
      let newAnchorCellKey;
      let newFocusCellKey;
      for (let r = fromY; r <= toY; r++) {
        const currentGridRowNode = gridRowNodes[r];
        if (!lexical.DEPRECATED_$isGridRowNode(currentGridRowNode)) {
          {
            throw Error(`getNodes: expected to find GridRowNode`);
          }
        }
        const newGridRowNode = newGridRows[newRowIdx];
        if (!lexical.DEPRECATED_$isGridRowNode(newGridRowNode)) {
          {
            throw Error(`getNodes: expected to find GridRowNode`);
          }
        }
        const gridCellNodes = currentGridRowNode.getChildren();
        const newGridCellNodes = newGridRowNode.getChildren();
        let newColumnIdx = 0;
        for (let c = fromX; c <= toX; c++) {
          const currentGridCellNode = gridCellNodes[c];
          if (!lexical.DEPRECATED_$isGridCellNode(currentGridCellNode)) {
            {
              throw Error(`getNodes: expected to find GridCellNode`);
            }
          }
          const newGridCellNode = newGridCellNodes[newColumnIdx];
          if (!lexical.DEPRECATED_$isGridCellNode(newGridCellNode)) {
            {
              throw Error(`getNodes: expected to find GridCellNode`);
            }
          }
          if (r === fromY && c === fromX) {
            newAnchorCellKey = currentGridCellNode.getKey();
          } else if (r === toY && c === toX) {
            newFocusCellKey = currentGridCellNode.getKey();
          }
          const originalChildren = currentGridCellNode.getChildren();
          newGridCellNode.getChildren().forEach((child) => {
            if (lexical.$isTextNode(child)) {
              const paragraphNode = lexical.$createParagraphNode();
              paragraphNode.append(child);
              currentGridCellNode.append(child);
            } else {
              currentGridCellNode.append(child);
            }
          });
          originalChildren.forEach((n) => n.remove());
          newColumnIdx++;
        }
        newRowIdx++;
      }
      if (newAnchorCellKey && newFocusCellKey) {
        const newGridSelection = lexical.DEPRECATED_$createGridSelection();
        newGridSelection.set(gridNode.getKey(), newAnchorCellKey, newFocusCellKey);
        lexical.$setSelection(newGridSelection);
        editor.dispatchCommand(lexical.SELECTION_CHANGE_COMMAND, void 0);
      }
    }
    function exportNodeToJSON(node) {
      const serializedNode = node.exportJSON();
      const nodeClass = node.constructor;
      if (serializedNode.type !== nodeClass.getType()) {
        {
          throw Error(`LexicalNode: Node ${nodeClass.name} does not implement .exportJSON().`);
        }
      }
      const serializedChildren = serializedNode.children;
      if (lexical.$isElementNode(node)) {
        if (!Array.isArray(serializedChildren)) {
          {
            throw Error(`LexicalNode: Node ${nodeClass.name} is an element but .exportJSON() does not have a children array.`);
          }
        }
      }
      return serializedNode;
    }
    function $appendNodesToJSON(editor, selection$1, currentNode, targetArray = []) {
      let shouldInclude = selection$1 != null ? currentNode.isSelected(selection$1) : true;
      const shouldExclude = lexical.$isElementNode(currentNode) && currentNode.excludeFromCopy("html");
      let target = currentNode;
      if (selection$1 !== null) {
        let clone = selection.$cloneWithProperties(currentNode);
        clone = lexical.$isTextNode(clone) && selection$1 != null ? selection.$sliceSelectedTextNodeContent(selection$1, clone) : clone;
        target = clone;
      }
      const children = lexical.$isElementNode(target) ? target.getChildren() : [];
      const serializedNode = exportNodeToJSON(target);
      if (lexical.$isTextNode(target)) {
        const text2 = target.__text;
        if (text2.length > 0) {
          serializedNode.text = text2;
        } else {
          shouldInclude = false;
        }
      }
      for (let i = 0; i < children.length; i++) {
        const childNode = children[i];
        const shouldIncludeChild = $appendNodesToJSON(editor, selection$1, childNode, serializedNode.children);
        if (!shouldInclude && lexical.$isElementNode(currentNode) && shouldIncludeChild && currentNode.extractWithChild(childNode, selection$1, "clone")) {
          shouldInclude = true;
        }
      }
      if (shouldInclude && !shouldExclude) {
        targetArray.push(serializedNode);
      } else if (Array.isArray(serializedNode.children)) {
        for (let i = 0; i < serializedNode.children.length; i++) {
          const serializedChildNode = serializedNode.children[i];
          targetArray.push(serializedChildNode);
        }
      }
      return shouldInclude;
    }
    function $generateJSONFromSelectedNodes(editor, selection2) {
      const nodes = [];
      const root2 = lexical.$getRoot();
      const topLevelChildren = root2.getChildren();
      for (let i = 0; i < topLevelChildren.length; i++) {
        const topLevelNode = topLevelChildren[i];
        $appendNodesToJSON(editor, selection2, topLevelNode, nodes);
      }
      return {
        namespace: editor._config.namespace,
        nodes
      };
    }
    function $generateNodesFromSerializedNodes(serializedNodes) {
      const nodes = [];
      for (let i = 0; i < serializedNodes.length; i++) {
        const serializedNode = serializedNodes[i];
        const node = lexical.$parseSerializedNode(serializedNode);
        if (lexical.$isTextNode(node)) {
          selection.$addNodeStyle(node);
        }
        nodes.push(node);
      }
      return nodes;
    }
    var EVENT_LATENCY = 50;
    var clipboardEventTimeout = null;
    async function copyToClipboard(editor, event) {
      if (clipboardEventTimeout !== null) {
        return false;
      }
      if (event !== null) {
        return new Promise((resolve, reject) => {
          editor.update(() => {
            resolve($copyToClipboardEvent(editor, event));
          });
        });
      }
      const rootElement = editor.getRootElement();
      const windowDocument = editor._window == null ? window.document : editor._window.document;
      const domSelection = getDOMSelection(editor._window);
      if (rootElement === null || domSelection === null) {
        return false;
      }
      const element = windowDocument.createElement("span");
      element.style.cssText = "position: fixed; top: -1000px;";
      element.append(windowDocument.createTextNode("#"));
      rootElement.append(element);
      const range = new Range();
      range.setStart(element, 0);
      range.setEnd(element, 1);
      domSelection.removeAllRanges();
      domSelection.addRange(range);
      return new Promise((resolve, reject) => {
        const removeListener = editor.registerCommand(lexical.COPY_COMMAND, (secondEvent) => {
          if (utils.objectKlassEquals(secondEvent, ClipboardEvent)) {
            removeListener();
            if (clipboardEventTimeout !== null) {
              window.clearTimeout(clipboardEventTimeout);
              clipboardEventTimeout = null;
            }
            resolve($copyToClipboardEvent(editor, secondEvent));
          }
          return true;
        }, lexical.COMMAND_PRIORITY_CRITICAL);
        clipboardEventTimeout = window.setTimeout(() => {
          removeListener();
          clipboardEventTimeout = null;
          resolve(false);
        }, EVENT_LATENCY);
        windowDocument.execCommand("copy");
        element.remove();
      });
    }
    function $copyToClipboardEvent(editor, event) {
      const domSelection = getDOMSelection(editor._window);
      if (!domSelection) {
        return false;
      }
      const anchorDOM = domSelection.anchorNode;
      const focusDOM = domSelection.focusNode;
      if (anchorDOM !== null && focusDOM !== null && !lexical.isSelectionWithinEditor(editor, anchorDOM, focusDOM)) {
        return false;
      }
      event.preventDefault();
      const clipboardData = event.clipboardData;
      const selection2 = lexical.$getSelection();
      if (clipboardData === null || selection2 === null) {
        return false;
      }
      const htmlString = $getHtmlContent(editor);
      const lexicalString = $getLexicalContent(editor);
      let plainString = "";
      if (selection2 !== null) {
        plainString = selection2.getTextContent();
      }
      if (htmlString !== null) {
        clipboardData.setData("text/html", htmlString);
      }
      if (lexicalString !== null) {
        clipboardData.setData("application/x-lexical-editor", lexicalString);
      }
      clipboardData.setData("text/plain", plainString);
      return true;
    }
    exports.$generateJSONFromSelectedNodes = $generateJSONFromSelectedNodes;
    exports.$generateNodesFromSerializedNodes = $generateNodesFromSerializedNodes;
    exports.$getHtmlContent = $getHtmlContent;
    exports.$getLexicalContent = $getLexicalContent;
    exports.$insertDataTransferForPlainText = $insertDataTransferForPlainText;
    exports.$insertDataTransferForRichText = $insertDataTransferForRichText;
    exports.$insertGeneratedNodes = $insertGeneratedNodes;
    exports.copyToClipboard = copyToClipboard;
  }
});

// node_modules/@lexical/clipboard/LexicalClipboard.js
var require_LexicalClipboard = __commonJS({
  "node_modules/@lexical/clipboard/LexicalClipboard.js"(exports, module) {
    "use strict";
    var LexicalClipboard = true ? require_LexicalClipboard_dev() : null;
    module.exports = LexicalClipboard;
  }
});

// node_modules/@lexical/rich-text/LexicalRichText.dev.js
var require_LexicalRichText_dev = __commonJS({
  "node_modules/@lexical/rich-text/LexicalRichText.dev.js"(exports) {
    "use strict";
    var clipboard = require_LexicalClipboard();
    var selection = require_LexicalSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    function caretFromPoint(x, y) {
      if (typeof document.caretRangeFromPoint !== "undefined") {
        const range = document.caretRangeFromPoint(x, y);
        if (range === null) {
          return null;
        }
        return {
          node: range.startContainer,
          offset: range.startOffset
        };
      } else if (document.caretPositionFromPoint !== "undefined") {
        const range = document.caretPositionFromPoint(x, y);
        if (range === null) {
          return null;
        }
        return {
          node: range.offsetNode,
          offset: range.offset
        };
      } else {
        return null;
      }
    }
    var CAN_USE_DOM2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
    var documentMode = CAN_USE_DOM2 && "documentMode" in document ? document.documentMode : null;
    CAN_USE_DOM2 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
    CAN_USE_DOM2 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
    var CAN_USE_BEFORE_INPUT = CAN_USE_DOM2 && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
    var IS_SAFARI = CAN_USE_DOM2 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
    var IS_IOS = CAN_USE_DOM2 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
    var IS_CHROME = CAN_USE_DOM2 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
    var IS_APPLE_WEBKIT = CAN_USE_DOM2 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME;
    var DRAG_DROP_PASTE = lexical.createCommand("DRAG_DROP_PASTE_FILE");
    var QuoteNode = class _QuoteNode extends lexical.ElementNode {
      static getType() {
        return "quote";
      }
      static clone(node) {
        return new _QuoteNode(node.__key);
      }
      constructor(key) {
        super(key);
      }
      // View
      createDOM(config) {
        const element = document.createElement("blockquote");
        utils.addClassNamesToElement(element, config.theme.quote);
        return element;
      }
      updateDOM(prevNode, dom) {
        return false;
      }
      static importDOM() {
        return {
          blockquote: (node) => ({
            conversion: convertBlockquoteElement,
            priority: 0
          })
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && utils.isHTMLElement(element)) {
          if (this.isEmpty())
            element.append(document.createElement("br"));
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createQuoteNode();
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          type: "quote"
        };
      }
      // Mutation
      insertNewAfter(_, restoreSelection) {
        const newBlock = lexical.$createParagraphNode();
        const direction = this.getDirection();
        newBlock.setDirection(direction);
        this.insertAfter(newBlock, restoreSelection);
        return newBlock;
      }
      collapseAtStart() {
        const paragraph2 = lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => paragraph2.append(child));
        this.replace(paragraph2);
        return true;
      }
    };
    function $createQuoteNode() {
      return lexical.$applyNodeReplacement(new QuoteNode());
    }
    function $isQuoteNode(node) {
      return node instanceof QuoteNode;
    }
    var HeadingNode = class _HeadingNode extends lexical.ElementNode {
      /** @internal */
      static getType() {
        return "heading";
      }
      static clone(node) {
        return new _HeadingNode(node.__tag, node.__key);
      }
      constructor(tag, key) {
        super(key);
        this.__tag = tag;
      }
      getTag() {
        return this.__tag;
      }
      // View
      createDOM(config) {
        const tag = this.__tag;
        const element = document.createElement(tag);
        const theme = config.theme;
        const classNames = theme.heading;
        if (classNames !== void 0) {
          const className = classNames[tag];
          utils.addClassNamesToElement(element, className);
        }
        return element;
      }
      updateDOM(prevNode, dom) {
        return false;
      }
      static importDOM() {
        return {
          h1: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h2: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h3: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h4: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h5: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          h6: (node) => ({
            conversion: convertHeadingElement,
            priority: 0
          }),
          p: (node) => {
            const paragraph2 = node;
            const firstChild = paragraph2.firstChild;
            if (firstChild !== null && isGoogleDocsTitle(firstChild)) {
              return {
                conversion: () => ({
                  node: null
                }),
                priority: 3
              };
            }
            return null;
          },
          span: (node) => {
            if (isGoogleDocsTitle(node)) {
              return {
                conversion: (domNode) => {
                  return {
                    node: $createHeadingNode("h1")
                  };
                },
                priority: 3
              };
            }
            return null;
          }
        };
      }
      exportDOM(editor) {
        const {
          element
        } = super.exportDOM(editor);
        if (element && utils.isHTMLElement(element)) {
          if (this.isEmpty())
            element.append(document.createElement("br"));
          const formatType = this.getFormatType();
          element.style.textAlign = formatType;
          const direction = this.getDirection();
          if (direction) {
            element.dir = direction;
          }
        }
        return {
          element
        };
      }
      static importJSON(serializedNode) {
        const node = $createHeadingNode(serializedNode.tag);
        node.setFormat(serializedNode.format);
        node.setIndent(serializedNode.indent);
        node.setDirection(serializedNode.direction);
        return node;
      }
      exportJSON() {
        return {
          ...super.exportJSON(),
          tag: this.getTag(),
          type: "heading",
          version: 1
        };
      }
      // Mutation
      insertNewAfter(selection2, restoreSelection = true) {
        const anchorOffet = selection2 ? selection2.anchor.offset : 0;
        const newElement = anchorOffet > 0 && anchorOffet < this.getTextContentSize() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
        const direction = this.getDirection();
        newElement.setDirection(direction);
        this.insertAfter(newElement, restoreSelection);
        return newElement;
      }
      collapseAtStart() {
        const newElement = !this.isEmpty() ? $createHeadingNode(this.getTag()) : lexical.$createParagraphNode();
        const children = this.getChildren();
        children.forEach((child) => newElement.append(child));
        this.replace(newElement);
        return true;
      }
      extractWithChild() {
        return true;
      }
    };
    function isGoogleDocsTitle(domNode) {
      if (domNode.nodeName.toLowerCase() === "span") {
        return domNode.style.fontSize === "26pt";
      }
      return false;
    }
    function convertHeadingElement(element) {
      const nodeName = element.nodeName.toLowerCase();
      let node = null;
      if (nodeName === "h1" || nodeName === "h2" || nodeName === "h3" || nodeName === "h4" || nodeName === "h5" || nodeName === "h6") {
        node = $createHeadingNode(nodeName);
        if (element.style !== null) {
          node.setFormat(element.style.textAlign);
        }
      }
      return {
        node
      };
    }
    function convertBlockquoteElement(element) {
      const node = $createQuoteNode();
      if (element.style !== null) {
        node.setFormat(element.style.textAlign);
      }
      return {
        node
      };
    }
    function $createHeadingNode(headingTag) {
      return lexical.$applyNodeReplacement(new HeadingNode(headingTag));
    }
    function $isHeadingNode2(node) {
      return node instanceof HeadingNode;
    }
    function onPasteForRichText(event, editor) {
      event.preventDefault();
      editor.update(() => {
        const selection2 = lexical.$getSelection();
        const clipboardData = event instanceof InputEvent || event instanceof KeyboardEvent ? null : event.clipboardData;
        if (clipboardData != null && (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2))) {
          clipboard.$insertDataTransferForRichText(clipboardData, selection2, editor);
        }
      }, {
        tag: "paste"
      });
    }
    async function onCutForRichText(event, editor) {
      await clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);
      editor.update(() => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2)) {
          selection2.removeText();
        } else if (lexical.$isNodeSelection(selection2)) {
          selection2.getNodes().forEach((node) => node.remove());
        }
      });
    }
    function eventFiles(event) {
      let dataTransfer = null;
      if (event instanceof DragEvent) {
        dataTransfer = event.dataTransfer;
      } else if (event instanceof ClipboardEvent) {
        dataTransfer = event.clipboardData;
      }
      if (dataTransfer === null) {
        return [false, [], false];
      }
      const types = dataTransfer.types;
      const hasFiles = types.includes("Files");
      const hasContent = types.includes("text/html") || types.includes("text/plain");
      return [hasFiles, Array.from(dataTransfer.files), hasContent];
    }
    function handleIndentAndOutdent(indentOrOutdent) {
      const selection2 = lexical.$getSelection();
      if (!lexical.$isRangeSelection(selection2)) {
        return false;
      }
      const alreadyHandled = /* @__PURE__ */ new Set();
      const nodes = selection2.getNodes();
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const key = node.getKey();
        if (alreadyHandled.has(key)) {
          continue;
        }
        const parentBlock = utils.$getNearestBlockElementAncestorOrThrow(node);
        const parentKey = parentBlock.getKey();
        if (parentBlock.canIndent() && !alreadyHandled.has(parentKey)) {
          alreadyHandled.add(parentKey);
          indentOrOutdent(parentBlock);
        }
      }
      return alreadyHandled.size > 0;
    }
    function $isTargetWithinDecorator(target) {
      const node = lexical.$getNearestNodeFromDOMNode(target);
      return lexical.$isDecoratorNode(node);
    }
    function $isSelectionAtEndOfRoot(selection2) {
      const focus = selection2.focus;
      return focus.key === "root" && focus.offset === lexical.$getRoot().getChildrenSize();
    }
    function registerRichText(editor) {
      const removeListener = utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (payload) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2)) {
          selection2.clear();
          return true;
        }
        return false;
      }, 0), editor.registerCommand(lexical.DELETE_CHARACTER_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteCharacter(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_WORD_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteWord(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DELETE_LINE_COMMAND, (isBackward) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.deleteLine(isBackward);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CONTROLLED_TEXT_INSERTION_COMMAND, (eventOrText) => {
        const selection2 = lexical.$getSelection();
        if (typeof eventOrText === "string") {
          if (lexical.$isRangeSelection(selection2)) {
            selection2.insertText(eventOrText);
          } else if (lexical.DEPRECATED_$isGridSelection(selection2))
            ;
        } else {
          if (!lexical.$isRangeSelection(selection2) && !lexical.DEPRECATED_$isGridSelection(selection2)) {
            return false;
          }
          const dataTransfer = eventOrText.dataTransfer;
          if (dataTransfer != null) {
            clipboard.$insertDataTransferForRichText(dataTransfer, selection2, editor);
          } else if (lexical.$isRangeSelection(selection2)) {
            const data = eventOrText.data;
            if (data) {
              selection2.insertText(data);
            }
            return true;
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REMOVE_TEXT_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.removeText();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_TEXT_COMMAND, (format) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.formatText(format);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.FORMAT_ELEMENT_COMMAND, (format) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2) && !lexical.$isNodeSelection(selection2)) {
          return false;
        }
        const nodes = selection2.getNodes();
        for (const node of nodes) {
          const element = utils.$findMatchingParent(node, (parentNode) => lexical.$isElementNode(parentNode) && !parentNode.isInline());
          if (element !== null) {
            element.setFormat(format);
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_LINE_BREAK_COMMAND, (selectStart) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.insertLineBreak(selectStart);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        selection2.insertParagraph();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INSERT_TAB_COMMAND, () => {
        lexical.$insertNodes([lexical.$createTabNode()]);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.INDENT_CONTENT_COMMAND, () => {
        return handleIndentAndOutdent((block) => {
          const indent = block.getIndent();
          block.setIndent(indent + 1);
        });
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.OUTDENT_CONTENT_COMMAND, () => {
        return handleIndentAndOutdent((block) => {
          const indent = block.getIndent();
          if (indent > 0) {
            block.setIndent(indent - 1);
          }
        });
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_UP_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2) && !$isTargetWithinDecorator(event.target)) {
          const nodes = selection2.getNodes();
          if (nodes.length > 0) {
            nodes[0].selectPrevious();
            return true;
          }
        } else if (lexical.$isRangeSelection(selection2)) {
          const possibleNode = lexical.$getAdjacentNode(selection2.focus, true);
          if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
            possibleNode.selectPrevious();
            event.preventDefault();
            return true;
          }
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_DOWN_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection2)) {
          const nodes = selection2.getNodes();
          if (nodes.length > 0) {
            nodes[0].selectNext(0, 0);
            return true;
          }
        } else if (lexical.$isRangeSelection(selection2)) {
          if ($isSelectionAtEndOfRoot(selection2)) {
            event.preventDefault();
            return true;
          }
          const possibleNode = lexical.$getAdjacentNode(selection2.focus, false);
          if (!event.shiftKey && lexical.$isDecoratorNode(possibleNode) && !possibleNode.isIsolated() && !possibleNode.isInline()) {
            possibleNode.selectNext();
            event.preventDefault();
            return true;
          }
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_LEFT_COMMAND, (event) => {
        const selection$1 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection$1)) {
          const nodes = selection$1.getNodes();
          if (nodes.length > 0) {
            event.preventDefault();
            nodes[0].selectPrevious();
            return true;
          }
        }
        if (!lexical.$isRangeSelection(selection$1)) {
          return false;
        }
        if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, true)) {
          const isHoldingShift = event.shiftKey;
          event.preventDefault();
          selection.$moveCharacter(selection$1, isHoldingShift, true);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ARROW_RIGHT_COMMAND, (event) => {
        const selection$1 = lexical.$getSelection();
        if (lexical.$isNodeSelection(selection$1) && !$isTargetWithinDecorator(event.target)) {
          const nodes = selection$1.getNodes();
          if (nodes.length > 0) {
            event.preventDefault();
            nodes[0].selectNext(0, 0);
            return true;
          }
        }
        if (!lexical.$isRangeSelection(selection$1)) {
          return false;
        }
        const isHoldingShift = event.shiftKey;
        if (selection.$shouldOverrideDefaultCharacterSelection(selection$1, false)) {
          event.preventDefault();
          selection.$moveCharacter(selection$1, isHoldingShift, false);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, (event) => {
        if ($isTargetWithinDecorator(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        event.preventDefault();
        const {
          anchor
        } = selection2;
        const anchorNode = anchor.getNode();
        if (selection2.isCollapsed() && anchor.offset === 0 && !lexical.$isRootNode(anchorNode)) {
          const element = utils.$getNearestBlockElementAncestorOrThrow(anchorNode);
          if (element.getIndent() > 0) {
            return editor.dispatchCommand(lexical.OUTDENT_CONTENT_COMMAND, void 0);
          }
        }
        return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, true);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_DELETE_COMMAND, (event) => {
        if ($isTargetWithinDecorator(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        event.preventDefault();
        return editor.dispatchCommand(lexical.DELETE_CHARACTER_COMMAND, false);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ENTER_COMMAND, (event) => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        if (event !== null) {
          if ((IS_IOS || IS_SAFARI || IS_APPLE_WEBKIT) && CAN_USE_BEFORE_INPUT) {
            return false;
          }
          event.preventDefault();
          if (event.shiftKey) {
            return editor.dispatchCommand(lexical.INSERT_LINE_BREAK_COMMAND, false);
          }
        }
        return editor.dispatchCommand(lexical.INSERT_PARAGRAPH_COMMAND, void 0);
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.KEY_ESCAPE_COMMAND, () => {
        const selection2 = lexical.$getSelection();
        if (!lexical.$isRangeSelection(selection2)) {
          return false;
        }
        editor.blur();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DROP_COMMAND, (event) => {
        const [, files] = eventFiles(event);
        if (files.length > 0) {
          const x = event.clientX;
          const y = event.clientY;
          const eventRange = caretFromPoint(x, y);
          if (eventRange !== null) {
            const {
              offset: domOffset,
              node: domNode
            } = eventRange;
            const node = lexical.$getNearestNodeFromDOMNode(domNode);
            if (node !== null) {
              const selection3 = lexical.$createRangeSelection();
              if (lexical.$isTextNode(node)) {
                selection3.anchor.set(node.getKey(), domOffset, "text");
                selection3.focus.set(node.getKey(), domOffset, "text");
              } else {
                const parentKey = node.getParentOrThrow().getKey();
                const offset = node.getIndexWithinParent() + 1;
                selection3.anchor.set(parentKey, offset, "element");
                selection3.focus.set(parentKey, offset, "element");
              }
              const normalizedSelection = lexical.$normalizeSelection__EXPERIMENTAL(selection3);
              lexical.$setSelection(normalizedSelection);
            }
            editor.dispatchCommand(DRAG_DROP_PASTE, files);
          }
          event.preventDefault();
          return true;
        }
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2)) {
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGSTART_COMMAND, (event) => {
        const [isFileTransfer] = eventFiles(event);
        const selection2 = lexical.$getSelection();
        if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
          return false;
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.DRAGOVER_COMMAND, (event) => {
        const [isFileTransfer] = eventFiles(event);
        const selection2 = lexical.$getSelection();
        if (isFileTransfer && !lexical.$isRangeSelection(selection2)) {
          return false;
        }
        const x = event.clientX;
        const y = event.clientY;
        const eventRange = caretFromPoint(x, y);
        if (eventRange !== null) {
          const node = lexical.$getNearestNodeFromDOMNode(eventRange.node);
          if (lexical.$isDecoratorNode(node)) {
            event.preventDefault();
          }
        }
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.SELECT_ALL_COMMAND, () => {
        lexical.$selectAll();
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.COPY_COMMAND, (event) => {
        clipboard.copyToClipboard(editor, utils.objectKlassEquals(event, ClipboardEvent) ? event : null);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CUT_COMMAND, (event) => {
        onCutForRichText(event, editor);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.PASTE_COMMAND, (event) => {
        const [, files, hasTextContent] = eventFiles(event);
        if (files.length > 0 && !hasTextContent) {
          editor.dispatchCommand(DRAG_DROP_PASTE, files);
          return true;
        }
        if (lexical.isSelectionCapturedInDecoratorInput(event.target)) {
          return false;
        }
        const selection2 = lexical.$getSelection();
        if (lexical.$isRangeSelection(selection2) || lexical.DEPRECATED_$isGridSelection(selection2)) {
          onPasteForRichText(event, editor);
          return true;
        }
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR));
      return removeListener;
    }
    exports.$createHeadingNode = $createHeadingNode;
    exports.$createQuoteNode = $createQuoteNode;
    exports.$isHeadingNode = $isHeadingNode2;
    exports.$isQuoteNode = $isQuoteNode;
    exports.DRAG_DROP_PASTE = DRAG_DROP_PASTE;
    exports.HeadingNode = HeadingNode;
    exports.QuoteNode = QuoteNode;
    exports.eventFiles = eventFiles;
    exports.registerRichText = registerRichText;
  }
});

// node_modules/@lexical/rich-text/LexicalRichText.js
var require_LexicalRichText = __commonJS({
  "node_modules/@lexical/rich-text/LexicalRichText.js"(exports, module) {
    "use strict";
    var LexicalRichText = true ? require_LexicalRichText_dev() : null;
    module.exports = LexicalRichText;
  }
});

// node_modules/@lexical/react/LexicalComposerContext.dev.js
var require_LexicalComposerContext_dev = __commonJS({
  "node_modules/@lexical/react/LexicalComposerContext.dev.js"(exports) {
    "use strict";
    var react = require_react();
    var LexicalComposerContext = react.createContext(null);
    function createLexicalComposerContext(parent, theme) {
      let parentContext = null;
      if (parent != null) {
        parentContext = parent[1];
      }
      function getTheme() {
        if (theme != null) {
          return theme;
        }
        return parentContext != null ? parentContext.getTheme() : null;
      }
      return {
        getTheme
      };
    }
    function useLexicalComposerContext() {
      const composerContext = react.useContext(LexicalComposerContext);
      if (composerContext == null) {
        {
          throw Error(`LexicalComposerContext.useLexicalComposerContext: cannot find a LexicalComposerContext`);
        }
      }
      return composerContext;
    }
    exports.LexicalComposerContext = LexicalComposerContext;
    exports.createLexicalComposerContext = createLexicalComposerContext;
    exports.useLexicalComposerContext = useLexicalComposerContext;
  }
});

// node_modules/@lexical/react/LexicalComposerContext.js
var require_LexicalComposerContext = __commonJS({
  "node_modules/@lexical/react/LexicalComposerContext.js"(exports, module) {
    "use strict";
    var LexicalComposerContext = true ? require_LexicalComposerContext_dev() : null;
    module.exports = LexicalComposerContext;
  }
});

// node_modules/@lexical/history/LexicalHistory.dev.js
var require_LexicalHistory_dev = __commonJS({
  "node_modules/@lexical/history/LexicalHistory.dev.js"(exports) {
    "use strict";
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var HISTORY_MERGE = 0;
    var HISTORY_PUSH = 1;
    var DISCARD_HISTORY_CANDIDATE = 2;
    var OTHER = 0;
    var COMPOSING_CHARACTER = 1;
    var INSERT_CHARACTER_AFTER_SELECTION = 2;
    var DELETE_CHARACTER_BEFORE_SELECTION = 3;
    var DELETE_CHARACTER_AFTER_SELECTION = 4;
    function getDirtyNodes(editorState, dirtyLeaves, dirtyElements) {
      const nodeMap = editorState._nodeMap;
      const nodes = [];
      for (const dirtyLeafKey of dirtyLeaves) {
        const dirtyLeaf = nodeMap.get(dirtyLeafKey);
        if (dirtyLeaf !== void 0) {
          nodes.push(dirtyLeaf);
        }
      }
      for (const [dirtyElementKey, intentionallyMarkedAsDirty] of dirtyElements) {
        if (!intentionallyMarkedAsDirty) {
          continue;
        }
        const dirtyElement = nodeMap.get(dirtyElementKey);
        if (dirtyElement !== void 0 && !lexical.$isRootNode(dirtyElement)) {
          nodes.push(dirtyElement);
        }
      }
      return nodes;
    }
    function getChangeType(prevEditorState, nextEditorState, dirtyLeavesSet, dirtyElementsSet, isComposing) {
      if (prevEditorState === null || dirtyLeavesSet.size === 0 && dirtyElementsSet.size === 0 && !isComposing) {
        return OTHER;
      }
      const nextSelection = nextEditorState._selection;
      const prevSelection = prevEditorState._selection;
      if (isComposing) {
        return COMPOSING_CHARACTER;
      }
      if (!lexical.$isRangeSelection(nextSelection) || !lexical.$isRangeSelection(prevSelection) || !prevSelection.isCollapsed() || !nextSelection.isCollapsed()) {
        return OTHER;
      }
      const dirtyNodes = getDirtyNodes(nextEditorState, dirtyLeavesSet, dirtyElementsSet);
      if (dirtyNodes.length === 0) {
        return OTHER;
      }
      if (dirtyNodes.length > 1) {
        const nextNodeMap = nextEditorState._nodeMap;
        const nextAnchorNode = nextNodeMap.get(nextSelection.anchor.key);
        const prevAnchorNode = nextNodeMap.get(prevSelection.anchor.key);
        if (nextAnchorNode && prevAnchorNode && !prevEditorState._nodeMap.has(nextAnchorNode.__key) && lexical.$isTextNode(nextAnchorNode) && nextAnchorNode.__text.length === 1 && nextSelection.anchor.offset === 1) {
          return INSERT_CHARACTER_AFTER_SELECTION;
        }
        return OTHER;
      }
      const nextDirtyNode = dirtyNodes[0];
      const prevDirtyNode = prevEditorState._nodeMap.get(nextDirtyNode.__key);
      if (!lexical.$isTextNode(prevDirtyNode) || !lexical.$isTextNode(nextDirtyNode) || prevDirtyNode.__mode !== nextDirtyNode.__mode) {
        return OTHER;
      }
      const prevText = prevDirtyNode.__text;
      const nextText = nextDirtyNode.__text;
      if (prevText === nextText) {
        return OTHER;
      }
      const nextAnchor = nextSelection.anchor;
      const prevAnchor = prevSelection.anchor;
      if (nextAnchor.key !== prevAnchor.key || nextAnchor.type !== "text") {
        return OTHER;
      }
      const nextAnchorOffset = nextAnchor.offset;
      const prevAnchorOffset = prevAnchor.offset;
      const textDiff = nextText.length - prevText.length;
      if (textDiff === 1 && prevAnchorOffset === nextAnchorOffset - 1) {
        return INSERT_CHARACTER_AFTER_SELECTION;
      }
      if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset + 1) {
        return DELETE_CHARACTER_BEFORE_SELECTION;
      }
      if (textDiff === -1 && prevAnchorOffset === nextAnchorOffset) {
        return DELETE_CHARACTER_AFTER_SELECTION;
      }
      return OTHER;
    }
    function isTextNodeUnchanged(key, prevEditorState, nextEditorState) {
      const prevNode = prevEditorState._nodeMap.get(key);
      const nextNode = nextEditorState._nodeMap.get(key);
      const prevSelection = prevEditorState._selection;
      const nextSelection = nextEditorState._selection;
      let isDeletingLine = false;
      if (lexical.$isRangeSelection(prevSelection) && lexical.$isRangeSelection(nextSelection)) {
        isDeletingLine = prevSelection.anchor.type === "element" && prevSelection.focus.type === "element" && nextSelection.anchor.type === "text" && nextSelection.focus.type === "text";
      }
      if (!isDeletingLine && lexical.$isTextNode(prevNode) && lexical.$isTextNode(nextNode)) {
        return prevNode.__type === nextNode.__type && prevNode.__text === nextNode.__text && prevNode.__mode === nextNode.__mode && prevNode.__detail === nextNode.__detail && prevNode.__style === nextNode.__style && prevNode.__format === nextNode.__format && prevNode.__parent === nextNode.__parent;
      }
      return false;
    }
    function createMergeActionGetter(editor, delay) {
      let prevChangeTime = Date.now();
      let prevChangeType = OTHER;
      return (prevEditorState, nextEditorState, currentHistoryEntry, dirtyLeaves, dirtyElements, tags) => {
        const changeTime = Date.now();
        if (tags.has("historic")) {
          prevChangeType = OTHER;
          prevChangeTime = changeTime;
          return DISCARD_HISTORY_CANDIDATE;
        }
        const changeType = getChangeType(prevEditorState, nextEditorState, dirtyLeaves, dirtyElements, editor.isComposing());
        const mergeAction = (() => {
          const isSameEditor = currentHistoryEntry === null || currentHistoryEntry.editor === editor;
          const shouldPushHistory = tags.has("history-push");
          const shouldMergeHistory = !shouldPushHistory && isSameEditor && tags.has("history-merge");
          if (shouldMergeHistory) {
            return HISTORY_MERGE;
          }
          if (prevEditorState === null) {
            return HISTORY_PUSH;
          }
          const selection = nextEditorState._selection;
          const hasDirtyNodes = dirtyLeaves.size > 0 || dirtyElements.size > 0;
          if (!hasDirtyNodes) {
            if (selection !== null) {
              return HISTORY_MERGE;
            }
            return DISCARD_HISTORY_CANDIDATE;
          }
          if (shouldPushHistory === false && changeType !== OTHER && changeType === prevChangeType && changeTime < prevChangeTime + delay && isSameEditor) {
            return HISTORY_MERGE;
          }
          if (dirtyLeaves.size === 1) {
            const dirtyLeafKey = Array.from(dirtyLeaves)[0];
            if (isTextNodeUnchanged(dirtyLeafKey, prevEditorState, nextEditorState)) {
              return HISTORY_MERGE;
            }
          }
          return HISTORY_PUSH;
        })();
        prevChangeTime = changeTime;
        prevChangeType = changeType;
        return mergeAction;
      };
    }
    function redo(editor, historyState) {
      const redoStack = historyState.redoStack;
      const undoStack = historyState.undoStack;
      if (redoStack.length !== 0) {
        const current = historyState.current;
        if (current !== null) {
          undoStack.push(current);
          editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);
        }
        const historyStateEntry = redoStack.pop();
        if (redoStack.length === 0) {
          editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);
        }
        historyState.current = historyStateEntry || null;
        if (historyStateEntry) {
          historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
            tag: "historic"
          });
        }
      }
    }
    function undo(editor, historyState) {
      const redoStack = historyState.redoStack;
      const undoStack = historyState.undoStack;
      const undoStackLength = undoStack.length;
      if (undoStackLength !== 0) {
        const current = historyState.current;
        const historyStateEntry = undoStack.pop();
        if (current !== null) {
          redoStack.push(current);
          editor.dispatchCommand(lexical.CAN_REDO_COMMAND, true);
        }
        if (undoStack.length === 0) {
          editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);
        }
        historyState.current = historyStateEntry || null;
        if (historyStateEntry) {
          historyStateEntry.editor.setEditorState(historyStateEntry.editorState, {
            tag: "historic"
          });
        }
      }
    }
    function clearHistory(historyState) {
      historyState.undoStack = [];
      historyState.redoStack = [];
      historyState.current = null;
    }
    function registerHistory(editor, historyState, delay) {
      const getMergeAction = createMergeActionGetter(editor, delay);
      const applyChange = ({
        editorState,
        prevEditorState,
        dirtyLeaves,
        dirtyElements,
        tags
      }) => {
        const current = historyState.current;
        const redoStack = historyState.redoStack;
        const undoStack = historyState.undoStack;
        const currentEditorState = current === null ? null : current.editorState;
        if (current !== null && editorState === currentEditorState) {
          return;
        }
        const mergeAction = getMergeAction(prevEditorState, editorState, current, dirtyLeaves, dirtyElements, tags);
        if (mergeAction === HISTORY_PUSH) {
          if (redoStack.length !== 0) {
            historyState.redoStack = [];
            editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);
          }
          if (current !== null) {
            undoStack.push({
              ...current
            });
            editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, true);
          }
        } else if (mergeAction === DISCARD_HISTORY_CANDIDATE) {
          return;
        }
        historyState.current = {
          editor,
          editorState
        };
      };
      const unregisterCommandListener = utils.mergeRegister(editor.registerCommand(lexical.UNDO_COMMAND, () => {
        undo(editor, historyState);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.REDO_COMMAND, () => {
        redo(editor, historyState);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_EDITOR_COMMAND, () => {
        clearHistory(historyState);
        return false;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerCommand(lexical.CLEAR_HISTORY_COMMAND, () => {
        clearHistory(historyState);
        editor.dispatchCommand(lexical.CAN_REDO_COMMAND, false);
        editor.dispatchCommand(lexical.CAN_UNDO_COMMAND, false);
        return true;
      }, lexical.COMMAND_PRIORITY_EDITOR), editor.registerUpdateListener(applyChange));
      const unregisterUpdateListener = editor.registerUpdateListener(applyChange);
      return () => {
        unregisterCommandListener();
        unregisterUpdateListener();
      };
    }
    function createEmptyHistoryState2() {
      return {
        current: null,
        redoStack: [],
        undoStack: []
      };
    }
    exports.createEmptyHistoryState = createEmptyHistoryState2;
    exports.registerHistory = registerHistory;
  }
});

// node_modules/@lexical/history/LexicalHistory.js
var require_LexicalHistory = __commonJS({
  "node_modules/@lexical/history/LexicalHistory.js"(exports, module) {
    "use strict";
    var LexicalHistory = true ? require_LexicalHistory_dev() : null;
    module.exports = LexicalHistory;
  }
});

// node_modules/@lexical/react/LexicalHistoryPlugin.dev.js
var require_LexicalHistoryPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalHistoryPlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var history = require_LexicalHistory();
    var react = require_react();
    function useHistory(editor, externalHistoryState, delay = 1e3) {
      const historyState = react.useMemo(() => externalHistoryState || history.createEmptyHistoryState(), [externalHistoryState]);
      react.useEffect(() => {
        return history.registerHistory(editor, historyState, delay);
      }, [delay, editor, historyState]);
    }
    function HistoryPlugin2({
      externalHistoryState
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      useHistory(editor, externalHistoryState);
      return null;
    }
    exports.createEmptyHistoryState = history.createEmptyHistoryState;
    exports.HistoryPlugin = HistoryPlugin2;
  }
});

// node_modules/@lexical/react/LexicalHistoryPlugin.js
var require_LexicalHistoryPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalHistoryPlugin.js"(exports, module) {
    "use strict";
    var LexicalHistoryPlugin = true ? require_LexicalHistoryPlugin_dev() : null;
    module.exports = LexicalHistoryPlugin;
  }
});

// node_modules/@mdxeditor/editor/dist/FormatConstants.js
var IS_BOLD = 1;
var IS_ITALIC = 2;
var IS_UNDERLINE = 8;
var IS_CODE = 16;

// node_modules/@mdxeditor/editor/dist/utils/fp.js
function tap(arg, proc) {
  proc(arg);
  return arg;
}
function noop() {
}

// node_modules/@mdxeditor/editor/dist/utils/detectMac.js
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var IS_APPLE = CAN_USE_DOM && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
function controlOrMeta(metaKey, ctrlKey) {
  if (IS_APPLE) {
    return metaKey;
  }
  return ctrlKey;
}

// node_modules/@mdxeditor/editor/dist/utils/uuid4.js
function uuidv4() {
  const hex = [...Array(256).keys()].map((index) => index.toString(16).padStart(2, "0"));
  const r = crypto.getRandomValues(new Uint8Array(16));
  r[6] = r[6] & 15 | 64;
  r[8] = r[8] & 63 | 128;
  return [...r.entries()].map(([index, int]) => [4, 6, 8, 10].includes(index) ? `-${hex[int]}` : hex[int]).join("");
}

// node_modules/@mdxeditor/editor/dist/gurx/realm.js
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
function defaultComparator(current, next) {
  return current === next;
}
var SetMap = class {
  constructor() {
    __publicField(this, "map", /* @__PURE__ */ new Map());
  }
  getOrCreate(key) {
    let record = this.map.get(key);
    if (!record) {
      record = /* @__PURE__ */ new Set();
      this.map.set(key, record);
    }
    return record;
  }
  get(key) {
    return this.map.get(key);
  }
  use(key, cb) {
    const set = this.get(key);
    if (set !== void 0) {
      cb(set);
    }
  }
  delete(key) {
    return this.map.delete(key);
  }
};
var RefCount = class _RefCount {
  constructor(map3 = /* @__PURE__ */ new Map()) {
    __publicField(this, "map");
    this.map = map3;
  }
  clone() {
    return new _RefCount(new Map(this.map));
  }
  increment(key) {
    const counter = this.map.get(key) ?? 0;
    this.map.set(key, counter + 1);
  }
  decrement(key, ifZero) {
    let counter = this.map.get(key);
    if (counter !== void 0) {
      counter -= 1;
      this.map.set(key, counter);
      if (counter === 0) {
        ifZero();
      }
    }
  }
};
var NO_VALUE = Symbol("NO_VALUE");
function realm() {
  const subscriptions = new SetMap();
  const singletonSubscriptions = /* @__PURE__ */ new Map();
  const graph = new SetMap();
  const state = /* @__PURE__ */ new Map();
  const distinctNodes = /* @__PURE__ */ new Map();
  const labels = {};
  function node(value = NO_VALUE, distinct = false) {
    const key = uuidv4();
    if (value !== NO_VALUE) {
      state.set(key, value);
    }
    if (distinct !== false) {
      distinctNodes.set(key, distinct === true ? defaultComparator : distinct);
    }
    return { key, toString: () => key };
  }
  function subSingle({ key }, subscription) {
    const nodeSubscriptions = subscriptions.getOrCreate(key);
    nodeSubscriptions.add(subscription);
    return () => nodeSubscriptions.delete(subscription);
  }
  function singletonSub({ key }, subscription) {
    if (!subscription) {
      singletonSubscriptions.delete(key);
    } else {
      singletonSubscriptions.set(key, subscription);
    }
    return () => singletonSubscriptions.delete(key);
  }
  function singletonSubKey(key, subscription) {
    return singletonSub(labels[key], subscription);
  }
  function resetSingletonSubs() {
    singletonSubscriptions.clear();
  }
  function subMultiple(sources, cb) {
    const sink = node();
    connect({
      map: (done) => (...args) => {
        done(args);
      },
      sink,
      sources
    });
    return subSingle(sink, cb);
  }
  function sub(...args) {
    const [subscription] = args.slice(-1);
    const nodes = args.slice(0, -1);
    if (nodes.length === 1) {
      return subSingle(nodes[0], subscription);
    } else {
      return subMultiple(nodes, subscription);
    }
  }
  function calculateExecutionMap(keys) {
    const participatingNodeKeys = [];
    const visitedNodes = /* @__PURE__ */ new Set();
    const pendingPulls = new SetMap();
    const refCount = new RefCount();
    const projections = new SetMap();
    function visit2(key, insertIndex = 0) {
      refCount.increment(key);
      if (visitedNodes.has(key)) {
        return;
      }
      pendingPulls.use(key, (pulls) => {
        insertIndex = Math.max(...Array.from(pulls).map((key2) => participatingNodeKeys.indexOf(key2))) + 1;
      });
      graph.use(key, (sinkProjections) => {
        sinkProjections.forEach((projection) => {
          if (projection.sources.has(key)) {
            projections.getOrCreate(projection.sink).add(projection);
            visit2(projection.sink, insertIndex);
          } else {
            pendingPulls.getOrCreate(projection.sink).add(key);
          }
        });
      });
      visitedNodes.add(key);
      participatingNodeKeys.splice(insertIndex, 0, key);
    }
    keys.forEach((key) => visit2(key));
    return { participatingNodeKeys, pendingPulls, projections, refCount };
  }
  const executionMaps = /* @__PURE__ */ new Map();
  function pubIn(values) {
    var _a;
    const keys = Object.keys(values);
    const executionMapKey = keys.join(",");
    if (!executionMaps.has(executionMapKey)) {
      executionMaps.set(executionMapKey, calculateExecutionMap(keys));
    }
    const map22 = executionMaps.get(executionMapKey);
    const refCount = map22.refCount.clone();
    const participatingNodeKeys = map22.participatingNodeKeys.slice();
    const transientState = new Map(state);
    function nodeWillNotEmit(key) {
      graph.use(key, (projections) => {
        projections.forEach(({ sources, sink }) => {
          if (sources.has(key)) {
            refCount.decrement(sink, () => {
              participatingNodeKeys.splice(participatingNodeKeys.indexOf(sink), 1);
              nodeWillNotEmit(sink);
            });
          }
        });
      });
    }
    let nodeKey;
    while (nodeKey = participatingNodeKeys.shift()) {
      let resolved = false;
      const done = (value) => {
        if (distinctNodes.has(nodeKey) && distinctNodes.get(nodeKey)(state.get(nodeKey), value)) {
          resolved = false;
          return;
        }
        resolved = true;
        transientState.set(nodeKey, value);
        if (state.has(nodeKey)) {
          state.set(nodeKey, value);
        }
      };
      if (Object.prototype.hasOwnProperty.call(values, nodeKey)) {
        done(values[nodeKey]);
      } else {
        map22.projections.use(nodeKey, (nodeProjections) => {
          nodeProjections.forEach((projection) => {
            const args = [...Array.from(projection.sources), ...Array.from(projection.pulls)].map((id) => transientState.get(id));
            projection.map(done)(...args);
          });
        });
      }
      if (resolved) {
        const value = transientState.get(nodeKey);
        subscriptions.use(nodeKey, (nodeSubscriptions) => {
          nodeSubscriptions.forEach((subscription) => subscription(value));
        });
        (_a = singletonSubscriptions.get(nodeKey)) == null ? void 0 : _a(value);
      } else {
        nodeWillNotEmit(nodeKey);
      }
    }
  }
  function nodesToKeySet(nodes) {
    return new Set(nodes.map((s) => s.key));
  }
  function connect({ sources, pulls = [], map: map22, sink: { key: sink } }) {
    const dependency = {
      map: map22,
      pulls: nodesToKeySet(pulls),
      sink,
      sources: nodesToKeySet(sources)
    };
    [...sources, ...pulls].forEach(({ key: sourceKey }) => {
      graph.getOrCreate(sourceKey).add(dependency);
    });
    executionMaps.clear();
  }
  function debug() {
    Object.entries(labels).forEach(([name, value]) => {
      state.get(value.key);
    });
  }
  function pub(...args) {
    const map22 = {};
    for (let index = 0; index < args.length; index += 2) {
      const node2 = args[index];
      map22[node2.key] = args[index + 1];
    }
    pubIn(map22);
  }
  function label(newLabels) {
    Object.assign(labels, newLabels);
  }
  function pipe(source, ...operators) {
    for (const operator of operators) {
      source = operator(source);
    }
    return source;
  }
  function spread(source, initialValues) {
    return initialValues.map((initialValue, index) => {
      return tap(node(initialValue, true), (sink) => {
        connect({
          map: (done) => (sourceValue) => {
            done(sourceValue[index]);
          },
          sink,
          sources: [source]
        });
      });
    });
  }
  function link2(source, sink) {
    connect({ map: (done) => (value) => done(value), sink, sources: [source] });
  }
  function derive(source, initial) {
    return tap(node(initial, true), (sink) => {
      connect({ map: (done) => (value) => done(value), sink, sources: [source] });
    });
  }
  function map3(mapFunction) {
    return (source) => {
      const sink = node();
      connect({
        map: (done) => (value) => {
          done(mapFunction(value));
        },
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function mapTo(value) {
    return (source) => {
      const sink = node();
      connect({ map: (done) => () => done(value), sink, sources: [source] });
      return sink;
    };
  }
  function filter(predicate) {
    return (source) => {
      const sink = node();
      connect({ map: (done) => (value) => predicate(value) && done(value), sink, sources: [source] });
      return sink;
    };
  }
  function once() {
    return (source) => {
      const sink = node();
      let passed = false;
      connect({
        map: (done) => (value) => {
          if (!passed) {
            passed = true;
            done(value);
          }
        },
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function scan(accumulator, seed) {
    return (source) => {
      const sink = node();
      connect({ map: (done) => (value) => done(seed = accumulator(seed, value)), sink, sources: [source] });
      return sink;
    };
  }
  function throttleTime(delay) {
    return (source) => {
      const sink = node();
      let currentValue;
      let timeout;
      sub(source, (value) => {
        currentValue = value;
        if (timeout) {
          return;
        }
        timeout = setTimeout(() => {
          timeout = void 0;
          pub(sink, currentValue);
        }, delay);
      });
      return sink;
    };
  }
  function delayWithMicrotask() {
    return (source) => {
      const sink = node();
      sub(source, (value) => queueMicrotask(() => pub(sink, value)));
      return sink;
    };
  }
  function debounceTime(delay) {
    return (source) => {
      const sink = node();
      let currentValue;
      let timeout;
      sub(source, (value) => {
        currentValue = value;
        if (timeout) {
          clearTimeout(timeout);
        }
        timeout = setTimeout(() => {
          pub(sink, currentValue);
        }, delay);
      });
      return sink;
    };
  }
  function onNext(bufNode) {
    return (source) => {
      const sink = node();
      let pendingValue = NO_VALUE;
      sub(source, (value) => pendingValue = value);
      connect({
        map: (done) => (value) => {
          if (pendingValue !== NO_VALUE) {
            done([pendingValue, value]);
            pendingValue = NO_VALUE;
          }
        },
        sink,
        sources: [bufNode]
      });
      return sink;
    };
  }
  function passOnlyAfterNodeHasEmittedBefore(starterNode, durationNode) {
    return (source) => {
      const sink = node();
      let startTime = 0;
      sub(starterNode, () => startTime = Date.now());
      connect({
        map: (done) => (value) => {
          if (Date.now() < startTime + state.get(durationNode.key)) {
            done(value);
          }
        },
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function withLatestFrom(...nodes) {
    return (source) => {
      const sink = node();
      connect({
        map: (done) => (...args) => done(args),
        pulls: nodes,
        sink,
        sources: [source]
      });
      return sink;
    };
  }
  function combine(...nodes) {
    const sink = node();
    connect({
      map: (done) => (...args) => done(args),
      sink,
      sources: nodes
    });
    return sink;
  }
  function subKey(key, subscription) {
    return sub(labels[key], subscription);
  }
  function subKeys(keys, subscription) {
    const nodes = keys.map((key) => labels[key]);
    return sub(...nodes.concat(subscription));
  }
  function pubKey(key, value) {
    pubKeys({ [key]: value });
  }
  function pubKeys(values) {
    const valuesWithInternalKeys = Object.entries(values).reduce(
      (acc, [key, value]) => tap(acc, (acc2) => {
        const label2 = labels[key];
        if (!label2) {
          throw new Error(`No label for key ${key}. Do you miss a plugin?`);
        }
        acc2[label2.key] = value;
        return value;
      }),
      {}
    );
    pubIn(valuesWithInternalKeys);
  }
  function getKeyValue(key) {
    return state.get(labels[key].key);
  }
  function getValue(node2) {
    return state.get(node2.key);
  }
  function getKeyValues(keys) {
    return keys.map((key) => {
      const label2 = labels[key];
      if (!label2) {
        throw new Error(`No label for key ${key}. Do you miss a plugin?`);
      }
      return state.get(label2.key);
    });
  }
  return {
    combine,
    connect,
    debug,
    derive,
    getKeyValue,
    getValue,
    getKeyValues,
    label,
    labels,
    link: link2,
    node,
    o: {
      delayWithMicrotask,
      debounceTime,
      filter,
      map: map3,
      mapTo,
      onNext,
      scan,
      throttleTime,
      withLatestFrom,
      once,
      passOnlyAfterNodeHasEmittedBefore
    },
    pipe,
    pub,
    pubIn,
    pubKey,
    pubKeys,
    resetSingletonSubs,
    singletonSub,
    singletonSubKey,
    spread,
    sub,
    subKey,
    subKeys
  };
}

// node_modules/@mdxeditor/editor/dist/gurx/realmFactory.js
function system(constructor, dependencies = []) {
  return {
    constructor,
    dependencies,
    id: uuidv4()
  };
}
function realmFactory(...specs) {
  const singletons = /* @__PURE__ */ new Map();
  const r = realm();
  const _init = ({ id, constructor, dependencies }) => {
    if (singletons.has(id)) {
      return singletons.get(id);
    }
    const system2 = constructor(r, dependencies.map((t) => _init(specs.find((spec) => spec.id === t.id))));
    r.label(system2);
    singletons.set(id, system2);
    return system2;
  };
  specs.forEach(_init);
  return r;
}

// node_modules/@mdxeditor/editor/dist/gurx/react.js
var import_react = __toESM(require_react(), 1);
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? import_react.default.useLayoutEffect : import_react.default.useEffect;
var GurxContext = import_react.default.createContext(void 0);
function sysHooks() {
  const Context = GurxContext;
  const usePublisher = (key) => {
    const realm2 = import_react.default.useContext(Context);
    return import_react.default.useCallback(
      (value) => {
        realm2.pubKey(key, value);
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [key, realm2]
    );
  };
  const useEmitterValues = (...keys) => {
    const realm2 = import_react.default.useContext(Context);
    const [values, setValues] = import_react.default.useState(() => realm2.getKeyValues(keys));
    (0, import_react.useEffect)(
      () => realm2 == null ? void 0 : realm2.subKeys(keys, (newValues) => {
        const setter = () => {
          if (keys.length === 1) {
            newValues = [newValues];
          }
          for (let i = 0; i < keys.length; i++) {
            if (newValues[i] !== values[i]) {
              setValues(newValues);
            }
          }
        };
        setter();
      }),
      [keys, realm2, values]
    );
    return values;
  };
  const usePubKeys = () => {
    return import_react.default.useContext(Context).pubKeys;
  };
  const useEmitter = (key, callback) => {
    const realm2 = import_react.default.useContext(Context);
    useIsomorphicLayoutEffect(() => realm2.subKey(key, callback), [callback]);
  };
  const useRealmContext = () => {
    return import_react.default.useContext(Context);
  };
  return {
    useRealmContext,
    useEmitter,
    useEmitterValues,
    usePubKeys,
    usePublisher
  };
}
var UsedPluginsContext = import_react.default.createContext(/* @__PURE__ */ new Set());
function realmPlugin(params) {
  const plugin = (pluginParams) => {
    return {
      systemSpec: params.systemSpec,
      pluginParams,
      applyParamsToSystem: params.applyParamsToSystem,
      init: params.init,
      id: params.id,
      dependencies: params.dependencies
    };
  };
  return [plugin, sysHooks()];
}
var RealmPluginInitializer = function({
  plugins,
  children
}) {
  const validPlugins = import_react.default.useMemo(() => {
    const availablePlugins = plugins.map((plugin) => plugin.id);
    const validPlugins2 = plugins.filter((plugin) => {
      if (plugin.dependencies) {
        if (plugin.dependencies.some((dep) => !availablePlugins.includes(dep))) {
          console.warn("MDXEditor plugin", plugin.id, "has some missing dependencies", plugin.dependencies, ", skipping");
          return false;
        }
      }
      return true;
    });
    return validPlugins2;
  }, [plugins]);
  const realm2 = import_react.default.useMemo(() => {
    const specs = validPlugins.map((plugin) => plugin.systemSpec);
    const pluginIds = validPlugins.map((plugin) => plugin.id);
    const realm22 = realmFactory(...specs);
    validPlugins.forEach((plugin) => {
      var _a, _b;
      (_a = plugin.init) == null ? void 0 : _a.call(plugin, realm22, plugin.pluginParams, pluginIds);
      (_b = plugin.applyParamsToSystem) == null ? void 0 : _b.call(plugin, realm22, plugin.pluginParams);
    });
    return realm22;
  }, []);
  import_react.default.useEffect(() => {
    validPlugins.forEach((plugin) => {
      var _a;
      (_a = plugin.applyParamsToSystem) == null ? void 0 : _a.call(plugin, realm2, plugin.pluginParams);
    });
  }, [realm2, validPlugins]);
  const Context = GurxContext;
  return import_react.default.createElement(
    Context.Provider,
    { value: realm2 },
    import_react.default.createElement(UsedPluginsContext.Provider, { value: new Set(plugins.map((plugin) => plugin.id)) }, children)
  );
};
function useHasPlugin(id) {
  const usedPlugins = import_react.default.useContext(UsedPluginsContext);
  return usedPlugins.has(id);
}

// node_modules/@mdxeditor/editor/dist/plugins/core/index.js
var import_LexicalHistoryPlugin2 = __toESM(require_LexicalHistoryPlugin(), 1);
var import_rich_text = __toESM(require_LexicalRichText(), 1);
var import_selection = __toESM(require_LexicalSelection(), 1);
var import_utils = __toESM(require_LexicalUtils(), 1);
var import_lexical10 = __toESM(require_Lexical(), 1);

// node_modules/@mdxeditor/editor/dist/exportMarkdownFromLexical.js
var import_lexical = __toESM(require_Lexical(), 1);

// node_modules/mdast-util-to-markdown/lib/configure.js
function configure(base, extension) {
  let index = -1;
  let key;
  if (extension.extensions) {
    while (++index < extension.extensions.length) {
      configure(base, extension.extensions[index]);
    }
  }
  for (key in extension) {
    if (key === "extensions") {
    } else if (key === "unsafe" || key === "join") {
      base[key] = [...base[key] || [], ...extension[key] || []];
    } else if (key === "handlers") {
      base[key] = Object.assign(base[key], extension[key] || {});
    } else {
      base.options[key] = extension[key];
    }
  }
  return base;
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node, _, state, info) {
  const exit = state.enter("blockquote");
  const tracker = state.createTracker(info);
  tracker.move("> ");
  tracker.shift(2);
  const value = state.indentLines(
    state.containerFlow(node, tracker.current()),
    map
  );
  exit();
  return value;
}
function map(line, _, blank) {
  return ">" + (blank ? "" : " ") + line;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, state, info) {
  let index = -1;
  while (++index < state.unsafe.length) {
    if (state.unsafe[index].character === "\n" && patternInScope(state.stack, state.unsafe[index])) {
      return /[ \t]/.test(info.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, substring) {
  const source = String(value);
  let index = source.indexOf(substring);
  let expected = index;
  let count = 0;
  let max = 0;
  if (typeof substring !== "string") {
    throw new TypeError("Expected substring");
  }
  while (index !== -1) {
    if (index === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index + substring.length;
    index = source.indexOf(substring, expected);
  }
  return max;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node, state) {
  return Boolean(
    !state.options.fences && node.value && // If there’s no info…
    !node.lang && // And there’s a non-whitespace character…
    /[^ \r\n]/.test(node.value) && // And the value doesn’t start or end in a blank…
    !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value)
  );
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(state) {
  const marker = state.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error(
      "Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node, _, state, info) {
  const marker = checkFence(state);
  const raw = node.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(node, state)) {
    const exit2 = state.enter("codeIndented");
    const value2 = state.indentLines(raw, map2);
    exit2();
    return value2;
  }
  const tracker = state.createTracker(info);
  const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
  const exit = state.enter("codeFenced");
  let value = tracker.move(sequence);
  if (node.lang) {
    const subexit = state.enter(`codeFencedLang${suffix}`);
    value += tracker.move(
      state.safe(node.lang, {
        before: value,
        after: " ",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  if (node.lang && node.meta) {
    const subexit = state.enter(`codeFencedMeta${suffix}`);
    value += tracker.move(" ");
    value += tracker.move(
      state.safe(node.meta, {
        before: value,
        after: "\n",
        encode: ["`"],
        ...tracker.current()
      })
    );
    subexit();
  }
  value += tracker.move("\n");
  if (raw) {
    value += tracker.move(raw + "\n");
  }
  value += tracker.move(sequence);
  exit();
  return value;
}
function map2(line, _, blank) {
  return (blank ? "" : "    ") + line;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(state) {
  const marker = state.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error(
      "Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition(node, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit = state.enter("definition");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  value += tracker.move(
    state.safe(state.associationId(node), {
      before: value,
      after: "]",
      ...tracker.current()
    })
  );
  value += tracker.move("]: ");
  subexit();
  if (
    // If there’s no url, or…
    !node.url || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node.url, {
        before: value,
        after: node.title ? " " : "\n",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(state) {
  const marker = state.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node, _, state, info) {
  const marker = checkEmphasis(state);
  const exit = state.enter("emphasis");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker);
  value += tracker.move(
    state.containerPhrasing(node, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker);
  exit();
  return value;
}
function emphasisPeek(_, _1, state) {
  return state.options.emphasis || "*";
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node, state) {
  let literalWithBreak = false;
  visit(node, (node2) => {
    if ("value" in node2 && /\r?\n|\r/.test(node2.value) || node2.type === "break") {
      literalWithBreak = true;
      return EXIT;
    }
  });
  return Boolean(
    (!node.depth || node.depth < 3) && toString(node) && (state.options.setext || literalWithBreak)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node, _, state, info) {
  const rank = Math.max(Math.min(6, node.depth || 1), 1);
  const tracker = state.createTracker(info);
  if (formatHeadingAsSetext(node, state)) {
    const exit2 = state.enter("headingSetext");
    const subexit2 = state.enter("phrasing");
    const value2 = state.containerPhrasing(node, {
      ...tracker.current(),
      before: "\n",
      after: "\n"
    });
    subexit2();
    exit2();
    return value2 + "\n" + (rank === 1 ? "=" : "-").repeat(
      // The whole size…
      value2.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(value2.lastIndexOf("\r"), value2.lastIndexOf("\n")) + 1)
    );
  }
  const sequence = "#".repeat(rank);
  const exit = state.enter("headingAtx");
  const subexit = state.enter("phrasing");
  tracker.move(sequence + " ");
  let value = state.containerPhrasing(node, {
    before: "# ",
    after: "\n",
    ...tracker.current()
  });
  if (/^[\t ]/.test(value)) {
    value = "&#x" + value.charCodeAt(0).toString(16).toUpperCase() + ";" + value.slice(1);
  }
  value = value ? sequence + " " + value : sequence;
  if (state.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node) {
  return node.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image.peek = imagePeek;
function image(node, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit = state.enter("image");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  value += tracker.move(
    state.safe(node.alt, { before: value, after: "]", ...tracker.current() })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node.url && node.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node.url, {
        before: value,
        after: node.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node, _, state, info) {
  const type = node.referenceType;
  const exit = state.enter("imageReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("![");
  const alt = state.safe(node.alt, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(alt + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit();
  if (type === "full" || !alt || alt !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node, state) {
  const raw = toString(node);
  return Boolean(
    !state.options.resourceLink && // If there’s a url…
    node.url && // And there’s a no title…
    !node.title && // And the content of `node` is a single text node…
    node.children && node.children.length === 1 && node.children[0].type === "text" && // And if the url is the same as the content…
    (raw === node.url || "mailto:" + raw === node.url) && // And that starts w/ a protocol…
    /^[a-z][a-z+.-]+:/i.test(node.url) && // And that doesn’t contain ASCII control codes (character escapes and
    // references don’t work), space, or angle brackets…
    !/[\0- <>\u007F]/.test(node.url)
  );
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node, _, state, info) {
  const quote = checkQuote(state);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const tracker = state.createTracker(info);
  let exit;
  let subexit;
  if (formatLinkAsAutolink(node, state)) {
    const stack = state.stack;
    state.stack = [];
    exit = state.enter("autolink");
    let value2 = tracker.move("<");
    value2 += tracker.move(
      state.containerPhrasing(node, {
        before: value2,
        after: ">",
        ...tracker.current()
      })
    );
    value2 += tracker.move(">");
    exit();
    state.stack = stack;
    return value2;
  }
  exit = state.enter("link");
  subexit = state.enter("label");
  let value = tracker.move("[");
  value += tracker.move(
    state.containerPhrasing(node, {
      before: value,
      after: "](",
      ...tracker.current()
    })
  );
  value += tracker.move("](");
  subexit();
  if (
    // If there’s no url but there is a title…
    !node.url && node.title || // If there are control characters or whitespace.
    /[\0- \u007F]/.test(node.url)
  ) {
    subexit = state.enter("destinationLiteral");
    value += tracker.move("<");
    value += tracker.move(
      state.safe(node.url, { before: value, after: ">", ...tracker.current() })
    );
    value += tracker.move(">");
  } else {
    subexit = state.enter("destinationRaw");
    value += tracker.move(
      state.safe(node.url, {
        before: value,
        after: node.title ? " " : ")",
        ...tracker.current()
      })
    );
  }
  subexit();
  if (node.title) {
    subexit = state.enter(`title${suffix}`);
    value += tracker.move(" " + quote);
    value += tracker.move(
      state.safe(node.title, {
        before: value,
        after: quote,
        ...tracker.current()
      })
    );
    value += tracker.move(quote);
    subexit();
  }
  value += tracker.move(")");
  exit();
  return value;
}
function linkPeek(node, _, state) {
  return formatLinkAsAutolink(node, state) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node, _, state, info) {
  const type = node.referenceType;
  const exit = state.enter("linkReference");
  let subexit = state.enter("label");
  const tracker = state.createTracker(info);
  let value = tracker.move("[");
  const text2 = state.containerPhrasing(node, {
    before: value,
    after: "]",
    ...tracker.current()
  });
  value += tracker.move(text2 + "][");
  subexit();
  const stack = state.stack;
  state.stack = [];
  subexit = state.enter("reference");
  const reference = state.safe(state.associationId(node), {
    before: value,
    after: "]",
    ...tracker.current()
  });
  subexit();
  state.stack = stack;
  exit();
  if (type === "full" || !text2 || text2 !== reference) {
    value += tracker.move(reference + "]");
  } else if (type === "shortcut") {
    value = value.slice(0, -1);
  } else {
    value += tracker.move("]");
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(state) {
  const bullet = checkBullet(state);
  const bulletOther = state.options.bulletOther;
  if (!bulletOther) {
    return bullet === "*" ? "-" : "*";
  }
  if (bulletOther !== "*" && bulletOther !== "+" && bulletOther !== "-") {
    throw new Error(
      "Cannot serialize items with `" + bulletOther + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOther === bullet) {
    throw new Error(
      "Expected `bullet` (`" + bullet + "`) and `bulletOther` (`" + bulletOther + "`) to be different"
    );
  }
  return bulletOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(state) {
  const marker = state.options.bulletOrdered || ".";
  if (marker !== "." && marker !== ")") {
    throw new Error(
      "Cannot serialize items with `" + marker + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js
function checkBulletOrderedOther(state) {
  const bulletOrdered = checkBulletOrdered(state);
  const bulletOrderedOther = state.options.bulletOrderedOther;
  if (!bulletOrderedOther) {
    return bulletOrdered === "." ? ")" : ".";
  }
  if (bulletOrderedOther !== "." && bulletOrderedOther !== ")") {
    throw new Error(
      "Cannot serialize items with `" + bulletOrderedOther + "` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`"
    );
  }
  if (bulletOrderedOther === bulletOrdered) {
    throw new Error(
      "Expected `bulletOrdered` (`" + bulletOrdered + "`) and `bulletOrderedOther` (`" + bulletOrderedOther + "`) to be different"
    );
  }
  return bulletOrderedOther;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(state) {
  const marker = state.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error(
      "Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list(node, parent, state, info) {
  const exit = state.enter("list");
  const bulletCurrent = state.bulletCurrent;
  let bullet = node.ordered ? checkBulletOrdered(state) : checkBullet(state);
  const bulletOther = node.ordered ? checkBulletOrderedOther(state) : checkBulletOther(state);
  const bulletLastUsed = state.bulletLastUsed;
  let useDifferentMarker = false;
  if (parent && // Explicit `other` set.
  (node.ordered ? state.options.bulletOrderedOther : state.options.bulletOther) && bulletLastUsed && bullet === bulletLastUsed) {
    useDifferentMarker = true;
  }
  if (!node.ordered) {
    const firstListItem = node.children ? node.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (bullet === "*" || bullet === "-") && // Empty first list item:
      firstListItem && (!firstListItem.children || !firstListItem.children[0]) && // Directly in two other list items:
      state.stack[state.stack.length - 1] === "list" && state.stack[state.stack.length - 2] === "listItem" && state.stack[state.stack.length - 3] === "list" && state.stack[state.stack.length - 4] === "listItem" && // That are each the first child.
      state.indexStack[state.indexStack.length - 1] === 0 && state.indexStack[state.indexStack.length - 2] === 0 && state.indexStack[state.indexStack.length - 3] === 0
    ) {
      useDifferentMarker = true;
    }
    if (checkRule(state) === bullet && firstListItem) {
      let index = -1;
      while (++index < node.children.length) {
        const item = node.children[index];
        if (item && item.type === "listItem" && item.children && item.children[0] && item.children[0].type === "thematicBreak") {
          useDifferentMarker = true;
          break;
        }
      }
    }
  }
  if (useDifferentMarker) {
    bullet = bulletOther;
  }
  state.bulletCurrent = bullet;
  const value = state.containerFlow(node, info);
  state.bulletLastUsed = bullet;
  state.bulletCurrent = bulletCurrent;
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node, _, state, info) {
  const exit = state.enter("paragraph");
  const subexit = state.enter("phrasing");
  const value = state.containerPhrasing(node, info);
  subexit();
  exit();
  return value;
}

// node_modules/mdast-util-phrasing/lib/index.js
var phrasing = (
  /** @type {AssertPredicatePhrasing} */
  convert([
    "break",
    "delete",
    "emphasis",
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    "link",
    "linkReference",
    "strong",
    "text"
  ])
);

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node, _, state, info) {
  const hasPhrasing = node.children.some((d) => phrasing(d));
  const fn = hasPhrasing ? state.containerPhrasing : state.containerFlow;
  return fn.call(state, node, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(state) {
  const marker = state.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error(
      "Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`"
    );
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node, _, state, info) {
  const marker = checkStrong(state);
  const exit = state.enter("strong");
  const tracker = state.createTracker(info);
  let value = tracker.move(marker + marker);
  value += tracker.move(
    state.containerPhrasing(node, {
      before: value,
      after: marker,
      ...tracker.current()
    })
  );
  value += tracker.move(marker + marker);
  exit();
  return value;
}
function strongPeek(_, _1, state) {
  return state.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text(node, _, state, info) {
  return state.safe(node.value, info);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(state) {
  const repetition = state.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error(
      "Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more"
    );
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak(_, _1, state) {
  const value = (checkRule(state) + (state.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(state));
  return state.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list,
  listItem,
  paragraph,
  root,
  strong,
  text,
  thematicBreak
};

// node_modules/mdast-util-to-markdown/lib/join.js
var join = [joinDefaults];
function joinDefaults(left, right, parent, state) {
  if (right.type === "code" && formatCodeAsIndented(right, state) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, state))) {
    return false;
  }
  if (left.type === "list" && left.type === right.type && Boolean(left.ordered) === Boolean(right.ordered) && !(left.ordered ? state.options.bulletOrderedOther : state.options.bulletOther)) {
    return false;
  }
  if ("spread" in parent && typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && // Two paragraphs.
    (left.type === right.type || right.type === "definition" || // Paragraph followed by a setext heading.
    right.type === "heading" && formatHeadingAsSetext(right, state))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
var unsafe = [
  { character: "	", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: "	", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  { character: " ", after: "[\\r\\n]", inConstruct: "phrasing" },
  { character: " ", before: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  // An exclamation mark can start an image, if it is followed by a link or
  // a link reference.
  {
    character: "!",
    after: "\\[",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A quote can break out of a title.
  { character: '"', inConstruct: "titleQuote" },
  // A number sign could start an ATX heading if it starts a line.
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  // Dollar sign and percentage are not used in markdown.
  // An ampersand could start a character reference.
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  // An apostrophe can break out of a title.
  { character: "'", inConstruct: "titleApostrophe" },
  // A left paren could break out of a destination raw.
  { character: "(", inConstruct: "destinationRaw" },
  // A left paren followed by `]` could make something into a link or image.
  {
    before: "\\]",
    character: "(",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  // A right paren could start a list item or break out of a destination
  // raw.
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  // An asterisk can start thematic breaks, list items, emphasis, strong.
  { atBreak: true, character: "*", after: "(?:[ 	\r\n*])" },
  { character: "*", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A plus sign could start a list item.
  { atBreak: true, character: "+", after: "(?:[ 	\r\n])" },
  // A dash can start thematic breaks, list items, and setext heading
  // underlines.
  { atBreak: true, character: "-", after: "(?:[ 	\r\n-])" },
  // A dot could start a list item.
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  // Slash, colon, and semicolon are not used in markdown for constructs.
  // A less than can start html (flow or text) or an autolink.
  // HTML could start with an exclamation mark (declaration, cdata, comment),
  // slash (closing tag), question mark (instruction), or a letter (tag).
  // An autolink also starts with a letter.
  // Finally, it could break out of a destination literal.
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  {
    character: "<",
    after: "[!/?A-Za-z]",
    inConstruct: "phrasing",
    notInConstruct: fullPhrasingSpans
  },
  { character: "<", inConstruct: "destinationLiteral" },
  // An equals to can start setext heading underlines.
  { atBreak: true, character: "=" },
  // A greater than can start block quotes and it can break out of a
  // destination literal.
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  // Question mark and at sign are not used in markdown for constructs.
  // A left bracket can start definitions, references, labels,
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  { character: "[", inConstruct: ["label", "reference"] },
  // A backslash can start an escape (when followed by punctuation) or a
  // hard break (when followed by an eol).
  // Note: typical escapes are handled in `safe`!
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  // A right bracket can exit labels.
  { character: "]", inConstruct: ["label", "reference"] },
  // Caret is not used in markdown for constructs.
  // An underscore can start emphasis, strong, or a thematic break.
  { atBreak: true, character: "_" },
  { character: "_", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // A grave accent can start code (fenced or text), or it can break out of
  // a grave accent code fence.
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedMetaGraveAccent"]
  },
  { character: "`", inConstruct: "phrasing", notInConstruct: fullPhrasingSpans },
  // Left brace, vertical bar, right brace are not used in markdown for
  // constructs.
  // A tilde can start code (fenced).
  { atBreak: true, character: "~" }
];

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options = {}) {
  const state = {
    enter,
    indentLines,
    associationId: association,
    containerPhrasing: containerPhrasingBound,
    containerFlow: containerFlowBound,
    createTracker: track,
    safe: safeBound,
    stack: [],
    unsafe: [],
    join: [],
    // @ts-expect-error: we’ll fill it next.
    handlers: {},
    options: {},
    indexStack: [],
    // @ts-expect-error: we’ll add `handle` later.
    handle: void 0
  };
  configure(state, { unsafe, join, handlers: handle });
  configure(state, options);
  if (state.options.tightDefinitions) {
    configure(state, { join: [joinDefinition] });
  }
  state.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: state.handlers
  });
  let result = state.handle(tree, void 0, state, {
    before: "\n",
    after: "\n",
    now: { line: 1, column: 1 },
    lineShift: 0
  });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name) {
    state.stack.push(name);
    return exit;
    function exit() {
      state.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(node) {
  throw new Error("Cannot handle unknown node `" + node.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}
function containerPhrasingBound(parent, info) {
  return containerPhrasing(parent, this, info);
}
function containerFlowBound(parent, info) {
  return containerFlow(parent, this, info);
}
function safeBound(value, config) {
  return safe(this, value, config);
}

// node_modules/@mdxeditor/editor/dist/exportMarkdownFromLexical.js
function isParent(node) {
  return node.children instanceof Array;
}
function exportLexicalTreeToMdast({
  root: root2,
  visitors,
  jsxComponentDescriptors,
  jsxIsAvailable
}) {
  let unistRoot = null;
  const referredComponents = /* @__PURE__ */ new Set();
  visit2(root2, null);
  function registerReferredComponent(componentName) {
    referredComponents.add(componentName);
  }
  function appendToParent(parentNode, node) {
    if (unistRoot === null) {
      unistRoot = node;
      return unistRoot;
    }
    if (!isParent(parentNode)) {
      throw new Error("Attempting to append children to a non-parent");
    }
    const siblings = parentNode.children;
    const prevSibling = siblings.at(-1);
    if (prevSibling) {
      const joinVisitor = visitors.find((visitor) => {
        var _a;
        return (_a = visitor.shouldJoin) == null ? void 0 : _a.call(visitor, prevSibling, node);
      });
      if (joinVisitor) {
        const joinedNode = joinVisitor.join(prevSibling, node);
        siblings.splice(siblings.length - 1, 1, joinedNode);
        return joinedNode;
      }
    }
    siblings.push(node);
    return node;
  }
  function visitChildren(lexicalNode, parentNode) {
    lexicalNode.getChildren().forEach((lexicalChild) => {
      visit2(lexicalChild, parentNode);
    });
  }
  function visit2(lexicalNode, mdastParent) {
    var _a;
    const visitor = visitors.find((visitor2) => {
      var _a2;
      return (_a2 = visitor2.testLexicalNode) == null ? void 0 : _a2.call(visitor2, lexicalNode);
    });
    if (!visitor) {
      throw new Error(`no lexical visitor found for ${lexicalNode.getType()}`, {
        cause: lexicalNode
      });
    }
    (_a = visitor.visitLexicalNode) == null ? void 0 : _a.call(visitor, {
      lexicalNode,
      mdastParent,
      actions: {
        addAndStepInto(type, props = {}, hasChildren = true) {
          const newNode = {
            type,
            ...props,
            ...hasChildren ? { children: [] } : {}
          };
          appendToParent(mdastParent, newNode);
          if ((0, import_lexical.$isElementNode)(lexicalNode) && hasChildren) {
            visitChildren(lexicalNode, newNode);
          }
        },
        appendToParent,
        visitChildren,
        registerReferredComponent
      }
    });
  }
  if (unistRoot === null) {
    throw new Error("traversal ended with no root element");
  }
  const importsMap = /* @__PURE__ */ new Map();
  const defaultImportsMap = /* @__PURE__ */ new Map();
  for (const componentName of referredComponents) {
    const descriptor = jsxComponentDescriptors.find((descriptor2) => descriptor2.name === componentName);
    if (!descriptor) {
      throw new Error(`Component ${componentName} is used but not imported`);
    }
    if (!descriptor.source) {
      continue;
    }
    if (descriptor.defaultExport) {
      defaultImportsMap.set(componentName, descriptor.source);
    } else {
      const { source } = descriptor;
      const existing = importsMap.get(source);
      if (existing) {
        existing.push(componentName);
      } else {
        importsMap.set(source, [componentName]);
      }
    }
  }
  const imports = Array.from(importsMap).map(([source, componentNames]) => {
    return {
      type: "mdxjsEsm",
      value: `import { ${componentNames.join(", ")} } from '${source}'`
    };
  });
  imports.push(
    ...Array.from(defaultImportsMap).map(([componentName, source]) => {
      return {
        type: "mdxjsEsm",
        value: `import ${componentName} from '${source}'`
      };
    })
  );
  const typedRoot = unistRoot;
  const frontmatter = typedRoot.children.find((child) => child.type === "yaml");
  if (frontmatter) {
    typedRoot.children.splice(typedRoot.children.indexOf(frontmatter) + 1, 0, ...imports);
  } else {
    typedRoot.children.unshift(...imports);
  }
  fixWrappingWhitespace(typedRoot, []);
  if (!jsxIsAvailable) {
    convertUnderlineJsxToHtml(typedRoot);
  }
  return typedRoot;
}
function convertUnderlineJsxToHtml(node) {
  if (Object.hasOwn(node, "children")) {
    const nodeAsParent = node;
    const newChildren = [];
    nodeAsParent.children.forEach((child) => {
      if (child.type === "mdxJsxTextElement" && child.name === "u") {
        newChildren.push(...[{ type: "html", value: "<u>" }, ...child.children, { type: "html", value: "</u>" }]);
      } else {
        newChildren.push(child);
        convertUnderlineJsxToHtml(child);
      }
    });
    nodeAsParent.children = newChildren;
  }
}
var TRAILING_WHITESPACE_REGEXP = /\s+$/;
var LEADING_WHITESPACE_REGEXP = /^\s+/;
function fixWrappingWhitespace(node, parentChain) {
  if (node.type === "strong" || node.type === "emphasis") {
    const lastChild = node.children.at(-1);
    if ((lastChild == null ? void 0 : lastChild.type) === "text") {
      const trailingWhitespace = lastChild.value.match(TRAILING_WHITESPACE_REGEXP);
      if (trailingWhitespace) {
        lastChild.value = lastChild.value.replace(TRAILING_WHITESPACE_REGEXP, "");
        const parent = parentChain.at(-1);
        if (parent) {
          parent.children.splice(parent.children.indexOf(node) + 1, 0, {
            type: "text",
            value: trailingWhitespace[0]
          });
          fixWrappingWhitespace(parent, parentChain.slice(0, -1));
        }
      }
    }
    const firstChild = node.children.at(0);
    if ((firstChild == null ? void 0 : firstChild.type) === "text") {
      const leadingWhitespace = firstChild.value.match(LEADING_WHITESPACE_REGEXP);
      if (leadingWhitespace) {
        firstChild.value = firstChild.value.replace(LEADING_WHITESPACE_REGEXP, "");
        const parent = parentChain.at(-1);
        if (parent) {
          parent.children.splice(parent.children.indexOf(node), 0, {
            type: "text",
            value: leadingWhitespace[0]
          });
          fixWrappingWhitespace(parent, parentChain.slice(0, -1));
        }
      }
    }
  }
  if (Object.hasOwn(node, "children")) {
    const nodeAsParent = node;
    nodeAsParent.children.forEach((child) => fixWrappingWhitespace(child, [...parentChain, nodeAsParent]));
  }
}
function exportMarkdownFromLexical({
  root: root2,
  toMarkdownOptions,
  toMarkdownExtensions,
  visitors,
  jsxComponentDescriptors,
  jsxIsAvailable
}) {
  return toMarkdown(exportLexicalTreeToMdast({ root: root2, visitors, jsxComponentDescriptors, jsxIsAvailable }), {
    extensions: toMarkdownExtensions,
    ...toMarkdownOptions
  });
}

// node_modules/@mdxeditor/editor/dist/importMarkdownToLexical.js
function isParent2(node) {
  return node.children instanceof Array;
}
function importMarkdownToLexical({ root: root2, markdown, visitors, syntaxExtensions, mdastExtensions }) {
  var _a;
  const mdastRoot = fromMarkdown(markdown, {
    extensions: syntaxExtensions,
    mdastExtensions
  });
  if (mdastRoot.children.length === 0) {
    mdastRoot.children.push({ type: "paragraph", children: [] });
  }
  if (((_a = mdastRoot.children.at(-1)) == null ? void 0 : _a.type) !== "paragraph") {
    mdastRoot.children.push({ type: "paragraph", children: [] });
  }
  importMdastTreeToLexical({ root: root2, mdastRoot, visitors });
}
function importMdastTreeToLexical({ root: root2, mdastRoot, visitors }) {
  const formattingMap = /* @__PURE__ */ new WeakMap();
  function visitChildren(mdastNode, lexicalParent) {
    if (!isParent2(mdastNode)) {
      throw new Error("Attempting to visit children of a non-parent");
    }
    mdastNode.children.forEach((child) => visit2(child, lexicalParent, mdastNode));
  }
  function visit2(mdastNode, lexicalParent, mdastParent) {
    const visitor = visitors.find((visitor2) => {
      if (typeof visitor2.testNode === "string") {
        return visitor2.testNode === mdastNode.type;
      }
      return visitor2.testNode(mdastNode);
    });
    if (!visitor) {
      throw new Error(`no MdastImportVisitor found for ${mdastNode.type} ${JSON.stringify(mdastNode)}`, {
        cause: mdastNode
      });
    }
    visitor.visitNode({
      //@ts-expect-error root type is glitching
      mdastNode,
      lexicalParent,
      mdastParent,
      actions: {
        visitChildren,
        addAndStepInto(lexicalNode) {
          lexicalParent.append(lexicalNode);
          if (isParent2(mdastNode)) {
            visitChildren(mdastNode, lexicalNode);
          }
        },
        addFormatting(format, node = mdastNode) {
          formattingMap.set(node, format | (formattingMap.get(mdastParent) ?? 0));
        },
        removeFormatting(format, node = mdastNode) {
          formattingMap.set(node, format ^ (formattingMap.get(mdastParent) ?? 0));
        },
        getParentFormatting() {
          return formattingMap.get(mdastParent) ?? 0;
        }
      }
    });
  }
  visit2(mdastRoot, root2, null);
}

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalLinebreakVisitor.js
var import_lexical2 = __toESM(require_Lexical(), 1);
var LexicalLinebreakVisitor = {
  testLexicalNode: import_lexical2.$isLineBreakNode,
  visitLexicalNode: ({ mdastParent, actions }) => {
    actions.appendToParent(mdastParent, { type: "text", value: "\n" });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalParagraphVisitor.js
var import_lexical3 = __toESM(require_Lexical(), 1);
var LexicalParagraphVisitor = {
  testLexicalNode: import_lexical3.$isParagraphNode,
  visitLexicalNode: ({ actions }) => {
    actions.addAndStepInto("paragraph");
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalRootVisitor.js
var import_lexical4 = __toESM(require_Lexical(), 1);
var LexicalRootVisitor = {
  testLexicalNode: import_lexical4.$isRootNode,
  visitLexicalNode: ({ actions }) => {
    actions.addAndStepInto("root");
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/LexicalTextVisitor.js
var import_lexical5 = __toESM(require_Lexical(), 1);
function isMdastText(mdastNode) {
  return mdastNode.type === "text";
}
var LexicalTextVisitor = {
  shouldJoin: (prevNode, currentNode) => {
    return ["text", "emphasis", "strong", "mdxJsxTextElement"].includes(prevNode.type) && prevNode.type === currentNode.type;
  },
  join(prevNode, currentNode) {
    if (isMdastText(prevNode) && isMdastText(currentNode)) {
      return {
        type: "text",
        value: prevNode.value + currentNode.value
      };
    } else {
      return {
        ...prevNode,
        children: [...prevNode.children, ...currentNode.children]
      };
    }
  },
  testLexicalNode: import_lexical5.$isTextNode,
  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {
    const previousSibling = lexicalNode.getPreviousSibling();
    const prevFormat = (0, import_lexical5.$isTextNode)(previousSibling) ? previousSibling.getFormat() : 0;
    const textContent = lexicalNode.getTextContent();
    const format = lexicalNode.getFormat() ?? 0;
    if (format & IS_CODE) {
      actions.addAndStepInto("inlineCode", {
        value: textContent
      });
      return;
    }
    let localParentNode = mdastParent;
    if (prevFormat & format & IS_ITALIC) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "emphasis",
        children: []
      });
    }
    if (prevFormat & format & IS_BOLD) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "strong",
        children: []
      });
    }
    if (prevFormat & format & IS_UNDERLINE) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "u",
        children: [],
        attributes: []
      });
    }
    if (format & IS_ITALIC && !(prevFormat & IS_ITALIC)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "emphasis",
        children: []
      });
    }
    if (format & IS_BOLD && !(prevFormat & IS_BOLD)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "strong",
        children: []
      });
    }
    if (format & IS_UNDERLINE && !(prevFormat & IS_UNDERLINE)) {
      localParentNode = actions.appendToParent(localParentNode, {
        type: "mdxJsxTextElement",
        name: "u",
        children: [],
        attributes: []
      });
    }
    actions.appendToParent(localParentNode, {
      type: "text",
      value: textContent
    });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastFormattingVisitor.js
function isOpeningUnderlineNode(node) {
  return node.type === "html" && node.value === "<u>";
}
function isClosingUnderlineNode(node) {
  return node.type === "html" && node.value === "</u>";
}
function isJsxUnderlineNode(node) {
  return node.type === "mdxJsxTextElement" && node.name === "u";
}
var MdastFormattingVisitor = {
  testNode(mdastNode) {
    return mdastNode.type === "emphasis" || mdastNode.type === "strong" || isJsxUnderlineNode(mdastNode) || isOpeningUnderlineNode(mdastNode) || isClosingUnderlineNode(mdastNode);
  },
  visitNode({ mdastNode, lexicalParent, actions, mdastParent }) {
    if (isOpeningUnderlineNode(mdastNode)) {
      actions.addFormatting(IS_UNDERLINE, mdastParent);
      return;
    }
    if (isClosingUnderlineNode(mdastNode)) {
      actions.removeFormatting(IS_UNDERLINE, mdastParent);
      return;
    }
    if (mdastNode.type === "emphasis") {
      actions.addFormatting(IS_ITALIC);
    } else if (mdastNode.type === "strong") {
      actions.addFormatting(IS_BOLD);
    } else if (isJsxUnderlineNode(mdastNode)) {
      actions.addFormatting(IS_UNDERLINE);
    }
    actions.visitChildren(mdastNode, lexicalParent);
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastInlineCodeVisitor.js
var import_lexical6 = __toESM(require_Lexical(), 1);
function isOpeningCodeNode(node) {
  return node.type === "html" && node.value === "<code>";
}
function isClosingCodeNode(node) {
  return node.type === "html" && node.value === "</code>";
}
var MdastInlineCodeVisitor = {
  testNode: (node) => {
    return node.type === "inlineCode" || isOpeningCodeNode(node) || isClosingCodeNode(node);
  },
  visitNode({ mdastNode, actions, mdastParent }) {
    if (isOpeningCodeNode(mdastNode)) {
      actions.addFormatting(IS_CODE, mdastParent);
      return;
    }
    if (isClosingCodeNode(mdastNode)) {
      actions.removeFormatting(IS_CODE, mdastParent);
      return;
    }
    actions.addAndStepInto((0, import_lexical6.$createTextNode)(mdastNode.value).setFormat(IS_CODE));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastParagraphVisitor.js
var import_lexical7 = __toESM(require_Lexical(), 1);
var lexicalTypesThatShouldSkipParagraphs = ["listitem", "quote", "admonition"];
var MdastParagraphVisitor = {
  testNode: "paragraph",
  visitNode: function({ mdastNode, lexicalParent, actions }) {
    if (lexicalTypesThatShouldSkipParagraphs.includes(lexicalParent.getType())) {
      actions.visitChildren(mdastNode, lexicalParent);
    } else {
      actions.addAndStepInto((0, import_lexical7.$createParagraphNode)());
    }
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastRootVisitor.js
var MdastRootVisitor = {
  testNode: "root",
  visitNode({ actions, mdastNode, lexicalParent }) {
    actions.visitChildren(mdastNode, lexicalParent);
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastTextVisitor.js
var import_lexical8 = __toESM(require_Lexical(), 1);
var MdastTextVisitor = {
  testNode: "text",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto((0, import_lexical8.$createTextNode)(mdastNode.value).setFormat(actions.getParentFormatting()));
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/SharedHistoryPlugin.js
var import_LexicalHistoryPlugin = __toESM(require_LexicalHistoryPlugin(), 1);
var import_react2 = __toESM(require_react(), 1);
var SharedHistoryPlugin = () => {
  const [historyState] = corePluginHooks.useEmitterValues("historyState");
  return import_react2.default.createElement(import_LexicalHistoryPlugin.HistoryPlugin, { externalHistoryState: historyState });
};

// node_modules/@mdxeditor/editor/dist/plugins/core/MdastBreakVisitor.js
var import_lexical9 = __toESM(require_Lexical(), 1);
var MdastBreakVisitor = {
  testNode: "break",
  visitNode: function({ lexicalParent }) {
    lexicalParent.append((0, import_lexical9.$createLineBreakNode)());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/core/index.js
var NESTED_EDITOR_UPDATED_COMMAND = (0, import_lexical10.createCommand)("NESTED_EDITOR_UPDATED_COMMAND");
var coreSystem = system((r) => {
  function createAppendNodeFor(node) {
    const appendNode = r.node();
    r.link(
      r.pipe(
        appendNode,
        r.o.withLatestFrom(node),
        r.o.map(([newValue, values]) => {
          if (values.includes(newValue)) {
            return values;
          }
          return [...values, newValue];
        })
      ),
      node
    );
    return appendNode;
  }
  const rootEditor = r.node(null);
  const activeEditor = r.node(null, true);
  const contentEditableClassName = r.node("");
  const readOnly = r.node(false);
  const placeholder = r.node("");
  const autoFocus = r.node(false);
  const inFocus = r.node(false, true);
  const currentFormat = r.node(0, true);
  const applyFormat = r.node();
  const currentSelection = r.node(null);
  const activeEditorSubscriptions = r.node([]);
  const rootEditorSubscriptions = r.node([]);
  const editorInFocus = r.node(null);
  const onBlur = r.node();
  const rebind = () => r.o.scan((teardowns, [subs, activeEditorValue]) => {
    teardowns.forEach((teardown) => {
      if (!teardown) {
        throw new Error("You have a subscription that does not return a teardown");
      }
      teardown();
    });
    return activeEditorValue ? subs.map((s) => s(activeEditorValue)) : [];
  }, []);
  r.pipe(r.combine(activeEditorSubscriptions, activeEditor), rebind());
  r.pipe(r.combine(rootEditorSubscriptions, rootEditor), rebind());
  const createRootEditorSubscription = createAppendNodeFor(rootEditorSubscriptions);
  const createActiveEditorSubscription = createAppendNodeFor(activeEditorSubscriptions);
  function handleSelectionChange() {
    const selection = (0, import_lexical10.$getSelection)();
    if ((0, import_lexical10.$isRangeSelection)(selection)) {
      r.pubKeys({
        currentSelection: selection,
        currentFormat: selection.format
      });
    }
  }
  r.pub(createRootEditorSubscription, (theRootEditor) => {
    return theRootEditor.registerCommand(
      import_lexical10.SELECTION_CHANGE_COMMAND,
      (_, theActiveEditor) => {
        r.pubIn({
          [activeEditor.key]: theActiveEditor,
          [inFocus.key]: true
        });
        if (theActiveEditor._parentEditor === null) {
          theActiveEditor.getEditorState().read(() => {
            r.pub(editorInFocus, {
              rootNode: (0, import_lexical10.$getRoot)(),
              editorType: "lexical"
            });
          });
        }
        handleSelectionChange();
        return false;
      },
      import_lexical10.COMMAND_PRIORITY_CRITICAL
    );
  });
  r.pub(createRootEditorSubscription, (theRootEditor) => {
    return theRootEditor.registerUpdateListener(({ dirtyElements, dirtyLeaves, editorState }) => {
      if (dirtyElements.size === 0 && dirtyLeaves.size === 0) {
        return;
      }
      let theNewMarkdownValue;
      editorState.read(() => {
        theNewMarkdownValue = exportMarkdownFromLexical({
          root: (0, import_lexical10.$getRoot)(),
          visitors: r.getValue(exportVisitors),
          jsxComponentDescriptors: r.getValue(jsxComponentDescriptors),
          toMarkdownExtensions: r.getValue(toMarkdownExtensions),
          toMarkdownOptions: r.getValue(toMarkdownOptions),
          jsxIsAvailable: r.getValue(jsxIsAvailable)
        });
      });
      r.pub(markdown, theNewMarkdownValue.trim());
    });
  });
  const initialMarkdown = r.node("");
  const markdown = r.node("", true);
  r.link(initialMarkdown, markdown);
  const importVisitors = r.node([]);
  const syntaxExtensions = r.node([]);
  const mdastExtensions = r.node([]);
  const usedLexicalNodes = r.node([]);
  const exportVisitors = r.node([]);
  const toMarkdownExtensions = r.node([]);
  const toMarkdownOptions = r.node({}, true);
  const jsxIsAvailable = r.node(false);
  const jsxComponentDescriptors = r.node([]);
  const editorRootElementRef = r.node(null);
  const addLexicalNode = createAppendNodeFor(usedLexicalNodes);
  const addImportVisitor = createAppendNodeFor(importVisitors);
  const addSyntaxExtension = createAppendNodeFor(syntaxExtensions);
  const addMdastExtension = createAppendNodeFor(mdastExtensions);
  const addExportVisitor = createAppendNodeFor(exportVisitors);
  const addToMarkdownExtension = createAppendNodeFor(toMarkdownExtensions);
  const setMarkdown = r.node();
  r.sub(
    r.pipe(setMarkdown, r.o.withLatestFrom(rootEditor, importVisitors, mdastExtensions, syntaxExtensions, inFocus)),
    ([theNewMarkdownValue, editor, importVisitors2, mdastExtensions2, syntaxExtensions2, inFocus2]) => {
      editor == null ? void 0 : editor.update(() => {
        (0, import_lexical10.$getRoot)().clear();
        importMarkdownToLexical({
          root: (0, import_lexical10.$getRoot)(),
          visitors: importVisitors2,
          mdastExtensions: mdastExtensions2,
          markdown: theNewMarkdownValue,
          syntaxExtensions: syntaxExtensions2
        });
        if (!inFocus2) {
          (0, import_lexical10.$setSelection)(null);
        }
      });
    }
  );
  const initialRootEditorState = r.node((theRootEditor) => {
    r.pub(rootEditor, theRootEditor);
    r.pub(activeEditor, theRootEditor);
    importMarkdownToLexical({
      root: (0, import_lexical10.$getRoot)(),
      visitors: r.getValue(importVisitors),
      mdastExtensions: r.getValue(mdastExtensions),
      markdown: r.getValue(initialMarkdown),
      syntaxExtensions: r.getValue(syntaxExtensions)
    });
    const autoFocusValue = r.getValue(autoFocus);
    if (autoFocusValue) {
      if (autoFocusValue === true) {
        setTimeout(() => theRootEditor.focus(noop, { defaultSelection: "rootStart" }));
        return;
      }
      setTimeout(
        () => theRootEditor.focus(noop, {
          defaultSelection: autoFocusValue.defaultSelection ?? "rootStart"
        })
      );
    }
  });
  r.pub(createActiveEditorSubscription, (editor) => {
    return editor.registerUpdateListener(({ editorState }) => {
      editorState.read(() => {
        handleSelectionChange();
      });
    });
  });
  r.pub(createActiveEditorSubscription, (theEditor) => {
    return theEditor.registerCommand(
      import_lexical10.BLUR_COMMAND,
      (payload) => {
        var _a;
        const theRootEditor = r.getValue(rootEditor);
        if (theRootEditor) {
          const movingOutside = !((_a = theRootEditor.getRootElement()) == null ? void 0 : _a.contains(payload.relatedTarget));
          if (movingOutside) {
            r.pubIn({
              [inFocus.key]: false,
              [onBlur.key]: payload
            });
          }
        }
        return false;
      },
      import_lexical10.COMMAND_PRIORITY_CRITICAL
    );
  });
  r.pub(createRootEditorSubscription, (theRootEditor) => {
    return theRootEditor.registerCommand(
      import_lexical10.KEY_DOWN_COMMAND,
      (event) => {
        const { keyCode, ctrlKey, metaKey } = event;
        if (keyCode === 65 && controlOrMeta(metaKey, ctrlKey)) {
          let shouldOverride = false;
          theRootEditor.getEditorState().read(() => {
            shouldOverride = (0, import_lexical10.$isDecoratorNode)((0, import_lexical10.$getRoot)().getFirstChild()) || (0, import_lexical10.$isDecoratorNode)((0, import_lexical10.$getRoot)().getLastChild());
          });
          if (shouldOverride) {
            event.preventDefault();
            event.stopImmediatePropagation();
            theRootEditor.update(() => {
              var _a;
              const rootElement = theRootEditor.getRootElement();
              (_a = window.getSelection()) == null ? void 0 : _a.selectAllChildren(rootElement);
              rootElement.focus({
                preventScroll: true
              });
            });
            return true;
          }
        }
        return false;
      },
      import_lexical10.COMMAND_PRIORITY_CRITICAL
    );
  });
  const composerChildren = r.node([]);
  const addComposerChild = createAppendNodeFor(composerChildren);
  const topAreaChildren = r.node([]);
  const addTopAreaChild = createAppendNodeFor(topAreaChildren);
  const editorWrappers = r.node([]);
  const addEditorWrapper = createAppendNodeFor(editorWrappers);
  const nestedEditorChildren = r.node([]);
  const addNestedEditorChild = createAppendNodeFor(nestedEditorChildren);
  const historyState = r.node((0, import_LexicalHistoryPlugin2.createEmptyHistoryState)());
  r.sub(r.pipe(applyFormat, r.o.withLatestFrom(activeEditor)), ([format, theEditor]) => {
    theEditor == null ? void 0 : theEditor.dispatchCommand(import_lexical10.FORMAT_TEXT_COMMAND, format);
  });
  const currentBlockType = r.node("");
  const applyBlockType = r.node();
  r.sub(r.pipe(currentSelection, r.o.withLatestFrom(activeEditor)), ([selection, theEditor]) => {
    if (!selection || !theEditor) {
      return;
    }
    const anchorNode = selection.anchor.getNode();
    let element = anchorNode.getKey() === "root" ? anchorNode : (0, import_utils.$findMatchingParent)(anchorNode, (e) => {
      const parent = e.getParent();
      return parent !== null && (0, import_lexical10.$isRootOrShadowRoot)(parent);
    });
    if (element === null) {
      element = anchorNode.getTopLevelElementOrThrow();
    }
    const elementKey = element.getKey();
    const elementDOM = theEditor.getElementByKey(elementKey);
    if (elementDOM !== null) {
      const blockType = (0, import_rich_text.$isHeadingNode)(element) ? element.getTag() : element.getType();
      r.pub(currentBlockType, blockType);
    }
  });
  const convertSelectionToNode = r.node();
  r.sub(r.pipe(convertSelectionToNode, r.o.withLatestFrom(activeEditor)), ([factory, editor]) => {
    editor == null ? void 0 : editor.update(() => {
      const selection = (0, import_lexical10.$getSelection)();
      if ((0, import_lexical10.$isRangeSelection)(selection)) {
        (0, import_selection.$setBlocksType)(selection, factory);
        setTimeout(() => {
          editor.focus();
        });
      }
    });
  });
  const insertDecoratorNode = r.node();
  r.sub(r.pipe(insertDecoratorNode, r.o.withLatestFrom(activeEditor)), ([nodeFactory, theEditor]) => {
    theEditor == null ? void 0 : theEditor.focus(
      () => {
        theEditor.getEditorState().read(() => {
          const selection = (0, import_lexical10.$getSelection)();
          if ((0, import_lexical10.$isRangeSelection)(selection)) {
            const focusNode = selection.focus.getNode();
            if (focusNode !== null) {
              theEditor.update(() => {
                const node = nodeFactory();
                if (node.isInline()) {
                  (0, import_lexical10.$insertNodes)([node]);
                  if ((0, import_lexical10.$isRootOrShadowRoot)(node.getParentOrThrow())) {
                    (0, import_utils.$wrapNodeInElement)(node, import_lexical10.$createParagraphNode).selectEnd();
                  }
                } else {
                  (0, import_utils.$insertNodeToNearestRoot)(node);
                }
                if (Object.hasOwn(node, "select") && typeof node.select === "function") {
                  setTimeout(() => node.select());
                }
              });
            }
          }
        });
      },
      { defaultSelection: "rootEnd" }
    );
  });
  r.sub(r.pipe(readOnly, r.o.withLatestFrom(rootEditor)), ([readOnly2, theRootEditor]) => {
    theRootEditor == null ? void 0 : theRootEditor.setEditable(!readOnly2);
  });
  return {
    // state
    activeEditor,
    inFocus,
    historyState,
    currentSelection,
    // jsx
    jsxIsAvailable,
    jsxComponentDescriptors,
    // lexical editor
    initialRootEditorState,
    rootEditor,
    createRootEditorSubscription,
    createActiveEditorSubscription,
    // import
    importVisitors,
    syntaxExtensions,
    mdastExtensions,
    usedLexicalNodes,
    addImportVisitor,
    addLexicalNode,
    addSyntaxExtension,
    addMdastExtension,
    // export
    toMarkdownExtensions,
    toMarkdownOptions,
    addToMarkdownExtension,
    addExportVisitor,
    exportVisitors,
    // markdown strings
    initialMarkdown,
    setMarkdown,
    markdown,
    // DOM
    editorRootElementRef,
    contentEditableClassName,
    placeholder,
    autoFocus,
    readOnly,
    // child controls
    composerChildren,
    addComposerChild,
    topAreaChildren,
    addTopAreaChild,
    nestedEditorChildren,
    addNestedEditorChild,
    editorWrappers,
    addEditorWrapper,
    // editor content state and commands
    currentFormat,
    editorInFocus,
    applyFormat,
    currentBlockType,
    applyBlockType,
    convertSelectionToNode,
    insertDecoratorNode,
    // Events
    onBlur
  };
}, []);
var [
  /** @internal */
  corePlugin,
  /** @internal */
  corePluginHooks
] = realmPlugin({
  id: "core",
  systemSpec: coreSystem,
  applyParamsToSystem(realm2, params) {
    realm2.pubKeys({
      contentEditableClassName: params.contentEditableClassName,
      toMarkdownOptions: params.toMarkdownOptions,
      autoFocus: params.autoFocus,
      placeholder: params.placeholder,
      readOnly: params.readOnly
    });
    realm2.singletonSubKey("markdown", params.onChange);
    realm2.singletonSubKey("onBlur", params.onBlur);
  },
  init(realm2, params) {
    realm2.pubKey("initialMarkdown", params.initialMarkdown.trim());
    realm2.pubKey("addImportVisitor", MdastRootVisitor);
    realm2.pubKey("addImportVisitor", MdastParagraphVisitor);
    realm2.pubKey("addImportVisitor", MdastTextVisitor);
    realm2.pubKey("addImportVisitor", MdastFormattingVisitor);
    realm2.pubKey("addImportVisitor", MdastInlineCodeVisitor);
    realm2.pubKey("addImportVisitor", MdastBreakVisitor);
    realm2.pubKey("addLexicalNode", import_lexical10.ParagraphNode);
    realm2.pubKey("addLexicalNode", import_lexical10.TextNode);
    realm2.pubKey("addExportVisitor", LexicalRootVisitor);
    realm2.pubKey("addExportVisitor", LexicalParagraphVisitor);
    realm2.pubKey("addExportVisitor", LexicalTextVisitor);
    realm2.pubKey("addExportVisitor", LexicalLinebreakVisitor);
    realm2.pubKey("addComposerChild", SharedHistoryPlugin);
  }
});

export {
  require_LexicalComposerContext,
  require_Lexical,
  require_LexicalSelection,
  require_LexicalUtils,
  require_LexicalRichText,
  IS_BOLD,
  IS_ITALIC,
  IS_UNDERLINE,
  noop,
  IS_APPLE,
  controlOrMeta,
  system,
  realmPlugin,
  RealmPluginInitializer,
  useHasPlugin,
  coreSystem,
  corePlugin,
  corePluginHooks
};
//# sourceMappingURL=chunk-I3I4FGWZ.js.map
