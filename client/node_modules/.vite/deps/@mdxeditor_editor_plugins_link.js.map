{
  "version": 3,
  "sources": ["../../@lexical/react/LexicalLinkPlugin.dev.js", "../../@lexical/react/LexicalLinkPlugin.js", "../../@lexical/react/LexicalAutoLinkPlugin.dev.js", "../../@lexical/react/LexicalAutoLinkPlugin.js", "../../@mdxeditor/editor/dist/plugins/link/index.js", "../../@mdxeditor/editor/dist/plugins/link/MdastLinkVisitor.js", "../../@mdxeditor/editor/dist/plugins/link/LexicalLinkVisitor.js", "../../@mdxeditor/editor/dist/plugins/link/AutoLinkPlugin.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction LinkPlugin({\n  validateUrl\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.LinkNode])) {\n      throw new Error('LinkPlugin: LinkNode not registered on editor');\n    }\n\n    return utils.mergeRegister(editor.registerCommand(link.TOGGLE_LINK_COMMAND, payload => {\n      if (payload === null) {\n        link.toggleLink(payload);\n        return true;\n      } else if (typeof payload === 'string') {\n        if (validateUrl === undefined || validateUrl(payload)) {\n          link.toggleLink(payload);\n          return true;\n        }\n\n        return false;\n      } else {\n        const {\n          url,\n          target,\n          rel,\n          title\n        } = payload;\n        link.toggleLink(url, {\n          rel,\n          target,\n          title\n        });\n        return true;\n      }\n    }, lexical.COMMAND_PRIORITY_LOW), validateUrl !== undefined ? editor.registerCommand(lexical.PASTE_COMMAND, event => {\n      const selection = lexical.$getSelection();\n\n      if (!lexical.$isRangeSelection(selection) || selection.isCollapsed() || !(event instanceof ClipboardEvent) || event.clipboardData == null) {\n        return false;\n      }\n\n      const clipboardText = event.clipboardData.getData('text');\n\n      if (!validateUrl(clipboardText)) {\n        return false;\n      } // If we select nodes that are elements then avoid applying the link.\n\n\n      if (!selection.getNodes().some(node => lexical.$isElementNode(node))) {\n        editor.dispatchCommand(link.TOGGLE_LINK_COMMAND, clipboardText);\n        event.preventDefault();\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW) : () => {// Don't paste arbritrary text as a link when there's no validate function\n    });\n  }, [editor, validateUrl]);\n  return null;\n}\n\nexports.LinkPlugin = LinkPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalLinkPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalLinkPlugin.dev.js') : require('./LexicalLinkPlugin.prod.js')\nmodule.exports = LexicalLinkPlugin;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar link = require('@lexical/link');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction createLinkMatcherWithRegExp(regExp, urlTransformer = text => text) {\n  return text => {\n    const match = regExp.exec(text);\n    if (match === null) return null;\n    return {\n      index: match.index,\n      length: match[0].length,\n      text: match[0],\n      url: urlTransformer(text)\n    };\n  };\n}\n\nfunction findFirstMatch(text, matchers) {\n  for (let i = 0; i < matchers.length; i++) {\n    const match = matchers[i](text);\n\n    if (match) {\n      return match;\n    }\n  }\n\n  return null;\n}\n\nconst PUNCTUATION_OR_SPACE = /[.,;\\s]/;\n\nfunction isSeparator(char) {\n  return PUNCTUATION_OR_SPACE.test(char);\n}\n\nfunction endsWithSeparator(textContent) {\n  return isSeparator(textContent[textContent.length - 1]);\n}\n\nfunction startsWithSeparator(textContent) {\n  return isSeparator(textContent[0]);\n}\n\nfunction isPreviousNodeValid(node) {\n  let previousNode = node.getPreviousSibling();\n\n  if (lexical.$isElementNode(previousNode)) {\n    previousNode = previousNode.getLastDescendant();\n  }\n\n  return previousNode === null || lexical.$isLineBreakNode(previousNode) || lexical.$isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());\n}\n\nfunction isNextNodeValid(node) {\n  let nextNode = node.getNextSibling();\n\n  if (lexical.$isElementNode(nextNode)) {\n    nextNode = nextNode.getFirstDescendant();\n  }\n\n  return nextNode === null || lexical.$isLineBreakNode(nextNode) || lexical.$isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());\n}\n\nfunction isContentAroundIsValid(matchStart, matchEnd, text, node) {\n  const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(node);\n\n  if (!contentBeforeIsValid) {\n    return false;\n  }\n\n  const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(node);\n  return contentAfterIsValid;\n}\n\nfunction handleLinkCreation(node, matchers, onChange) {\n  const nodeText = node.getTextContent();\n  let text = nodeText;\n  let invalidMatchEnd = 0;\n  let remainingTextNode = node;\n  let match;\n\n  while ((match = findFirstMatch(text, matchers)) && match !== null) {\n    const matchStart = match.index;\n    const matchLength = match.length;\n    const matchEnd = matchStart + matchLength;\n    const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, nodeText, node);\n\n    if (isValid) {\n      let linkTextNode;\n\n      if (invalidMatchEnd + matchStart === 0) {\n        [linkTextNode, remainingTextNode] = remainingTextNode.splitText(invalidMatchEnd + matchLength);\n      } else {\n        [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(invalidMatchEnd + matchStart, invalidMatchEnd + matchStart + matchLength);\n      }\n\n      const linkNode = link.$createAutoLinkNode(match.url, match.attributes);\n      const textNode = lexical.$createTextNode(match.text);\n      textNode.setFormat(linkTextNode.getFormat());\n      textNode.setDetail(linkTextNode.getDetail());\n      linkNode.append(textNode);\n      linkTextNode.replace(linkNode);\n      onChange(match.url, null);\n      invalidMatchEnd = 0;\n    } else {\n      invalidMatchEnd += matchEnd;\n    }\n\n    text = text.substring(matchEnd);\n  }\n}\n\nfunction handleLinkEdit(linkNode, matchers, onChange) {\n  // Check children are simple text\n  const children = linkNode.getChildren();\n  const childrenLength = children.length;\n\n  for (let i = 0; i < childrenLength; i++) {\n    const child = children[i];\n\n    if (!lexical.$isTextNode(child) || !child.isSimpleText()) {\n      replaceWithChildren(linkNode);\n      onChange(null, linkNode.getURL());\n      return;\n    }\n  } // Check text content fully matches\n\n\n  const text = linkNode.getTextContent();\n  const match = findFirstMatch(text, matchers);\n\n  if (match === null || match.text !== text) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  } // Check neighbors\n\n\n  if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {\n    replaceWithChildren(linkNode);\n    onChange(null, linkNode.getURL());\n    return;\n  }\n\n  const url = linkNode.getURL();\n\n  if (url !== match.url) {\n    linkNode.setURL(match.url);\n    onChange(match.url, url);\n  }\n\n  if (match.attributes) {\n    const rel = linkNode.getRel();\n\n    if (rel !== match.attributes.rel) {\n      linkNode.setRel(match.attributes.rel || null);\n      onChange(match.attributes.rel || null, rel);\n    }\n\n    const target = linkNode.getTarget();\n\n    if (target !== match.attributes.target) {\n      linkNode.setTarget(match.attributes.target || null);\n      onChange(match.attributes.target || null, target);\n    }\n  }\n} // Bad neighbours are edits in neighbor nodes that make AutoLinks incompatible.\n// Given the creation preconditions, these can only be simple text nodes.\n\n\nfunction handleBadNeighbors(textNode, matchers, onChange) {\n  const previousSibling = textNode.getPreviousSibling();\n  const nextSibling = textNode.getNextSibling();\n  const text = textNode.getTextContent();\n\n  if (link.$isAutoLinkNode(previousSibling) && !startsWithSeparator(text)) {\n    previousSibling.append(textNode);\n    handleLinkEdit(previousSibling, matchers, onChange);\n    onChange(null, previousSibling.getURL());\n  }\n\n  if (link.$isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {\n    replaceWithChildren(nextSibling);\n    handleLinkEdit(nextSibling, matchers, onChange);\n    onChange(null, nextSibling.getURL());\n  }\n}\n\nfunction replaceWithChildren(node) {\n  const children = node.getChildren();\n  const childrenLength = children.length;\n\n  for (let j = childrenLength - 1; j >= 0; j--) {\n    node.insertAfter(children[j]);\n  }\n\n  node.remove();\n  return children.map(child => child.getLatest());\n}\n\nfunction useAutoLink(editor, matchers, onChange) {\n  react.useEffect(() => {\n    if (!editor.hasNodes([link.AutoLinkNode])) {\n      {\n        throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);\n      }\n    }\n\n    const onChangeWrapped = (url, prevUrl) => {\n      if (onChange) {\n        onChange(url, prevUrl);\n      }\n    };\n\n    return utils.mergeRegister(editor.registerNodeTransform(lexical.TextNode, textNode => {\n      const parent = textNode.getParentOrThrow();\n      const previous = textNode.getPreviousSibling();\n\n      if (link.$isAutoLinkNode(parent)) {\n        handleLinkEdit(parent, matchers, onChangeWrapped);\n      } else if (!link.$isLinkNode(parent)) {\n        if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !link.$isAutoLinkNode(previous))) {\n          handleLinkCreation(textNode, matchers, onChangeWrapped);\n        }\n\n        handleBadNeighbors(textNode, matchers, onChangeWrapped);\n      }\n    }));\n  }, [editor, matchers, onChange]);\n}\n\nfunction AutoLinkPlugin({\n  matchers,\n  onChange\n}) {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  useAutoLink(editor, matchers, onChange);\n  return null;\n}\n\nexports.AutoLinkPlugin = AutoLinkPlugin;\nexports.createLinkMatcherWithRegExp = createLinkMatcherWithRegExp;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalAutoLinkPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalAutoLinkPlugin.dev.js') : require('./LexicalAutoLinkPlugin.prod.js')\nmodule.exports = LexicalAutoLinkPlugin;", "import React__default from \"react\";\nimport { coreSystem } from \"../core/index.js\";\nimport { MdastLinkVisitor } from \"./MdastLinkVisitor.js\";\nimport { LexicalLinkVisitor } from \"./LexicalLinkVisitor.js\";\nimport { LinkNode, AutoLinkNode } from \"@lexical/link\";\nimport { LinkPlugin } from \"@lexical/react/LexicalLinkPlugin.js\";\nimport { LexicalAutoLinkPlugin } from \"./AutoLinkPlugin.js\";\nimport { system } from \"../../gurx/realmFactory.js\";\nimport { realmPlugin } from \"../../gurx/react.js\";\nconst linkSystem = system(\n  (r) => {\n    const disableAutoLink = r.node(false);\n    return { disableAutoLink };\n  },\n  [coreSystem]\n);\nconst [linkPlugin] = realmPlugin({\n  id: \"link\",\n  systemSpec: linkSystem,\n  init: (realm, params) => {\n    const disableAutoLink = Boolean(params == null ? void 0 : params.disableAutoLink);\n    realm.pubKey(\"addImportVisitor\", MdastLinkVisitor);\n    realm.pubKey(\"addLexicalNode\", LinkNode);\n    realm.pubKey(\"addLexicalNode\", AutoLinkNode);\n    realm.pubKey(\"addExportVisitor\", LexicalLinkVisitor);\n    realm.pubKey(\"disableAutoLink\", disableAutoLink);\n    const linkPluginProps = (params == null ? void 0 : params.validateUrl) ? { validateUrl: params.validateUrl } : {};\n    realm.pubKey(\"addComposerChild\", () => /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement(LinkPlugin, { ...linkPluginProps }), disableAutoLink ? null : /* @__PURE__ */ React__default.createElement(LexicalAutoLinkPlugin, null)));\n  }\n});\nexport {\n  linkPlugin\n};\n", "import { $createLinkNode } from \"@lexical/link\";\nconst MdastLinkVisitor = {\n  testNode: \"link\",\n  visitNode({ mdastNode, actions }) {\n    actions.addAndStepInto(\n      $createLinkNode(mdastNode.url, {\n        title: mdastNode.title\n      })\n    );\n  }\n};\nexport {\n  MdastLinkVisitor\n};\n", "import { $isLinkNode } from \"@lexical/link\";\nconst LexicalLinkVisitor = {\n  testLexicalNode: $isLinkNode,\n  visitLexicalNode: ({ lexicalNode, actions }) => {\n    actions.addAndStepInto(\"link\", { url: lexicalNode.getURL(), title: lexicalNode.getTitle() });\n  }\n};\nexport {\n  LexicalLinkVisitor\n};\n", "import { createLinkMatcherWithRegExp, AutoLinkPlugin } from \"@lexical/react/LexicalAutoLinkPlugin.js\";\nimport React__default from \"react\";\nconst URL_REGEX = /((https?:\\/\\/(www\\.)?)|(www\\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\\.[a-zA-Z0-9()]{1,6}\\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/;\nconst EMAIL_REGEX = /(([^<>()[\\]\\\\.,;:\\s@\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\"]+)*)|(\".+\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))/;\nconst MATCHERS = [\n  createLinkMatcherWithRegExp(URL_REGEX, (text) => {\n    return text.startsWith(\"http\") ? text : `https://${text}`;\n  }),\n  createLinkMatcherWithRegExp(EMAIL_REGEX, (text) => {\n    return `mailto:${text}`;\n  })\n];\nconst LexicalAutoLinkPlugin = () => {\n  return /* @__PURE__ */ React__default.createElement(AutoLinkPlugin, { matchers: MATCHERS });\n};\nexport {\n  LexicalAutoLinkPlugin\n};\n"],
  "mappings": "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",
  "names": ["LinkPlugin", "createLinkMatcherWithRegExp", "AutoLinkPlugin", "LexicalAutoLinkPlugin", "import_react", "import_link", "import_link", "React__default", "React__default"]
}
