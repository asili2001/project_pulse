import {
  coreSystem,
  realmPlugin,
  require_Lexical,
  require_LexicalComposerContext,
  require_LexicalUtils,
  system
} from "./chunk-I3I4FGWZ.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/@lexical/react/useLexicalNodeSelection.dev.js
var require_useLexicalNodeSelection_dev = __commonJS({
  "node_modules/@lexical/react/useLexicalNodeSelection.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var lexical = require_Lexical();
    var react = require_react();
    function isNodeSelected(editor, key) {
      return editor.getEditorState().read(() => {
        const node = lexical.$getNodeByKey(key);
        if (node === null) {
          return false;
        }
        return node.isSelected();
      });
    }
    function useLexicalNodeSelection(key) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isSelected, setIsSelected] = react.useState(() => isNodeSelected(editor, key));
      react.useEffect(() => {
        let isMounted = true;
        const unregister = editor.registerUpdateListener(() => {
          if (isMounted) {
            setIsSelected(isNodeSelected(editor, key));
          }
        });
        return () => {
          isMounted = false;
          unregister();
        };
      }, [editor, key]);
      const setSelected = react.useCallback((selected) => {
        editor.update(() => {
          let selection = lexical.$getSelection();
          if (!lexical.$isNodeSelection(selection)) {
            selection = lexical.$createNodeSelection();
            lexical.$setSelection(selection);
          }
          if (selected) {
            selection.add(key);
          } else {
            selection.delete(key);
          }
        });
      }, [editor, key]);
      const clearSelected = react.useCallback(() => {
        editor.update(() => {
          const selection = lexical.$getSelection();
          if (lexical.$isNodeSelection(selection)) {
            selection.clear();
          }
        });
      }, [editor]);
      return [isSelected, setSelected, clearSelected];
    }
    exports.useLexicalNodeSelection = useLexicalNodeSelection;
  }
});

// node_modules/@lexical/react/useLexicalNodeSelection.js
var require_useLexicalNodeSelection = __commonJS({
  "node_modules/@lexical/react/useLexicalNodeSelection.js"(exports, module) {
    "use strict";
    var useLexicalNodeSelection = true ? require_useLexicalNodeSelection_dev() : null;
    module.exports = useLexicalNodeSelection;
  }
});

// node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js
var require_LexicalHorizontalRuleNode_dev = __commonJS({
  "node_modules/@lexical/react/LexicalHorizontalRuleNode.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var useLexicalNodeSelection = require_useLexicalNodeSelection();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var React = require_react();
    var INSERT_HORIZONTAL_RULE_COMMAND2 = lexical.createCommand("INSERT_HORIZONTAL_RULE_COMMAND");
    function HorizontalRuleComponent({
      nodeKey
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      const [isSelected, setSelected, clearSelection] = useLexicalNodeSelection.useLexicalNodeSelection(nodeKey);
      const onDelete = React.useCallback((event) => {
        if (isSelected && lexical.$isNodeSelection(lexical.$getSelection())) {
          event.preventDefault();
          const node = lexical.$getNodeByKey(nodeKey);
          if ($isHorizontalRuleNode2(node)) {
            node.remove();
          }
        }
        return false;
      }, [isSelected, nodeKey]);
      React.useEffect(() => {
        return utils.mergeRegister(editor.registerCommand(lexical.CLICK_COMMAND, (event) => {
          const hrElem = editor.getElementByKey(nodeKey);
          if (event.target === hrElem) {
            if (!event.shiftKey) {
              clearSelection();
            }
            setSelected(!isSelected);
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_DELETE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.KEY_BACKSPACE_COMMAND, onDelete, lexical.COMMAND_PRIORITY_LOW));
      }, [clearSelection, editor, isSelected, nodeKey, onDelete, setSelected]);
      React.useEffect(() => {
        const hrElem = editor.getElementByKey(nodeKey);
        if (hrElem !== null) {
          hrElem.className = isSelected ? "selected" : "";
        }
      }, [editor, isSelected, nodeKey]);
      return null;
    }
    var HorizontalRuleNode2 = class _HorizontalRuleNode extends lexical.DecoratorNode {
      static getType() {
        return "horizontalrule";
      }
      static clone(node) {
        return new _HorizontalRuleNode(node.__key);
      }
      static importJSON(serializedNode) {
        return $createHorizontalRuleNode2();
      }
      static importDOM() {
        return {
          hr: () => ({
            conversion: convertHorizontalRuleElement,
            priority: 0
          })
        };
      }
      exportJSON() {
        return {
          type: "horizontalrule",
          version: 1
        };
      }
      exportDOM() {
        return {
          element: document.createElement("hr")
        };
      }
      createDOM() {
        return document.createElement("hr");
      }
      getTextContent() {
        return "\n";
      }
      isInline() {
        return false;
      }
      updateDOM() {
        return false;
      }
      decorate() {
        return React.createElement(HorizontalRuleComponent, {
          nodeKey: this.__key
        });
      }
    };
    function convertHorizontalRuleElement() {
      return {
        node: $createHorizontalRuleNode2()
      };
    }
    function $createHorizontalRuleNode2() {
      return lexical.$applyNodeReplacement(new HorizontalRuleNode2());
    }
    function $isHorizontalRuleNode2(node) {
      return node instanceof HorizontalRuleNode2;
    }
    exports.$createHorizontalRuleNode = $createHorizontalRuleNode2;
    exports.$isHorizontalRuleNode = $isHorizontalRuleNode2;
    exports.HorizontalRuleNode = HorizontalRuleNode2;
    exports.INSERT_HORIZONTAL_RULE_COMMAND = INSERT_HORIZONTAL_RULE_COMMAND2;
  }
});

// node_modules/@lexical/react/LexicalHorizontalRuleNode.js
var require_LexicalHorizontalRuleNode = __commonJS({
  "node_modules/@lexical/react/LexicalHorizontalRuleNode.js"(exports, module) {
    "use strict";
    var LexicalHorizontalRuleNode = true ? require_LexicalHorizontalRuleNode_dev() : null;
    module.exports = LexicalHorizontalRuleNode;
  }
});

// node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.js
var require_LexicalHorizontalRulePlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalHorizontalRulePlugin.dev.js"(exports) {
    "use strict";
    var LexicalComposerContext = require_LexicalComposerContext();
    var LexicalHorizontalRuleNode = require_LexicalHorizontalRuleNode();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var react = require_react();
    function HorizontalRulePlugin2() {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        return editor.registerCommand(LexicalHorizontalRuleNode.INSERT_HORIZONTAL_RULE_COMMAND, (type) => {
          const selection = lexical.$getSelection();
          if (!lexical.$isRangeSelection(selection)) {
            return false;
          }
          const focusNode = selection.focus.getNode();
          if (focusNode !== null) {
            const horizontalRuleNode = LexicalHorizontalRuleNode.$createHorizontalRuleNode();
            utils.$insertNodeToNearestRoot(horizontalRuleNode);
          }
          return true;
        }, lexical.COMMAND_PRIORITY_EDITOR);
      }, [editor]);
      return null;
    }
    exports.HorizontalRulePlugin = HorizontalRulePlugin2;
  }
});

// node_modules/@lexical/react/LexicalHorizontalRulePlugin.js
var require_LexicalHorizontalRulePlugin = __commonJS({
  "node_modules/@lexical/react/LexicalHorizontalRulePlugin.js"(exports, module) {
    "use strict";
    var LexicalHorizontalRulePlugin = true ? require_LexicalHorizontalRulePlugin_dev() : null;
    module.exports = LexicalHorizontalRulePlugin;
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/thematic-break/MdastThematicBreakVisitor.js
var import_LexicalHorizontalRuleNode = __toESM(require_LexicalHorizontalRuleNode(), 1);
var MdastThematicBreakVisitor = {
  testNode: "thematicBreak",
  visitNode({ actions }) {
    actions.addAndStepInto((0, import_LexicalHorizontalRuleNode.$createHorizontalRuleNode)());
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/thematic-break/LexicalThematicBreakVisitor.js
var import_LexicalHorizontalRuleNode2 = __toESM(require_LexicalHorizontalRuleNode(), 1);
var LexicalThematicBreakVisitor = {
  testLexicalNode: import_LexicalHorizontalRuleNode2.$isHorizontalRuleNode,
  visitLexicalNode({ actions }) {
    actions.addAndStepInto("thematicBreak");
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/thematic-break/index.js
var import_LexicalHorizontalRuleNode3 = __toESM(require_LexicalHorizontalRuleNode());
var import_LexicalHorizontalRulePlugin = __toESM(require_LexicalHorizontalRulePlugin());
var thematicBreakSystem = system(
  (r, [{ activeEditor }]) => {
    const insertThematicBreak = r.node();
    r.sub(r.pipe(insertThematicBreak, r.o.withLatestFrom(activeEditor)), ([, theEditor]) => {
      theEditor == null ? void 0 : theEditor.dispatchCommand(import_LexicalHorizontalRuleNode3.INSERT_HORIZONTAL_RULE_COMMAND, void 0);
    });
    return {
      insertThematicBreak
    };
  },
  [coreSystem]
);
var [
  /** @internal */
  thematicBreakPlugin,
  /** @internal */
  thematicBreakPluginHooks
] = realmPlugin({
  id: "thematic-break",
  systemSpec: thematicBreakSystem,
  init: (realm) => {
    realm.pubKey("addImportVisitor", MdastThematicBreakVisitor);
    realm.pubKey("addLexicalNode", import_LexicalHorizontalRuleNode3.HorizontalRuleNode);
    realm.pubKey("addExportVisitor", LexicalThematicBreakVisitor);
    realm.pubKey("addComposerChild", import_LexicalHorizontalRulePlugin.HorizontalRulePlugin);
  }
});

export {
  thematicBreakSystem,
  thematicBreakPlugin,
  thematicBreakPluginHooks
};
//# sourceMappingURL=chunk-WPATRBAO.js.map
