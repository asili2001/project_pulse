import {
  require_LexicalLink
} from "./chunk-TQPCPFY2.js";
import {
  coreSystem,
  realmPlugin,
  require_Lexical,
  require_LexicalComposerContext,
  require_LexicalUtils,
  system
} from "./chunk-I3I4FGWZ.js";
import "./chunk-4YQ2LHX3.js";
import {
  require_react
} from "./chunk-RDZYK52F.js";
import {
  __commonJS,
  __toESM
} from "./chunk-5WWUZCGV.js";

// node_modules/@lexical/react/LexicalLinkPlugin.dev.js
var require_LexicalLinkPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalLinkPlugin.dev.js"(exports) {
    "use strict";
    var link = require_LexicalLink();
    var LexicalComposerContext = require_LexicalComposerContext();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var react = require_react();
    function LinkPlugin2({
      validateUrl
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      react.useEffect(() => {
        if (!editor.hasNodes([link.LinkNode])) {
          throw new Error("LinkPlugin: LinkNode not registered on editor");
        }
        return utils.mergeRegister(editor.registerCommand(link.TOGGLE_LINK_COMMAND, (payload) => {
          if (payload === null) {
            link.toggleLink(payload);
            return true;
          } else if (typeof payload === "string") {
            if (validateUrl === void 0 || validateUrl(payload)) {
              link.toggleLink(payload);
              return true;
            }
            return false;
          } else {
            const {
              url,
              target,
              rel,
              title
            } = payload;
            link.toggleLink(url, {
              rel,
              target,
              title
            });
            return true;
          }
        }, lexical.COMMAND_PRIORITY_LOW), validateUrl !== void 0 ? editor.registerCommand(lexical.PASTE_COMMAND, (event) => {
          const selection = lexical.$getSelection();
          if (!lexical.$isRangeSelection(selection) || selection.isCollapsed() || !(event instanceof ClipboardEvent) || event.clipboardData == null) {
            return false;
          }
          const clipboardText = event.clipboardData.getData("text");
          if (!validateUrl(clipboardText)) {
            return false;
          }
          if (!selection.getNodes().some((node) => lexical.$isElementNode(node))) {
            editor.dispatchCommand(link.TOGGLE_LINK_COMMAND, clipboardText);
            event.preventDefault();
            return true;
          }
          return false;
        }, lexical.COMMAND_PRIORITY_LOW) : () => {
        });
      }, [editor, validateUrl]);
      return null;
    }
    exports.LinkPlugin = LinkPlugin2;
  }
});

// node_modules/@lexical/react/LexicalLinkPlugin.js
var require_LexicalLinkPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalLinkPlugin.js"(exports, module) {
    "use strict";
    var LexicalLinkPlugin = true ? require_LexicalLinkPlugin_dev() : null;
    module.exports = LexicalLinkPlugin;
  }
});

// node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.js
var require_LexicalAutoLinkPlugin_dev = __commonJS({
  "node_modules/@lexical/react/LexicalAutoLinkPlugin.dev.js"(exports) {
    "use strict";
    var link = require_LexicalLink();
    var LexicalComposerContext = require_LexicalComposerContext();
    var utils = require_LexicalUtils();
    var lexical = require_Lexical();
    var react = require_react();
    function createLinkMatcherWithRegExp2(regExp, urlTransformer = (text) => text) {
      return (text) => {
        const match = regExp.exec(text);
        if (match === null)
          return null;
        return {
          index: match.index,
          length: match[0].length,
          text: match[0],
          url: urlTransformer(text)
        };
      };
    }
    function findFirstMatch(text, matchers) {
      for (let i = 0; i < matchers.length; i++) {
        const match = matchers[i](text);
        if (match) {
          return match;
        }
      }
      return null;
    }
    var PUNCTUATION_OR_SPACE = /[.,;\s]/;
    function isSeparator(char) {
      return PUNCTUATION_OR_SPACE.test(char);
    }
    function endsWithSeparator(textContent) {
      return isSeparator(textContent[textContent.length - 1]);
    }
    function startsWithSeparator(textContent) {
      return isSeparator(textContent[0]);
    }
    function isPreviousNodeValid(node) {
      let previousNode = node.getPreviousSibling();
      if (lexical.$isElementNode(previousNode)) {
        previousNode = previousNode.getLastDescendant();
      }
      return previousNode === null || lexical.$isLineBreakNode(previousNode) || lexical.$isTextNode(previousNode) && endsWithSeparator(previousNode.getTextContent());
    }
    function isNextNodeValid(node) {
      let nextNode = node.getNextSibling();
      if (lexical.$isElementNode(nextNode)) {
        nextNode = nextNode.getFirstDescendant();
      }
      return nextNode === null || lexical.$isLineBreakNode(nextNode) || lexical.$isTextNode(nextNode) && startsWithSeparator(nextNode.getTextContent());
    }
    function isContentAroundIsValid(matchStart, matchEnd, text, node) {
      const contentBeforeIsValid = matchStart > 0 ? isSeparator(text[matchStart - 1]) : isPreviousNodeValid(node);
      if (!contentBeforeIsValid) {
        return false;
      }
      const contentAfterIsValid = matchEnd < text.length ? isSeparator(text[matchEnd]) : isNextNodeValid(node);
      return contentAfterIsValid;
    }
    function handleLinkCreation(node, matchers, onChange) {
      const nodeText = node.getTextContent();
      let text = nodeText;
      let invalidMatchEnd = 0;
      let remainingTextNode = node;
      let match;
      while ((match = findFirstMatch(text, matchers)) && match !== null) {
        const matchStart = match.index;
        const matchLength = match.length;
        const matchEnd = matchStart + matchLength;
        const isValid = isContentAroundIsValid(invalidMatchEnd + matchStart, invalidMatchEnd + matchEnd, nodeText, node);
        if (isValid) {
          let linkTextNode;
          if (invalidMatchEnd + matchStart === 0) {
            [linkTextNode, remainingTextNode] = remainingTextNode.splitText(invalidMatchEnd + matchLength);
          } else {
            [, linkTextNode, remainingTextNode] = remainingTextNode.splitText(invalidMatchEnd + matchStart, invalidMatchEnd + matchStart + matchLength);
          }
          const linkNode = link.$createAutoLinkNode(match.url, match.attributes);
          const textNode = lexical.$createTextNode(match.text);
          textNode.setFormat(linkTextNode.getFormat());
          textNode.setDetail(linkTextNode.getDetail());
          linkNode.append(textNode);
          linkTextNode.replace(linkNode);
          onChange(match.url, null);
          invalidMatchEnd = 0;
        } else {
          invalidMatchEnd += matchEnd;
        }
        text = text.substring(matchEnd);
      }
    }
    function handleLinkEdit(linkNode, matchers, onChange) {
      const children = linkNode.getChildren();
      const childrenLength = children.length;
      for (let i = 0; i < childrenLength; i++) {
        const child = children[i];
        if (!lexical.$isTextNode(child) || !child.isSimpleText()) {
          replaceWithChildren(linkNode);
          onChange(null, linkNode.getURL());
          return;
        }
      }
      const text = linkNode.getTextContent();
      const match = findFirstMatch(text, matchers);
      if (match === null || match.text !== text) {
        replaceWithChildren(linkNode);
        onChange(null, linkNode.getURL());
        return;
      }
      if (!isPreviousNodeValid(linkNode) || !isNextNodeValid(linkNode)) {
        replaceWithChildren(linkNode);
        onChange(null, linkNode.getURL());
        return;
      }
      const url = linkNode.getURL();
      if (url !== match.url) {
        linkNode.setURL(match.url);
        onChange(match.url, url);
      }
      if (match.attributes) {
        const rel = linkNode.getRel();
        if (rel !== match.attributes.rel) {
          linkNode.setRel(match.attributes.rel || null);
          onChange(match.attributes.rel || null, rel);
        }
        const target = linkNode.getTarget();
        if (target !== match.attributes.target) {
          linkNode.setTarget(match.attributes.target || null);
          onChange(match.attributes.target || null, target);
        }
      }
    }
    function handleBadNeighbors(textNode, matchers, onChange) {
      const previousSibling = textNode.getPreviousSibling();
      const nextSibling = textNode.getNextSibling();
      const text = textNode.getTextContent();
      if (link.$isAutoLinkNode(previousSibling) && !startsWithSeparator(text)) {
        previousSibling.append(textNode);
        handleLinkEdit(previousSibling, matchers, onChange);
        onChange(null, previousSibling.getURL());
      }
      if (link.$isAutoLinkNode(nextSibling) && !endsWithSeparator(text)) {
        replaceWithChildren(nextSibling);
        handleLinkEdit(nextSibling, matchers, onChange);
        onChange(null, nextSibling.getURL());
      }
    }
    function replaceWithChildren(node) {
      const children = node.getChildren();
      const childrenLength = children.length;
      for (let j = childrenLength - 1; j >= 0; j--) {
        node.insertAfter(children[j]);
      }
      node.remove();
      return children.map((child) => child.getLatest());
    }
    function useAutoLink(editor, matchers, onChange) {
      react.useEffect(() => {
        if (!editor.hasNodes([link.AutoLinkNode])) {
          {
            throw Error(`LexicalAutoLinkPlugin: AutoLinkNode not registered on editor`);
          }
        }
        const onChangeWrapped = (url, prevUrl) => {
          if (onChange) {
            onChange(url, prevUrl);
          }
        };
        return utils.mergeRegister(editor.registerNodeTransform(lexical.TextNode, (textNode) => {
          const parent = textNode.getParentOrThrow();
          const previous = textNode.getPreviousSibling();
          if (link.$isAutoLinkNode(parent)) {
            handleLinkEdit(parent, matchers, onChangeWrapped);
          } else if (!link.$isLinkNode(parent)) {
            if (textNode.isSimpleText() && (startsWithSeparator(textNode.getTextContent()) || !link.$isAutoLinkNode(previous))) {
              handleLinkCreation(textNode, matchers, onChangeWrapped);
            }
            handleBadNeighbors(textNode, matchers, onChangeWrapped);
          }
        }));
      }, [editor, matchers, onChange]);
    }
    function AutoLinkPlugin2({
      matchers,
      onChange
    }) {
      const [editor] = LexicalComposerContext.useLexicalComposerContext();
      useAutoLink(editor, matchers, onChange);
      return null;
    }
    exports.AutoLinkPlugin = AutoLinkPlugin2;
    exports.createLinkMatcherWithRegExp = createLinkMatcherWithRegExp2;
  }
});

// node_modules/@lexical/react/LexicalAutoLinkPlugin.js
var require_LexicalAutoLinkPlugin = __commonJS({
  "node_modules/@lexical/react/LexicalAutoLinkPlugin.js"(exports, module) {
    "use strict";
    var LexicalAutoLinkPlugin2 = true ? require_LexicalAutoLinkPlugin_dev() : null;
    module.exports = LexicalAutoLinkPlugin2;
  }
});

// node_modules/@mdxeditor/editor/dist/plugins/link/index.js
var import_react2 = __toESM(require_react());

// node_modules/@mdxeditor/editor/dist/plugins/link/MdastLinkVisitor.js
var import_link = __toESM(require_LexicalLink(), 1);
var MdastLinkVisitor = {
  testNode: "link",
  visitNode({ mdastNode, actions }) {
    actions.addAndStepInto(
      (0, import_link.$createLinkNode)(mdastNode.url, {
        title: mdastNode.title
      })
    );
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/link/LexicalLinkVisitor.js
var import_link2 = __toESM(require_LexicalLink(), 1);
var LexicalLinkVisitor = {
  testLexicalNode: import_link2.$isLinkNode,
  visitLexicalNode: ({ lexicalNode, actions }) => {
    actions.addAndStepInto("link", { url: lexicalNode.getURL(), title: lexicalNode.getTitle() });
  }
};

// node_modules/@mdxeditor/editor/dist/plugins/link/index.js
var import_link3 = __toESM(require_LexicalLink());
var import_LexicalLinkPlugin = __toESM(require_LexicalLinkPlugin());

// node_modules/@mdxeditor/editor/dist/plugins/link/AutoLinkPlugin.js
var import_LexicalAutoLinkPlugin = __toESM(require_LexicalAutoLinkPlugin(), 1);
var import_react = __toESM(require_react(), 1);
var URL_REGEX = /((https?:\/\/(www\.)?)|(www\.))[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_+.~#?&//=]*)/;
var EMAIL_REGEX = /(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))/;
var MATCHERS = [
  (0, import_LexicalAutoLinkPlugin.createLinkMatcherWithRegExp)(URL_REGEX, (text) => {
    return text.startsWith("http") ? text : `https://${text}`;
  }),
  (0, import_LexicalAutoLinkPlugin.createLinkMatcherWithRegExp)(EMAIL_REGEX, (text) => {
    return `mailto:${text}`;
  })
];
var LexicalAutoLinkPlugin = () => {
  return import_react.default.createElement(import_LexicalAutoLinkPlugin.AutoLinkPlugin, { matchers: MATCHERS });
};

// node_modules/@mdxeditor/editor/dist/plugins/link/index.js
var linkSystem = system(
  (r) => {
    const disableAutoLink = r.node(false);
    return { disableAutoLink };
  },
  [coreSystem]
);
var [linkPlugin] = realmPlugin({
  id: "link",
  systemSpec: linkSystem,
  init: (realm, params) => {
    const disableAutoLink = Boolean(params == null ? void 0 : params.disableAutoLink);
    realm.pubKey("addImportVisitor", MdastLinkVisitor);
    realm.pubKey("addLexicalNode", import_link3.LinkNode);
    realm.pubKey("addLexicalNode", import_link3.AutoLinkNode);
    realm.pubKey("addExportVisitor", LexicalLinkVisitor);
    realm.pubKey("disableAutoLink", disableAutoLink);
    const linkPluginProps = (params == null ? void 0 : params.validateUrl) ? { validateUrl: params.validateUrl } : {};
    realm.pubKey("addComposerChild", () => import_react2.default.createElement(import_react2.default.Fragment, null, import_react2.default.createElement(import_LexicalLinkPlugin.LinkPlugin, { ...linkPluginProps }), disableAutoLink ? null : import_react2.default.createElement(LexicalAutoLinkPlugin, null)));
  }
});
export {
  linkPlugin
};
//# sourceMappingURL=@mdxeditor_editor_plugins_link.js.map
