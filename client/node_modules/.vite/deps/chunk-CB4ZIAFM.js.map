{
  "version": 3,
  "sources": ["../../@lexical/list/LexicalList.dev.js", "../../@lexical/list/LexicalList.js", "../../@lexical/react/LexicalTabIndentationPlugin.dev.js", "../../@lexical/react/LexicalTabIndentationPlugin.js", "../../@lexical/react/LexicalListPlugin.dev.js", "../../@lexical/react/LexicalListPlugin.js", "../../@mdxeditor/editor/dist/plugins/lists/MdastListVisitor.js", "../../@mdxeditor/editor/dist/plugins/lists/MdastListItemVisitor.js", "../../@mdxeditor/editor/dist/plugins/lists/LexicalListVisitor.js", "../../@mdxeditor/editor/dist/plugins/lists/LexicalListItemVisitor.js", "../../@mdxeditor/editor/dist/plugins/lists/index.js"],
  "sourcesContent": ["/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar lexical = require('lexical');\nvar utils = require('@lexical/utils');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n/**\n * Checks the depth of listNode from the root node.\n * @param listNode - The ListNode to be checked.\n * @returns The depth of the ListNode.\n */\n\nfunction $getListDepth(listNode) {\n  let depth = 1;\n  let parent = listNode.getParent();\n\n  while (parent != null) {\n    if ($isListItemNode(parent)) {\n      const parentList = parent.getParent();\n\n      if ($isListNode(parentList)) {\n        depth++;\n        parent = parentList.getParent();\n        continue;\n      }\n\n      {\n        throw Error(`A ListItemNode must have a ListNode for a parent.`);\n      }\n    }\n\n    return depth;\n  }\n\n  return depth;\n}\n/**\n * Finds the nearest ancestral ListNode and returns it, throws an invariant if listItem is not a ListItemNode.\n * @param listItem - The node to be checked.\n * @returns The ListNode found.\n */\n\nfunction $getTopListNode(listItem) {\n  let list = listItem.getParent();\n\n  if (!$isListNode(list)) {\n    {\n      throw Error(`A ListItemNode must have a ListNode for a parent.`);\n    }\n  }\n\n  let parent = list;\n\n  while (parent !== null) {\n    parent = parent.getParent();\n\n    if ($isListNode(parent)) {\n      list = parent;\n    }\n  }\n\n  return list;\n}\n/**\n * A recursive Depth-First Search (Postorder Traversal) that finds all of a node's children\n * that are of type ListItemNode and returns them in an array.\n * @param node - The ListNode to start the search.\n * @returns An array containing all nodes of type ListItemNode found.\n */\n// This should probably be $getAllChildrenOfType\n\nfunction $getAllListItems(node) {\n  let listItemNodes = [];\n  const listChildren = node.getChildren().filter($isListItemNode);\n\n  for (let i = 0; i < listChildren.length; i++) {\n    const listItemNode = listChildren[i];\n    const firstChild = listItemNode.getFirstChild();\n\n    if ($isListNode(firstChild)) {\n      listItemNodes = listItemNodes.concat($getAllListItems(firstChild));\n    } else {\n      listItemNodes.push(listItemNode);\n    }\n  }\n\n  return listItemNodes;\n}\n/**\n * Checks to see if the passed node is a ListItemNode and has a ListNode as a child.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode and has a ListNode child, false otherwise.\n */\n\nfunction isNestedListNode(node) {\n  return $isListItemNode(node) && $isListNode(node.getFirstChild());\n}\n/**\n * Takes a deeply nested ListNode or ListItemNode and traverses up the branch to delete the first\n * ancestral ListNode (which could be the root ListNode) or ListItemNode with siblings, essentially\n * bringing the deeply nested node up the branch once. Would remove sublist if it has siblings.\n * Should not break ListItem -> List -> ListItem chain as empty List/ItemNodes should be removed on .remove().\n * @param sublist - The nested ListNode or ListItemNode to be brought up the branch.\n */\n\nfunction $removeHighestEmptyListParent(sublist) {\n  // Nodes may be repeatedly indented, to create deeply nested lists that each\n  // contain just one bullet.\n  // Our goal is to remove these (empty) deeply nested lists. The easiest\n  // way to do that is crawl back up the tree until we find a node that has siblings\n  // (e.g. is actually part of the list contents) and delete that, or delete\n  // the root of the list (if no list nodes have siblings.)\n  let emptyListPtr = sublist;\n\n  while (emptyListPtr.getNextSibling() == null && emptyListPtr.getPreviousSibling() == null) {\n    const parent = emptyListPtr.getParent();\n\n    if (parent == null || !($isListItemNode(emptyListPtr) || $isListNode(emptyListPtr))) {\n      break;\n    }\n\n    emptyListPtr = parent;\n  }\n\n  emptyListPtr.remove();\n}\n/**\n * Wraps a node into a ListItemNode.\n * @param node - The node to be wrapped into a ListItemNode\n * @returns The ListItemNode which the passed node is wrapped in.\n */\n\nfunction wrapInListItem(node) {\n  const listItemWrapper = $createListItemNode();\n  return listItemWrapper.append(node);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction $isSelectingEmptyListItem(anchorNode, nodes) {\n  return $isListItemNode(anchorNode) && (nodes.length === 0 || nodes.length === 1 && anchorNode.is(nodes[0]) && anchorNode.getChildrenSize() === 0);\n}\n\nfunction $getListItemValue(listItem) {\n  const list = listItem.getParent();\n  let value = 1;\n\n  if (list != null) {\n    if (!$isListNode(list)) {\n      {\n        throw Error(`$getListItemValue: list node is not parent of list item node`);\n      }\n    } else {\n      value = list.getStart();\n    }\n  }\n\n  const siblings = listItem.getPreviousSiblings();\n\n  for (let i = 0; i < siblings.length; i++) {\n    const sibling = siblings[i];\n\n    if ($isListItemNode(sibling) && !$isListNode(sibling.getFirstChild())) {\n      value++;\n    }\n  }\n\n  return value;\n}\n/**\n * Inserts a new ListNode. If the selection's anchor node is an empty ListItemNode and is a child of\n * the root/shadow root, it will replace the ListItemNode with a ListNode and the old ListItemNode.\n * Otherwise it will replace its parent with a new ListNode and re-insert the ListItemNode and any previous children.\n * If the selection's anchor node is not an empty ListItemNode, it will add a new ListNode or merge an existing ListNode,\n * unless the the node is a leaf node, in which case it will attempt to find a ListNode up the branch and replace it with\n * a new ListNode, or create a new ListNode at the nearest root/shadow root.\n * @param editor - The lexical editor.\n * @param listType - The type of list, \"number\" | \"bullet\" | \"check\".\n */\n\n\nfunction insertList(editor, listType) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection) || lexical.DEPRECATED_$isGridSelection(selection)) {\n      const nodes = selection.getNodes();\n      const anchor = selection.anchor;\n      const anchorNode = anchor.getNode();\n      const anchorNodeParent = anchorNode.getParent();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        const list = $createListNode(listType);\n\n        if (lexical.$isRootOrShadowRoot(anchorNodeParent)) {\n          anchorNode.replace(list);\n          const listItem = $createListItemNode();\n\n          if (lexical.$isElementNode(anchorNode)) {\n            listItem.setFormat(anchorNode.getFormatType());\n            listItem.setIndent(anchorNode.getIndent());\n          }\n\n          list.append(listItem);\n        } else if ($isListItemNode(anchorNode)) {\n          const parent = anchorNode.getParentOrThrow();\n          append(list, parent.getChildren());\n          parent.replace(list);\n        }\n\n        return;\n      } else {\n        const handled = new Set();\n\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isElementNode(node) && node.isEmpty() && !handled.has(node.getKey())) {\n            createListOrMerge(node, listType);\n            continue;\n          }\n\n          if (lexical.$isLeafNode(node)) {\n            let parent = node.getParent();\n\n            while (parent != null) {\n              const parentKey = parent.getKey();\n\n              if ($isListNode(parent)) {\n                if (!handled.has(parentKey)) {\n                  const newListNode = $createListNode(listType);\n                  append(newListNode, parent.getChildren());\n                  parent.replace(newListNode);\n                  updateChildrenListItemValue(newListNode);\n                  handled.add(parentKey);\n                }\n\n                break;\n              } else {\n                const nextParent = parent.getParent();\n\n                if (lexical.$isRootOrShadowRoot(nextParent) && !handled.has(parentKey)) {\n                  handled.add(parentKey);\n                  createListOrMerge(parent, listType);\n                  break;\n                }\n\n                parent = nextParent;\n              }\n            }\n          }\n        }\n      }\n    }\n  });\n}\n\nfunction append(node, nodesToAppend) {\n  node.splice(node.getChildrenSize(), 0, nodesToAppend);\n}\n\nfunction createListOrMerge(node, listType) {\n  if ($isListNode(node)) {\n    return node;\n  }\n\n  const previousSibling = node.getPreviousSibling();\n  const nextSibling = node.getNextSibling();\n  const listItem = $createListItemNode();\n  listItem.setFormat(node.getFormatType());\n  listItem.setIndent(node.getIndent());\n  append(listItem, node.getChildren());\n\n  if ($isListNode(previousSibling) && listType === previousSibling.getListType()) {\n    previousSibling.append(listItem);\n    node.remove(); // if the same type of list is on both sides, merge them.\n\n    if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n      append(previousSibling, nextSibling.getChildren());\n      nextSibling.remove();\n    }\n\n    return previousSibling;\n  } else if ($isListNode(nextSibling) && listType === nextSibling.getListType()) {\n    nextSibling.getFirstChildOrThrow().insertBefore(listItem);\n    node.remove();\n    return nextSibling;\n  } else {\n    const list = $createListNode(listType);\n    list.append(listItem);\n    node.replace(list);\n    updateChildrenListItemValue(list);\n    return list;\n  }\n}\n/**\n * A recursive function that goes through each list and their children, including nested lists,\n * appending list2 children after list1 children and updating ListItemNode values.\n * @param list1 - The first list to be merged.\n * @param list2 - The second list to be merged.\n */\n\n\nfunction mergeLists(list1, list2) {\n  const listItem1 = list1.getLastChild();\n  const listItem2 = list2.getFirstChild();\n\n  if (listItem1 && listItem2 && isNestedListNode(listItem1) && isNestedListNode(listItem2)) {\n    mergeLists(listItem1.getFirstChild(), listItem2.getFirstChild());\n    listItem2.remove();\n  }\n\n  const toMerge = list2.getChildren();\n\n  if (toMerge.length > 0) {\n    list1.append(...toMerge);\n    updateChildrenListItemValue(list1);\n  }\n\n  list2.remove();\n}\n/**\n * Searches for the nearest ancestral ListNode and removes it. If selection is an empty ListItemNode\n * it will remove the whole list, including the ListItemNode. For each ListItemNode in the ListNode,\n * removeList will also generate new ParagraphNodes in the removed ListNode's place. Any child node\n * inside a ListItemNode will be appended to the new ParagraphNodes.\n * @param editor - The lexical editor.\n */\n\nfunction removeList(editor) {\n  editor.update(() => {\n    const selection = lexical.$getSelection();\n\n    if (lexical.$isRangeSelection(selection)) {\n      const listNodes = new Set();\n      const nodes = selection.getNodes();\n      const anchorNode = selection.anchor.getNode();\n\n      if ($isSelectingEmptyListItem(anchorNode, nodes)) {\n        listNodes.add($getTopListNode(anchorNode));\n      } else {\n        for (let i = 0; i < nodes.length; i++) {\n          const node = nodes[i];\n\n          if (lexical.$isLeafNode(node)) {\n            const listItemNode = utils.$getNearestNodeOfType(node, ListItemNode);\n\n            if (listItemNode != null) {\n              listNodes.add($getTopListNode(listItemNode));\n            }\n          }\n        }\n      }\n\n      for (const listNode of listNodes) {\n        let insertionPoint = listNode;\n        const listItems = $getAllListItems(listNode);\n\n        for (const listItemNode of listItems) {\n          const paragraph = lexical.$createParagraphNode();\n          append(paragraph, listItemNode.getChildren());\n          insertionPoint.insertAfter(paragraph);\n          insertionPoint = paragraph; // When the anchor and focus fall on the textNode\n          // we don't have to change the selection because the textNode will be appended to\n          // the newly generated paragraph.\n          // When selection is in empty nested list item, selection is actually on the listItemNode.\n          // When the corresponding listItemNode is deleted and replaced by the newly generated paragraph\n          // we should manually set the selection's focus and anchor to the newly generated paragraph.\n\n          if (listItemNode.__key === selection.anchor.key) {\n            selection.anchor.set(paragraph.getKey(), 0, 'element');\n          }\n\n          if (listItemNode.__key === selection.focus.key) {\n            selection.focus.set(paragraph.getKey(), 0, 'element');\n          }\n\n          listItemNode.remove();\n        }\n\n        listNode.remove();\n      }\n    }\n  });\n}\n/**\n * Takes the value of a child ListItemNode and makes it the value the ListItemNode\n * should be if it isn't already. If only certain children should be updated, they\n * can be passed optionally in an array.\n * @param list - The list whose children are updated.\n * @param children - An array of the children to be updated.\n */\n\nfunction updateChildrenListItemValue(list, children) {\n  const childrenOrExisting = children || list.getChildren();\n\n  if (childrenOrExisting !== undefined) {\n    for (let i = 0; i < childrenOrExisting.length; i++) {\n      const child = childrenOrExisting[i];\n\n      if ($isListItemNode(child)) {\n        const prevValue = child.getValue();\n        const nextValue = $getListItemValue(child);\n\n        if (prevValue !== nextValue) {\n          child.setValue(nextValue);\n        }\n      }\n    }\n  }\n}\n/**\n * Adds an empty ListNode/ListItemNode chain at listItemNode, so as to\n * create an indent effect. Won't indent ListItemNodes that have a ListNode as\n * a child, but does merge sibling ListItemNodes if one has a nested ListNode.\n * @param listItemNode - The ListItemNode to be indented.\n */\n\nfunction $handleIndent(listItemNode) {\n  // go through each node and decide where to move it.\n  const removed = new Set();\n\n  if (isNestedListNode(listItemNode) || removed.has(listItemNode.getKey())) {\n    return;\n  }\n\n  const parent = listItemNode.getParent(); // We can cast both of the below `isNestedListNode` only returns a boolean type instead of a user-defined type guards\n\n  const nextSibling = listItemNode.getNextSibling();\n  const previousSibling = listItemNode.getPreviousSibling(); // if there are nested lists on either side, merge them all together.\n\n  if (isNestedListNode(nextSibling) && isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      const nextInnerList = nextSibling.getFirstChild();\n\n      if ($isListNode(nextInnerList)) {\n        const children = nextInnerList.getChildren();\n        append(innerList, children);\n        nextSibling.remove();\n        removed.add(nextSibling.getKey());\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(nextSibling)) {\n    // if the ListItemNode is next to a nested ListNode, merge them\n    const innerList = nextSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      const firstChild = innerList.getFirstChild();\n\n      if (firstChild !== null) {\n        firstChild.insertBefore(listItemNode);\n      }\n\n      updateChildrenListItemValue(innerList);\n    }\n  } else if (isNestedListNode(previousSibling)) {\n    const innerList = previousSibling.getFirstChild();\n\n    if ($isListNode(innerList)) {\n      innerList.append(listItemNode);\n      updateChildrenListItemValue(innerList);\n    }\n  } else {\n    // otherwise, we need to create a new nested ListNode\n    if ($isListNode(parent)) {\n      const newListItem = $createListItemNode();\n      const newList = $createListNode(parent.getListType());\n      newListItem.append(newList);\n      newList.append(listItemNode);\n\n      if (previousSibling) {\n        previousSibling.insertAfter(newListItem);\n      } else if (nextSibling) {\n        nextSibling.insertBefore(newListItem);\n      } else {\n        parent.append(newListItem);\n      }\n\n      updateChildrenListItemValue(newList);\n    }\n  }\n\n  if ($isListNode(parent)) {\n    updateChildrenListItemValue(parent);\n  }\n}\n/**\n * Removes an indent by removing an empty ListNode/ListItemNode chain. An indented ListItemNode\n * has a great grandparent node of type ListNode, which is where the ListItemNode will reside\n * within as a child.\n * @param listItemNode - The ListItemNode to remove the indent (outdent).\n */\n\nfunction $handleOutdent(listItemNode) {\n  // go through each node and decide where to move it.\n  if (isNestedListNode(listItemNode)) {\n    return;\n  }\n\n  const parentList = listItemNode.getParent();\n  const grandparentListItem = parentList ? parentList.getParent() : undefined;\n  const greatGrandparentList = grandparentListItem ? grandparentListItem.getParent() : undefined; // If it doesn't have these ancestors, it's not indented.\n\n  if ($isListNode(greatGrandparentList) && $isListItemNode(grandparentListItem) && $isListNode(parentList)) {\n    // if it's the first child in it's parent list, insert it into the\n    // great grandparent list before the grandparent\n    const firstChild = parentList ? parentList.getFirstChild() : undefined;\n    const lastChild = parentList ? parentList.getLastChild() : undefined;\n\n    if (listItemNode.is(firstChild)) {\n      grandparentListItem.insertBefore(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      } // if it's the last child in it's parent list, insert it into the\n      // great grandparent list after the grandparent.\n\n    } else if (listItemNode.is(lastChild)) {\n      grandparentListItem.insertAfter(listItemNode);\n\n      if (parentList.isEmpty()) {\n        grandparentListItem.remove();\n      }\n    } else {\n      // otherwise, we need to split the siblings into two new nested lists\n      const listType = parentList.getListType();\n      const previousSiblingsListItem = $createListItemNode();\n      const previousSiblingsList = $createListNode(listType);\n      previousSiblingsListItem.append(previousSiblingsList);\n      listItemNode.getPreviousSiblings().forEach(sibling => previousSiblingsList.append(sibling));\n      const nextSiblingsListItem = $createListItemNode();\n      const nextSiblingsList = $createListNode(listType);\n      nextSiblingsListItem.append(nextSiblingsList);\n      append(nextSiblingsList, listItemNode.getNextSiblings()); // put the sibling nested lists on either side of the grandparent list item in the great grandparent.\n\n      grandparentListItem.insertBefore(previousSiblingsListItem);\n      grandparentListItem.insertAfter(nextSiblingsListItem); // replace the grandparent list item (now between the siblings) with the outdented list item.\n\n      grandparentListItem.replace(listItemNode);\n    }\n\n    updateChildrenListItemValue(parentList);\n    updateChildrenListItemValue(greatGrandparentList);\n  }\n}\n/**\n * Attempts to insert a ParagraphNode at selection and selects the new node. The selection must contain a ListItemNode\n * or a node that does not already contain text. If its grandparent is the root/shadow root, it will get the ListNode\n * (which should be the parent node) and insert the ParagraphNode as a sibling to the ListNode. If the ListNode is\n * nested in a ListItemNode instead, it will add the ParagraphNode after the grandparent ListItemNode.\n * Throws an invariant if the selection is not a child of a ListNode.\n * @returns true if a ParagraphNode was inserted succesfully, false if there is no selection\n * or the selection does not contain a ListItemNode or the node already holds text.\n */\n\nfunction $handleListInsertParagraph() {\n  const selection = lexical.$getSelection();\n\n  if (!lexical.$isRangeSelection(selection) || !selection.isCollapsed()) {\n    return false;\n  } // Only run this code on empty list items\n\n\n  const anchor = selection.anchor.getNode();\n\n  if (!$isListItemNode(anchor) || anchor.getChildrenSize() !== 0) {\n    return false;\n  }\n\n  const topListNode = $getTopListNode(anchor);\n  const parent = anchor.getParent();\n\n  if (!$isListNode(parent)) {\n    throw Error(`A ListItemNode must have a ListNode for a parent.`);\n  }\n\n  const grandparent = parent.getParent();\n  let replacementNode;\n\n  if (lexical.$isRootOrShadowRoot(grandparent)) {\n    replacementNode = lexical.$createParagraphNode();\n    topListNode.insertAfter(replacementNode);\n  } else if ($isListItemNode(grandparent)) {\n    replacementNode = $createListItemNode();\n    grandparent.insertAfter(replacementNode);\n  } else {\n    return false;\n  }\n\n  replacementNode.select();\n  const nextSiblings = anchor.getNextSiblings();\n\n  if (nextSiblings.length > 0) {\n    const newList = $createListNode(parent.getListType());\n\n    if (lexical.$isParagraphNode(replacementNode)) {\n      replacementNode.insertAfter(newList);\n    } else {\n      const newListItem = $createListItemNode();\n      newListItem.append(newList);\n      replacementNode.insertAfter(newListItem);\n    }\n\n    nextSiblings.forEach(sibling => {\n      sibling.remove();\n      newList.append(sibling);\n    });\n  } // Don't leave hanging nested empty lists\n\n\n  $removeHighestEmptyListParent(anchor);\n  return true;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListItemNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'listitem';\n  }\n\n  static clone(node) {\n    return new ListItemNode(node.__value, node.__checked, node.__key);\n  }\n\n  constructor(value, checked, key) {\n    super(key);\n    this.__value = value === undefined ? 1 : value;\n    this.__checked = checked;\n  }\n\n  createDOM(config) {\n    const element = document.createElement('li');\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(element, this, null);\n    }\n\n    element.value = this.__value;\n    $setListItemThemeClassNames(element, config.theme, this);\n    return element;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    const parent = this.getParent();\n\n    if ($isListNode(parent) && parent.getListType() === 'check') {\n      updateListItemChecked(dom, this, prevNode);\n    } // @ts-expect-error - this is always HTMLListItemElement\n\n\n    dom.value = this.__value;\n    $setListItemThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static transform() {\n    return node => {\n      const parent = node.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n\n        if (parent.getListType() !== 'check' && node.getChecked() != null) {\n          node.setChecked(undefined);\n        }\n      }\n    };\n  }\n\n  static importDOM() {\n    return {\n      li: node => ({\n        conversion: convertListItemElement,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListItemNode();\n    node.setChecked(serializedNode.checked);\n    node.setValue(serializedNode.value);\n    node.setFormat(serializedNode.format);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      checked: this.getChecked(),\n      type: 'listitem',\n      value: this.getValue(),\n      version: 1\n    };\n  }\n\n  append(...nodes) {\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n\n      if (lexical.$isElementNode(node) && this.canMergeWith(node)) {\n        const children = node.getChildren();\n        this.append(...children);\n        node.remove();\n      } else {\n        super.append(node);\n      }\n    }\n\n    return this;\n  }\n\n  replace(replaceWithNode, includeChildren) {\n    if ($isListItemNode(replaceWithNode)) {\n      return super.replace(replaceWithNode);\n    }\n\n    this.setIndent(0);\n    const list = this.getParentOrThrow();\n    if (!$isListNode(list)) return replaceWithNode;\n\n    if (list.__first === this.getKey()) {\n      list.insertBefore(replaceWithNode);\n    } else if (list.__last === this.getKey()) {\n      list.insertAfter(replaceWithNode);\n    } else {\n      // Split the list\n      const newList = $createListNode(list.getListType());\n      let nextSibling = this.getNextSibling();\n\n      while (nextSibling) {\n        const nodeToAppend = nextSibling;\n        nextSibling = nextSibling.getNextSibling();\n        newList.append(nodeToAppend);\n      }\n\n      list.insertAfter(replaceWithNode);\n      replaceWithNode.insertAfter(newList);\n    }\n\n    if (includeChildren) {\n      this.getChildren().forEach(child => {\n        replaceWithNode.append(child);\n      });\n    }\n\n    this.remove();\n\n    if (list.getChildrenSize() === 0) {\n      list.remove();\n    }\n\n    return replaceWithNode;\n  }\n\n  insertAfter(node, restoreSelection = true) {\n    const listNode = this.getParentOrThrow();\n\n    if (!$isListNode(listNode)) {\n      {\n        throw Error(`insertAfter: list node is not parent of list item node`);\n      }\n    }\n\n    const siblings = this.getNextSiblings();\n\n    if ($isListItemNode(node)) {\n      const after = super.insertAfter(node, restoreSelection);\n      const afterListNode = node.getParentOrThrow();\n\n      if ($isListNode(afterListNode)) {\n        updateChildrenListItemValue(afterListNode);\n      }\n\n      return after;\n    } // Attempt to merge if the list is of the same type.\n\n\n    if ($isListNode(node)) {\n      let child = node;\n      const children = node.getChildren();\n\n      for (let i = children.length - 1; i >= 0; i--) {\n        child = children[i];\n        this.insertAfter(child, restoreSelection);\n      }\n\n      return child;\n    } // Otherwise, split the list\n    // Split the lists and insert the node in between them\n\n\n    listNode.insertAfter(node, restoreSelection);\n\n    if (siblings.length !== 0) {\n      const newListNode = $createListNode(listNode.getListType());\n      siblings.forEach(sibling => newListNode.append(sibling));\n      node.insertAfter(newListNode, restoreSelection);\n    }\n\n    return node;\n  }\n\n  remove(preserveEmptyParent) {\n    const prevSibling = this.getPreviousSibling();\n    const nextSibling = this.getNextSibling();\n    super.remove(preserveEmptyParent);\n\n    if (prevSibling && nextSibling && isNestedListNode(prevSibling) && isNestedListNode(nextSibling)) {\n      mergeLists(prevSibling.getFirstChild(), nextSibling.getFirstChild());\n      nextSibling.remove();\n    } else if (nextSibling) {\n      const parent = nextSibling.getParent();\n\n      if ($isListNode(parent)) {\n        updateChildrenListItemValue(parent);\n      }\n    }\n  }\n\n  insertNewAfter(_, restoreSelection = true) {\n    const newElement = $createListItemNode(this.__checked == null ? undefined : false);\n    this.insertAfter(newElement, restoreSelection);\n    return newElement;\n  }\n\n  collapseAtStart(selection) {\n    const paragraph = lexical.$createParagraphNode();\n    const children = this.getChildren();\n    children.forEach(child => paragraph.append(child));\n    const listNode = this.getParentOrThrow();\n    const listNodeParent = listNode.getParentOrThrow();\n    const isIndented = $isListItemNode(listNodeParent);\n\n    if (listNode.getChildrenSize() === 1) {\n      if (isIndented) {\n        // if the list node is nested, we just want to remove it,\n        // effectively unindenting it.\n        listNode.remove();\n        listNodeParent.select();\n      } else {\n        listNode.insertBefore(paragraph);\n        listNode.remove(); // If we have selection on the list item, we'll need to move it\n        // to the paragraph\n\n        const anchor = selection.anchor;\n        const focus = selection.focus;\n        const key = paragraph.getKey();\n\n        if (anchor.type === 'element' && anchor.getNode().is(this)) {\n          anchor.set(key, anchor.offset, 'element');\n        }\n\n        if (focus.type === 'element' && focus.getNode().is(this)) {\n          focus.set(key, focus.offset, 'element');\n        }\n      }\n    } else {\n      listNode.insertBefore(paragraph);\n      this.remove();\n    }\n\n    return true;\n  }\n\n  getValue() {\n    const self = this.getLatest();\n    return self.__value;\n  }\n\n  setValue(value) {\n    const self = this.getWritable();\n    self.__value = value;\n  }\n\n  getChecked() {\n    const self = this.getLatest();\n    return self.__checked;\n  }\n\n  setChecked(checked) {\n    const self = this.getWritable();\n    self.__checked = checked;\n  }\n\n  toggleChecked() {\n    this.setChecked(!this.__checked);\n  }\n\n  getIndent() {\n    // If we don't have a parent, we are likely serializing\n    const parent = this.getParent();\n\n    if (parent === null) {\n      return this.getLatest().__indent;\n    } // ListItemNode should always have a ListNode for a parent.\n\n\n    let listNodeParent = parent.getParentOrThrow();\n    let indentLevel = 0;\n\n    while ($isListItemNode(listNodeParent)) {\n      listNodeParent = listNodeParent.getParentOrThrow().getParentOrThrow();\n      indentLevel++;\n    }\n\n    return indentLevel;\n  }\n\n  setIndent(indent) {\n    if (!(typeof indent === 'number' && indent > -1)) {\n      throw Error(`Invalid indent value.`);\n    }\n\n    let currentIndent = this.getIndent();\n\n    while (currentIndent !== indent) {\n      if (currentIndent < indent) {\n        $handleIndent(this);\n        currentIndent++;\n      } else {\n        $handleOutdent(this);\n        currentIndent--;\n      }\n    }\n\n    return this;\n  }\n\n  insertBefore(nodeToInsert) {\n    if ($isListItemNode(nodeToInsert)) {\n      const parent = this.getParentOrThrow();\n\n      if ($isListNode(parent)) {\n        const siblings = this.getNextSiblings();\n        updateChildrenListItemValue(parent, siblings);\n      }\n    }\n\n    return super.insertBefore(nodeToInsert);\n  }\n\n  canInsertAfter(node) {\n    return $isListItemNode(node);\n  }\n\n  canReplaceWith(replacement) {\n    return $isListItemNode(replacement);\n  }\n\n  canMergeWith(node) {\n    return lexical.$isParagraphNode(node) || $isListItemNode(node);\n  }\n\n  extractWithChild(child, selection) {\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    const anchorNode = selection.anchor.getNode();\n    const focusNode = selection.focus.getNode();\n    return this.isParentOf(anchorNode) && this.isParentOf(focusNode) && this.getTextContent().length === selection.getTextContent().length;\n  }\n\n  isParentRequired() {\n    return true;\n  }\n\n  createParentElementNode() {\n    return $createListNode('bullet');\n  }\n\n}\n\nfunction $setListItemThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n  const listItemClassName = listTheme ? listTheme.listitem : undefined;\n  let nestedListItemClassName;\n\n  if (listTheme && listTheme.nested) {\n    nestedListItemClassName = listTheme.nested.listitem;\n  }\n\n  if (listItemClassName !== undefined) {\n    const listItemClasses = listItemClassName.split(' ');\n    classesToAdd.push(...listItemClasses);\n  }\n\n  if (listTheme) {\n    const parentNode = node.getParent();\n    const isCheckList = $isListNode(parentNode) && parentNode.getListType() === 'check';\n    const checked = node.getChecked();\n\n    if (!isCheckList || checked) {\n      classesToRemove.push(listTheme.listitemUnchecked);\n    }\n\n    if (!isCheckList || !checked) {\n      classesToRemove.push(listTheme.listitemChecked);\n    }\n\n    if (isCheckList) {\n      classesToAdd.push(checked ? listTheme.listitemChecked : listTheme.listitemUnchecked);\n    }\n  }\n\n  if (nestedListItemClassName !== undefined) {\n    const nestedListItemClasses = nestedListItemClassName.split(' ');\n\n    if (node.getChildren().some(child => $isListNode(child))) {\n      classesToAdd.push(...nestedListItemClasses);\n    } else {\n      classesToRemove.push(...nestedListItemClasses);\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n\nfunction updateListItemChecked(dom, listItemNode, prevListItemNode, listNode) {\n  // Only add attributes for leaf list items\n  if ($isListNode(listItemNode.getFirstChild())) {\n    dom.removeAttribute('role');\n    dom.removeAttribute('tabIndex');\n    dom.removeAttribute('aria-checked');\n  } else {\n    dom.setAttribute('role', 'checkbox');\n    dom.setAttribute('tabIndex', '-1');\n\n    if (!prevListItemNode || listItemNode.__checked !== prevListItemNode.__checked) {\n      dom.setAttribute('aria-checked', listItemNode.getChecked() ? 'true' : 'false');\n    }\n  }\n}\n\nfunction convertListItemElement(domNode) {\n  const checked = utils.isHTMLElement(domNode) && domNode.getAttribute('aria-checked') === 'true';\n  return {\n    node: $createListItemNode(checked)\n  };\n}\n/**\n * Creates a new List Item node, passing true/false will convert it to a checkbox input.\n * @param checked - Is the List Item a checkbox and, if so, is it checked? undefined/null: not a checkbox, true/false is a checkbox and checked/unchecked, respectively.\n * @returns The new List Item.\n */\n\n\nfunction $createListItemNode(checked) {\n  return lexical.$applyNodeReplacement(new ListItemNode(undefined, checked));\n}\n/**\n * Checks to see if the node is a ListItemNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListItemNode, false otherwise.\n */\n\nfunction $isListItemNode(node) {\n  return node instanceof ListItemNode;\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\n/** @noInheritDoc */\nclass ListNode extends lexical.ElementNode {\n  /** @internal */\n\n  /** @internal */\n\n  /** @internal */\n  static getType() {\n    return 'list';\n  }\n\n  static clone(node) {\n    const listType = node.__listType || TAG_TO_LIST_TYPE[node.__tag];\n    return new ListNode(listType, node.__start, node.__key);\n  }\n\n  constructor(listType, start, key) {\n    super(key);\n\n    const _listType = TAG_TO_LIST_TYPE[listType] || listType;\n\n    this.__listType = _listType;\n    this.__tag = _listType === 'number' ? 'ol' : 'ul';\n    this.__start = start;\n  }\n\n  getTag() {\n    return this.__tag;\n  }\n\n  setListType(type) {\n    const writable = this.getWritable();\n    writable.__listType = type;\n    writable.__tag = type === 'number' ? 'ol' : 'ul';\n  }\n\n  getListType() {\n    return this.__listType;\n  }\n\n  getStart() {\n    return this.__start;\n  } // View\n\n\n  createDOM(config, _editor) {\n    const tag = this.__tag;\n    const dom = document.createElement(tag);\n\n    if (this.__start !== 1) {\n      dom.setAttribute('start', String(this.__start));\n    } // @ts-expect-error Internal field.\n\n\n    dom.__lexicalListType = this.__listType;\n    setListThemeClassNames(dom, config.theme, this);\n    return dom;\n  }\n\n  updateDOM(prevNode, dom, config) {\n    if (prevNode.__tag !== this.__tag) {\n      return true;\n    }\n\n    setListThemeClassNames(dom, config.theme, this);\n    return false;\n  }\n\n  static importDOM() {\n    return {\n      ol: node => ({\n        conversion: convertListNode,\n        priority: 0\n      }),\n      ul: node => ({\n        conversion: convertListNode,\n        priority: 0\n      })\n    };\n  }\n\n  static importJSON(serializedNode) {\n    const node = $createListNode(serializedNode.listType, serializedNode.start);\n    node.setFormat(serializedNode.format);\n    node.setIndent(serializedNode.indent);\n    node.setDirection(serializedNode.direction);\n    return node;\n  }\n\n  exportDOM(editor) {\n    const {\n      element\n    } = super.exportDOM(editor);\n\n    if (element && utils.isHTMLElement(element)) {\n      if (this.__start !== 1) {\n        element.setAttribute('start', String(this.__start));\n      }\n\n      if (this.__listType === 'check') {\n        element.setAttribute('__lexicalListType', 'check');\n      }\n    }\n\n    return {\n      element\n    };\n  }\n\n  exportJSON() {\n    return { ...super.exportJSON(),\n      listType: this.getListType(),\n      start: this.getStart(),\n      tag: this.getTag(),\n      type: 'list',\n      version: 1\n    };\n  }\n\n  canBeEmpty() {\n    return false;\n  }\n\n  canIndent() {\n    return false;\n  }\n\n  append(...nodesToAppend) {\n    for (let i = 0; i < nodesToAppend.length; i++) {\n      const currentNode = nodesToAppend[i];\n\n      if ($isListItemNode(currentNode)) {\n        super.append(currentNode);\n      } else {\n        const listItemNode = $createListItemNode();\n\n        if ($isListNode(currentNode)) {\n          listItemNode.append(currentNode);\n        } else if (lexical.$isElementNode(currentNode)) {\n          const textNode = lexical.$createTextNode(currentNode.getTextContent());\n          listItemNode.append(textNode);\n        } else {\n          listItemNode.append(currentNode);\n        }\n\n        super.append(listItemNode);\n      }\n    }\n\n    updateChildrenListItemValue(this);\n    return this;\n  }\n\n  extractWithChild(child) {\n    return $isListItemNode(child);\n  }\n\n}\n\nfunction setListThemeClassNames(dom, editorThemeClasses, node) {\n  const classesToAdd = [];\n  const classesToRemove = [];\n  const listTheme = editorThemeClasses.list;\n\n  if (listTheme !== undefined) {\n    const listLevelsClassNames = listTheme[`${node.__tag}Depth`] || [];\n    const listDepth = $getListDepth(node) - 1;\n    const normalizedListDepth = listDepth % listLevelsClassNames.length;\n    const listLevelClassName = listLevelsClassNames[normalizedListDepth];\n    const listClassName = listTheme[node.__tag];\n    let nestedListClassName;\n    const nestedListTheme = listTheme.nested;\n\n    if (nestedListTheme !== undefined && nestedListTheme.list) {\n      nestedListClassName = nestedListTheme.list;\n    }\n\n    if (listClassName !== undefined) {\n      classesToAdd.push(listClassName);\n    }\n\n    if (listLevelClassName !== undefined) {\n      const listItemClasses = listLevelClassName.split(' ');\n      classesToAdd.push(...listItemClasses);\n\n      for (let i = 0; i < listLevelsClassNames.length; i++) {\n        if (i !== normalizedListDepth) {\n          classesToRemove.push(node.__tag + i);\n        }\n      }\n    }\n\n    if (nestedListClassName !== undefined) {\n      const nestedListItemClasses = nestedListClassName.split(' ');\n\n      if (listDepth > 1) {\n        classesToAdd.push(...nestedListItemClasses);\n      } else {\n        classesToRemove.push(...nestedListItemClasses);\n      }\n    }\n  }\n\n  if (classesToRemove.length > 0) {\n    utils.removeClassNamesFromElement(dom, ...classesToRemove);\n  }\n\n  if (classesToAdd.length > 0) {\n    utils.addClassNamesToElement(dom, ...classesToAdd);\n  }\n}\n/*\n * This function normalizes the children of a ListNode after the conversion from HTML,\n * ensuring that they are all ListItemNodes and contain either a single nested ListNode\n * or some other inline content.\n */\n\n\nfunction normalizeChildren(nodes) {\n  const normalizedListItems = [];\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n\n    if ($isListItemNode(node)) {\n      normalizedListItems.push(node);\n      const children = node.getChildren();\n\n      if (children.length > 1) {\n        children.forEach(child => {\n          if ($isListNode(child)) {\n            normalizedListItems.push(wrapInListItem(child));\n          }\n        });\n      }\n    } else {\n      normalizedListItems.push(wrapInListItem(node));\n    }\n  }\n\n  return normalizedListItems;\n}\n\nfunction convertListNode(domNode) {\n  const nodeName = domNode.nodeName.toLowerCase();\n  let node = null;\n\n  if (nodeName === 'ol') {\n    // @ts-ignore\n    const start = domNode.start;\n    node = $createListNode('number', start);\n  } else if (nodeName === 'ul') {\n    if (utils.isHTMLElement(domNode) && domNode.getAttribute('__lexicallisttype') === 'check') {\n      node = $createListNode('check');\n    } else {\n      node = $createListNode('bullet');\n    }\n  }\n\n  return {\n    after: normalizeChildren,\n    node\n  };\n}\n\nconst TAG_TO_LIST_TYPE = {\n  ol: 'number',\n  ul: 'bullet'\n};\n/**\n * Creates a ListNode of listType.\n * @param listType - The type of list to be created. Can be 'number', 'bullet', or 'check'.\n * @param start - Where an ordered list starts its count, start = 1 if left undefined.\n * @returns The new ListNode\n */\n\nfunction $createListNode(listType, start = 1) {\n  return lexical.$applyNodeReplacement(new ListNode(listType, start));\n}\n/**\n * Checks to see if the node is a ListNode.\n * @param node - The node to be checked.\n * @returns true if the node is a ListNode, false otherwise.\n */\n\nfunction $isListNode(node) {\n  return node instanceof ListNode;\n}\n\n/** @module @lexical/list */\nconst INSERT_UNORDERED_LIST_COMMAND = lexical.createCommand('INSERT_UNORDERED_LIST_COMMAND');\nconst INSERT_ORDERED_LIST_COMMAND = lexical.createCommand('INSERT_ORDERED_LIST_COMMAND');\nconst INSERT_CHECK_LIST_COMMAND = lexical.createCommand('INSERT_CHECK_LIST_COMMAND');\nconst REMOVE_LIST_COMMAND = lexical.createCommand('REMOVE_LIST_COMMAND');\n\nexports.$createListItemNode = $createListItemNode;\nexports.$createListNode = $createListNode;\nexports.$getListDepth = $getListDepth;\nexports.$handleListInsertParagraph = $handleListInsertParagraph;\nexports.$isListItemNode = $isListItemNode;\nexports.$isListNode = $isListNode;\nexports.INSERT_CHECK_LIST_COMMAND = INSERT_CHECK_LIST_COMMAND;\nexports.INSERT_ORDERED_LIST_COMMAND = INSERT_ORDERED_LIST_COMMAND;\nexports.INSERT_UNORDERED_LIST_COMMAND = INSERT_UNORDERED_LIST_COMMAND;\nexports.ListItemNode = ListItemNode;\nexports.ListNode = ListNode;\nexports.REMOVE_LIST_COMMAND = REMOVE_LIST_COMMAND;\nexports.insertList = insertList;\nexports.removeList = removeList;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalList = process.env.NODE_ENV === 'development' ? require('./LexicalList.dev.js') : require('./LexicalList.prod.js')\nmodule.exports = LexicalList;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\nvar react = require('react');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\n\nfunction indentOverTab(selection) {\n  // const handled = new Set();\n  const nodes = selection.getNodes();\n  const canIndentBlockNodes = utils.$filter(nodes, node => {\n    if (lexical.$isBlockElementNode(node) && node.canIndent()) {\n      return node;\n    }\n\n    return null;\n  }); // 1. If selection spans across canIndent block nodes: indent\n\n  if (canIndentBlockNodes.length > 0) {\n    return true;\n  } // 2. If first (anchor/focus) is at block start: indent\n\n\n  const anchor = selection.anchor;\n  const focus = selection.focus;\n  const first = focus.isBefore(anchor) ? focus : anchor;\n  const firstNode = first.getNode();\n  const firstBlock = utils.$getNearestBlockElementAncestorOrThrow(firstNode);\n\n  if (firstBlock.canIndent()) {\n    const firstBlockKey = firstBlock.getKey();\n    let selectionAtStart = lexical.$createRangeSelection();\n    selectionAtStart.anchor.set(firstBlockKey, 0, 'element');\n    selectionAtStart.focus.set(firstBlockKey, 0, 'element');\n    selectionAtStart = lexical.$normalizeSelection__EXPERIMENTAL(selectionAtStart);\n\n    if (selectionAtStart.anchor.is(first)) {\n      return true;\n    }\n  } // 3. Else: tab\n\n\n  return false;\n}\n\nfunction registerTabIndentation(editor) {\n  return editor.registerCommand(lexical.KEY_TAB_COMMAND, event => {\n    const selection = lexical.$getSelection();\n\n    if (!lexical.$isRangeSelection(selection)) {\n      return false;\n    }\n\n    event.preventDefault();\n    const command = indentOverTab(selection) ? event.shiftKey ? lexical.OUTDENT_CONTENT_COMMAND : lexical.INDENT_CONTENT_COMMAND : lexical.INSERT_TAB_COMMAND;\n    return editor.dispatchCommand(command, undefined);\n  }, lexical.COMMAND_PRIORITY_EDITOR);\n}\n/**\n * This plugin adds the ability to indent content using the tab key. Generally, we don't\n * recommend using this plugin as it could negatively affect acessibility for keyboard\n * users, causing focus to become trapped within the editor.\n */\n\nfunction TabIndentationPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    return registerTabIndentation(editor);\n  });\n  return null;\n}\n\nexports.TabIndentationPlugin = TabIndentationPlugin;\nexports.registerTabIndentation = registerTabIndentation;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalTabIndentationPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalTabIndentationPlugin.dev.js') : require('./LexicalTabIndentationPlugin.prod.js')\nmodule.exports = LexicalTabIndentationPlugin;", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';\n\nvar list = require('@lexical/list');\nvar LexicalComposerContext = require('@lexical/react/LexicalComposerContext');\nvar react = require('react');\nvar utils = require('@lexical/utils');\nvar lexical = require('lexical');\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction useList(editor) {\n  react.useEffect(() => {\n    return utils.mergeRegister(editor.registerCommand(list.INSERT_ORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'number');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.INSERT_UNORDERED_LIST_COMMAND, () => {\n      list.insertList(editor, 'bullet');\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(list.REMOVE_LIST_COMMAND, () => {\n      list.removeList(editor);\n      return true;\n    }, lexical.COMMAND_PRIORITY_LOW), editor.registerCommand(lexical.INSERT_PARAGRAPH_COMMAND, () => {\n      const hasHandledInsertParagraph = list.$handleListInsertParagraph();\n\n      if (hasHandledInsertParagraph) {\n        return true;\n      }\n\n      return false;\n    }, lexical.COMMAND_PRIORITY_LOW));\n  }, [editor]);\n}\n\n/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n */\nfunction ListPlugin() {\n  const [editor] = LexicalComposerContext.useLexicalComposerContext();\n  react.useEffect(() => {\n    if (!editor.hasNodes([list.ListNode, list.ListItemNode])) {\n      throw new Error('ListPlugin: ListNode and/or ListItemNode not registered on editor');\n    }\n  }, [editor]);\n  useList(editor);\n  return null;\n}\n\nexports.ListPlugin = ListPlugin;\n", "/**\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict'\nconst LexicalListPlugin = process.env.NODE_ENV === 'development' ? require('./LexicalListPlugin.dev.js') : require('./LexicalListPlugin.prod.js')\nmodule.exports = LexicalListPlugin;", "import { $createListNode, $isListItemNode, $createListItemNode } from \"@lexical/list\";\nconst MdastListVisitor = {\n  testNode: \"list\",\n  visitNode: function({ mdastNode, lexicalParent, actions }) {\n    const lexicalNode = $createListNode(mdastNode.ordered ? \"number\" : \"bullet\");\n    if ($isListItemNode(lexicalParent)) {\n      const dedicatedParent = $createListItemNode();\n      dedicatedParent.append(lexicalNode);\n      lexicalParent.insertAfter(dedicatedParent);\n    } else {\n      lexicalParent.append(lexicalNode);\n    }\n    actions.visitChildren(mdastNode, lexicalNode);\n  }\n};\nexport {\n  MdastListVisitor\n};\n", "import { $createListItemNode } from \"@lexical/list\";\nconst MdastListItemVisitor = {\n  testNode: \"listItem\",\n  visitNode({ actions }) {\n    actions.addAndStepInto($createListItemNode());\n  }\n};\nexport {\n  MdastListItemVisitor\n};\n", "import { $isListNode } from \"@lexical/list\";\nconst LexicalListVisitor = {\n  testLexicalNode: $isListNode,\n  visitLexicalNode: ({ lexicalNode, actions }) => {\n    actions.addAndStepInto(\"list\", {\n      ordered: lexicalNode.getListType() === \"number\",\n      spread: false\n    });\n  }\n};\nexport {\n  LexicalListVisitor\n};\n", "import { $isListItemNode, $isListNode } from \"@lexical/list\";\nconst LexicalListItemVisitor = {\n  testLexicalNode: $isListItemNode,\n  visitLexicalNode: ({ lexicalNode, mdastParent, actions }) => {\n    const children = lexicalNode.getChildren();\n    const firstChild = children[0];\n    if (children.length === 1 && $isListNode(firstChild)) {\n      const prevListItemNode = mdastParent.children.at(-1);\n      actions.visitChildren(lexicalNode, prevListItemNode);\n    } else {\n      const listItem = actions.appendToParent(mdastParent, {\n        type: \"listItem\",\n        spread: false,\n        children: [{ type: \"paragraph\", children: [] }]\n      });\n      actions.visitChildren(lexicalNode, listItem.children[0]);\n    }\n  }\n};\nexport {\n  LexicalListItemVisitor\n};\n", "import { coreSystem } from \"../core/index.js\";\nimport { MdastListVisitor } from \"./MdastListVisitor.js\";\nimport { MdastListItemVisitor } from \"./MdastListItemVisitor.js\";\nimport { LexicalListVisitor } from \"./LexicalListVisitor.js\";\nimport { LexicalListItemVisitor } from \"./LexicalListItemVisitor.js\";\nimport { $isListNode, ListNode, INSERT_ORDERED_LIST_COMMAND, INSERT_UNORDERED_LIST_COMMAND, REMOVE_LIST_COMMAND, ListItemNode, $getListDepth, $isListItemNode } from \"@lexical/list\";\nimport { $isRootOrShadowRoot, INDENT_CONTENT_COMMAND, COMMAND_PRIORITY_CRITICAL, $getSelection, $isRangeSelection, $isElementNode } from \"lexical\";\nimport { TabIndentationPlugin } from \"@lexical/react/LexicalTabIndentationPlugin.js\";\nimport { ListPlugin } from \"@lexical/react/LexicalListPlugin.js\";\nimport { $findMatchingParent, $getNearestNodeOfType } from \"@lexical/utils\";\nimport { system } from \"../../gurx/realmFactory.js\";\nimport { realmPlugin } from \"../../gurx/react.js\";\nconst ListTypeCommandMap = /* @__PURE__ */ new Map([\n  [\"number\", INSERT_ORDERED_LIST_COMMAND],\n  [\"bullet\", INSERT_UNORDERED_LIST_COMMAND],\n  [\"\", REMOVE_LIST_COMMAND]\n]);\nconst listsSystem = system(\n  (r, [{ activeEditor, currentSelection }]) => {\n    const currentListType = r.node(\"\");\n    const applyListType = r.node();\n    r.sub(r.pipe(applyListType, r.o.withLatestFrom(activeEditor)), ([listType, theEditor]) => {\n      theEditor == null ? void 0 : theEditor.dispatchCommand(ListTypeCommandMap.get(listType), void 0);\n    });\n    r.sub(r.pipe(currentSelection, r.o.withLatestFrom(activeEditor)), ([selection, theEditor]) => {\n      if (!selection || !theEditor) {\n        return;\n      }\n      const anchorNode = selection.anchor.getNode();\n      let element = anchorNode.getKey() === \"root\" ? anchorNode : $findMatchingParent(anchorNode, (e) => {\n        const parent = e.getParent();\n        return parent !== null && $isRootOrShadowRoot(parent);\n      });\n      if (element === null) {\n        element = anchorNode.getTopLevelElementOrThrow();\n      }\n      const elementKey = element.getKey();\n      const elementDOM = theEditor.getElementByKey(elementKey);\n      if (elementDOM !== null) {\n        if ($isListNode(element)) {\n          const parentList = $getNearestNodeOfType(anchorNode, ListNode);\n          const type = parentList ? parentList.getListType() : element.getListType();\n          r.pub(currentListType, type);\n        } else {\n          r.pub(currentListType, null);\n        }\n      }\n    });\n    return { currentListType, applyListType };\n  },\n  [coreSystem]\n);\nconst [\n  /** @internal */\n  listsPlugin,\n  /** @internal */\n  listsPluginHooks\n] = realmPlugin({\n  id: \"lists\",\n  systemSpec: listsSystem,\n  init: (realm) => {\n    var _a;\n    realm.pubKey(\"addImportVisitor\", MdastListVisitor);\n    realm.pubKey(\"addImportVisitor\", MdastListItemVisitor);\n    realm.pubKey(\"addLexicalNode\", ListItemNode);\n    realm.pubKey(\"addLexicalNode\", ListNode);\n    realm.pubKey(\"addExportVisitor\", LexicalListVisitor);\n    realm.pubKey(\"addExportVisitor\", LexicalListItemVisitor);\n    (_a = realm.getKeyValue(\"rootEditor\")) == null ? void 0 : _a.registerCommand(INDENT_CONTENT_COMMAND, () => !isIndentPermitted(7), COMMAND_PRIORITY_CRITICAL);\n    realm.pubKey(\"addComposerChild\", TabIndentationPlugin);\n    realm.pubKey(\"addComposerChild\", ListPlugin);\n  }\n});\nfunction getElementNodesInSelection(selection) {\n  const nodesInSelection = selection.getNodes();\n  if (nodesInSelection.length === 0) {\n    return /* @__PURE__ */ new Set([selection.anchor.getNode().getParentOrThrow(), selection.focus.getNode().getParentOrThrow()]);\n  }\n  return new Set(nodesInSelection.map((n) => $isElementNode(n) ? n : n.getParentOrThrow()));\n}\nfunction isIndentPermitted(maxDepth) {\n  const selection = $getSelection();\n  if (!$isRangeSelection(selection)) {\n    return false;\n  }\n  const elementNodesInSelection = getElementNodesInSelection(selection);\n  let totalDepth = 0;\n  for (const elementNode of elementNodesInSelection) {\n    if ($isListNode(elementNode)) {\n      totalDepth = Math.max($getListDepth(elementNode) + 1, totalDepth);\n    } else if ($isListItemNode(elementNode)) {\n      const parent = elementNode.getParent();\n      if ((parent == null ? void 0 : parent.getChildren().length) === 1) {\n        const grandParentListItem = parent == null ? void 0 : parent.getParent();\n        if ($isListItemNode(grandParentListItem) && grandParentListItem.getChildren().length === 1) {\n          return false;\n        }\n      }\n      if (!$isListNode(parent)) {\n        throw new Error(\"ListMaxIndentLevelPlugin: A ListItemNode must have a ListNode for a parent.\");\n      }\n      totalDepth = Math.max($getListDepth(parent) + 1, totalDepth);\n    }\n  }\n  return totalDepth <= maxDepth;\n}\nexport {\n  listsPlugin,\n  listsPluginHooks,\n  listsSystem\n};\n"],
  "mappings": "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",
  "names": ["$getListDepth", "$isListItemNode", "$isListNode", "$createListItemNode", "$createListNode", "ListItemNode", "ListNode", "INSERT_UNORDERED_LIST_COMMAND", "INSERT_ORDERED_LIST_COMMAND", "REMOVE_LIST_COMMAND", "TabIndentationPlugin", "ListPlugin", "import_list", "import_list", "import_list", "import_list"]
}
